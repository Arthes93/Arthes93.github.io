{"meta":{"title":"Victor","subtitle":"백문이 불여일타","description":"백문이 불여일타","author":"ckck803","url":"https://ckck803.github.io","root":"/"},"pages":[{"title":"안녕하세요!","date":"2021-01-29T02:42:17.000Z","updated":"2021-02-16T15:17:29.131Z","comments":true,"path":"about/index.html","permalink":"https://ckck803.github.io/about/index.html","excerpt":"","text":"안녕하세요 저는 꾸준히 성장하고 싶은 개발자 입니다. 2020년 하반기 인턴 공채에 합격해 전환 면접을 거쳐 어엿한 2021년에 신입개발자가 됐습니다. 저는 현재 제조??? 운영파트 쪽에서 일하고 있습니다. 개발이 너무 어려웠어요저는 처음에 개발이 너~~~무 어려웠답니다. 누구나 그랬듯이 C언어의 포인터 맛을 보고 컴공은 내 길이 아니구나! 싶어 개발자의 길을 생각하지 않았어요. 3학년때는 부모님의 권유(부모님 두분다 공기업)를 받아 공무원 준비를 했다가 3학년 말 때 이럴꺼면 내가 왜 대학을 왔을까라는 질문과 스스로의 전문성을 쌓고 싶다는 마음으로 커리어를 돌리게 됐답니다. 그 선택을 진심으로 후회하지 않습니다! 일단 도전해보자대학교를 졸업할 때 쯤 알고리즘에 손을 대기 시작했답니다. 백준 사이트는 전역하자마자 알았지만 알고리즘 자체가 너무 겁났어요! 어떻게 다가가야 할지도 모르겠고 그 누구도 가르켜 주지 않았으니깐요! 그러게 두려워 하다가 결국 아무것도 못한 제 자신을 보면서 모르면 그냥 공식을 암기해 버리자!라는 생각으로 도전을 했고 처음에는 다른 사람이 푼 문제 코드를 보고 읽고 이해한 상태로 코드를 짜고 하니깐 생각보다 괜찮더라고요! 이렇게 문제를 풀어가면서 나오는 맞았습니다.가 쌓일 수록 쾌감이 너무너무 짜릿했어요! 그리고 생각보다 무서워할 만한게 아니라는 것도 알았어요! 이렇게 5개월 동안 아침 9시부터 시작해 5시까지 매일 꾸준히 문제를 풀어가다보니 실력이 쌓여있는 제 모습도 볼 수 있었답니다. 지금은 개발이 너무너무 좋아요제가 제 손으로 무언가를 만들고 고민하는게 너무 재미있더라고요! 인턴때 MES 페이지를 개선하는 프로젝트를 맡앗는데 제가 만든 프로그램이 배포되고 누군가가 사용한다고 하니 진짜 너무 좋았어요! 그래서 야근도 자연스럽게 재미있게 했었죠!!! 진짜 코드를 짜다보면 시간이 너무 후딱가서 시간 봤을 때 놀란 적도 있었어요! 지금도 꾸준히 공부중이에요저는 스프링부트를 좋아해서 인프런을 통해서 학습도 꾸준히 하고 있고 배운 내용을 활용하고 싶어 간단한 토이 프로젝트를 만든 후 블로그에 꾸준히 올릴 계획 입니다! 개발자로 커리어를 정한 이상 앞으로 꾸준히 나아가기 위해 노력하고 공부할겁니다.모든 것은 처음이 두렵지 시작해보면 별 것 아닌 것들이 많습니다!멈취 있지 말고 꾸준히 나아가라! 사람은 항상 성장할 줄 알아야 한다!깃 허브 : https://github.com/Astro86깃 허브2 : https://github.com/Arthes93"}],"posts":[{"title":"Spring Security - UsernamePasswordAuthenticationFilter","slug":"springboot/security/study/usernamepasswordAuthenticationFilter","date":"2021-03-20T13:25:35.000Z","updated":"2021-03-19T17:19:34.183Z","comments":true,"path":"2021/03/20/springboot/security/study/usernamepasswordAuthenticationFilter/","link":"","permalink":"https://ckck803.github.io/2021/03/20/springboot/security/study/usernamepasswordAuthenticationFilter/","excerpt":"","text":"UsernamePasswordAuthenticationFilterAbstractAuthenticationProcessingFilter를 상속한 객체로 Username과 Password를 이용해 보안인증을 진행할 때 사용하는 Filter이다. 1. Authentication 객체 생성 사용자 요청으로 부터 username과 password를 가져온다. username과 password를 Authentication을 구현한 UsernamePasswordAuthenticationToken 객체를 생성 생성된 Authentication 객체는 AuthenticationManager 객체를 통해 인증을 진행한다. Spring Security에서는 AuthenticationManager 객체를 구현한 ProviderManager 객체를 사용한다. UsernamePasswordAuthenticationFilter.java 12345678910111213141516171819202122@Overridepublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); &#125; // reqeust로부터 username을 가져온다. String username = obtainUsername(request); username = (username != null) ? username : &quot;&quot;; username = username.trim(); // request로부터 password를 가져온다. String password = obtainPassword(request); password = (password != null) ? password : &quot;&quot;; UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); // Allow subclasses to set the &quot;details&quot; property setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest);&#125; 2. ProviderManager를 통한 인증 진행ProviderManager 객체는 인증을 직접 진행하는 하지 않는다. 대신, 인증 위한 다양한 AuthenticationProvider 객체들을 가지고 있고 AuthenticationProvider 객체에게 인증을 위임하는 형태로 인증을 진행한다. ProviderManager에서 적절한 AuthenticationProvider 객체를 가져온다. 가져온 AuthenticationProvider를 이용해 Authentication객체 인증을 진행 인증이 완료 되면 새로운 Authentication 객체를 반환하게 된다. 만일 현재 ProviderManager에서 적절한 AuthenticationProvider 객체가 없다면 부모 ProviderManager로 이동해 인증을 시도한다. ProviderManager.java (인증 프로세스를 중심으로 보기 위해 예외처리와 관련된 부분은 삭제를 했다.) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); Authentication result = null; Authentication parentResult = null; // 인증을 진행하기 위한 AuthenticationProvider를 가져온다. for (AuthenticationProvider provider : getProviders()) &#123; // AuthenticationProvider가 Authentication객체 인증을 지원하는지 확인 if (!provider.supports(toTest)) &#123; continue; &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; // 기존의 Authentication 객체와 result를 이용해 새로운 Authentication 객체를 생성 copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException | InternalAuthenticationServiceException ex) &#123; prepareException(ex, authentication); throw ex; &#125; catch (AuthenticationException ex) &#123; lastException = ex; &#125; &#125; if (result == null &amp;&amp; this.parent != null) &#123; // Allow the parent to try. try &#123; parentResult = this.parent.authenticate(authentication); result = parentResult; &#125; catch (ProviderNotFoundException ex) &#123; &#125; catch (AuthenticationException ex) &#123; parentException = ex; lastException = ex; &#125; &#125; if (result != null) &#123; if (this.eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123; // 인증을 완료한 후에 Authentication 객체에서 Credentials와 같은 민감한 정보를 지운다. ((CredentialsContainer) result).eraseCredentials(); &#125; if (parentResult == null) &#123; this.eventPublisher.publishAuthenticationSuccess(result); &#125; // 인증이 완료된 Authentication 객체를 반환한다. return result; &#125; // 다양한 예외 처리들 생략 //&#125; 인증 전 Authentication 객체인증 전 Authenticatin 객체내의 principal에는 username이 credentials는 password가 들어있고, 인증 유무를 나타내는 authenticated 값이 false로 나타나 있다. 인증 후 Authentication 객체인증을 진행한 후 인증 전과 다르게 Authenticatin 객체의 principal에는 User 객체가 들어갔고 authenticated 값이 true가 됐다. 최종적으로 반환 될 때는 Authenticatin 객체에서 credentials를 지우고 반환한다. ProviderManager hierarchy각 ProviderManager에는 AuthenticationProvider 객체들이 있다. 만약 현재의 ProviderManager에 적절한 AuthenticationProvider가 없을 경우 parent ProviderManager로 이동하게 된다. parent ProviderManager 역시 AuthenticationProvider 객체들이 존재한다. 여기서의 parent는 상속 개념이 아니라 field값으로 parent를 가지고 있다. 3. 인증 완료 후 작업인증이 완료된 후 작업으로는 Session에 대한 처리와 SecurityContextHolder에 Authentication 객체를 등록하는 일이 남아 있다. AbstractAuthenticationProcessingFilter.java 1234567891011121314151617181920212223242526272829303132private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (!requiresAuthentication(request, response)) &#123; chain.doFilter(request, response); return; &#125; try &#123; // 인증이 완료 된 후 Authentication 객체를 반환받는다. Authentication authenticationResult = attemptAuthentication(request, response); if (authenticationResult == null) &#123; return; &#125; // Session에 대한 설정을 한다. Session Id를 변경 this.sessionStrategy.onAuthentication(authenticationResult, request, response); // Authentication success if (this.continueChainBeforeSuccessfulAuthentication) &#123; chain.doFilter(request, response); &#125; // SecurityContextHlder에 Authentication 객체를 등록 successfulAuthentication(request, response, chain, authenticationResult); &#125; catch (InternalAuthenticationServiceException failed) &#123; this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, failed); unsuccessfulAuthentication(request, response, failed); &#125; catch (AuthenticationException ex) &#123; // Authentication failed unsuccessfulAuthentication(request, response, ex); &#125;&#125; SecurityContextHolder에 Authentication 객체를 등록successfulAuthentication 메소드는 인증이 성공적으로 이루어 졌을 때 호출되는 메소드로 크게 3가지 작업을 진행한다. SecurityContextHolder로부터 SecurityContext 객체를 가져와 Authentication 객체를 넣어준다. Remember-Me에 대한 설정을 해준다. 인증이 완료 되면 successHandler를 이용해 정상적으로 인증이 완료 됐을 때의 작업을 진행한다. SecurityConfig에서 http.successHandler() 메소드로 등록한 Handler객체가 실행된다. AbstractAuthenticationProcessingFilter.java 1234567891011121314151617protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; SecurityContextHolder.getContext().setAuthentication(authResult); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult)); &#125; this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); &#125; this.successHandler.onAuthenticationSuccess(request, response, authResult);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"}]},{"title":"1194-달이차오른다_가자","slug":"algorithm/baekjoon/BFS/1194-달이차오른다-가자","date":"2021-03-19T17:21:07.000Z","updated":"2021-03-19T17:21:23.451Z","comments":true,"path":"2021/03/20/algorithm/baekjoon/BFS/1194-달이차오른다-가자/","link":"","permalink":"https://ckck803.github.io/2021/03/20/algorithm/baekjoon/BFS/1194-%EB%8B%AC%EC%9D%B4%EC%B0%A8%EC%98%A4%EB%A5%B8%EB%8B%A4-%EA%B0%80%EC%9E%90/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;int N, M;char Map[55][55];bool check[1 &lt;&lt; 6][55][55];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;queue&lt;pair&lt;int, int&gt;&gt; q;int startY, startX;struct point &#123; int y; int x; int key; int count;&#125;;int bfs() &#123; queue&lt;point&gt; q; q.push(&#123;startY, startX, 0, 0&#125;); check[0][startY][startX] = true; while (!q.empty()) &#123; int cntY = q.front().y; int cntX = q.front().x; int cntKey = q.front().key; int cntCount = q.front().count; q.pop(); if (Map[cntY][cntX] == &#x27;1&#x27;) &#123; return cntCount; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt;= ny || ny &gt; N || 0 &gt;= nx || nx &gt; M) &#123; continue; &#125; if (check[cntKey][ny][nx] == true) &#123; continue; &#125; if (Map[ny][nx] == &#x27;.&#x27;) &#123; check[cntKey][ny][nx] = true; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; else &#123; // 열쇠에 마주쳤을 경우 if (&#x27;a&#x27; &lt;= Map[ny][nx] &amp;&amp; Map[ny][nx] &lt;= &#x27;f&#x27;) &#123; int key = (1 &lt;&lt; (Map[ny][nx] - &#x27;a&#x27;)); check[cntKey | key][ny][nx] = true; q.push(&#123;ny, nx, cntKey | key, cntCount + 1&#125;); &#125; // 문을 만났을 경우 if (&#x27;A&#x27; &lt;= Map[ny][nx] &amp;&amp; Map[ny][nx] &lt;= &#x27;F&#x27;) &#123; int door = (1 &lt;&lt; (Map[ny][nx] - &#x27;A&#x27;)); if (door &amp; cntKey) &#123; check[cntKey][ny][nx] = true; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; &#125; // 출구를 만났을 경우 if (Map[ny][nx] == &#x27;1&#x27;) &#123; q.push(&#123;ny, nx, cntKey, cntCount + 1&#125;); &#125; &#125; &#125; &#125; return -1;&#125;void init() &#123; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; Map[i][j]; if (Map[i][j] == &#x27;0&#x27;) &#123; startY = i; startX = j; Map[i][j] = &#x27;.&#x27;; &#125; &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; N &gt;&gt; M; init(); cout &lt;&lt; bfs() &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[],"tags":[]},{"title":"Spring Security - WebSecurityConfigurerAdatper","slug":"springboot/security/study/web-security-configurer","date":"2021-03-19T13:25:35.000Z","updated":"2021-03-19T16:59:17.050Z","comments":true,"path":"2021/03/19/springboot/security/study/web-security-configurer/","link":"","permalink":"https://ckck803.github.io/2021/03/19/springboot/security/study/web-security-configurer/","excerpt":"","text":"Spring Security - WebSecurityConfigurerAdatper스프링 Scurity에 대한 설정은 WebSecurityConfigurer 인터페이스 구현하거나 WebSecurityConfigurerAdapter 클래스를 상속해 설정을 할 수 있다. 인증 방식 설정 configure(AuthenticationManagerBuilder auth) 인증 방식과 관련된 설정을 하기 위한 메소드 AuthenticationManagerBuilder는 인증객체(AuthenticationManager)를 생성하기 위한 클래스이다. In Memory authentication나 UserDetailsService를 사용하는 다양한 인증 방식을 손 쉽게 구축할 수 있도록 지원한다. configure(AuthenticationManagerBuilder auth) 123456private final CustomUserDetailsService customUserDetailsService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService);&#125; 전역적인 Security 설정 configure(WebSecurity web) 전역적인 Security 설정을 하기 위해 사용하는 메소드 정적 파일에 대한 보안 예외처리와 같이 Security Filter Chain에 대한 예외처리를 할 때 사용한다. WebSecurity 클래스는 Spring Security에서 FilterChainProxy를 생성한다. configure(WebSecurity web) 1234567@Overridepublic void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;);&#125; Resource별로 Security를 설정 configure(HttpSecurity http) Resource별로 Security를 설정하기 위한 메소드이다. HttpSecurity 클래스를 통해 인증, 인가와 관련된 Web 기반의 보안 설정을 할 수 있다. 인증 : Form Login, Http Basic, OAuth2 Login 등 인가 : Matchers, Role, Authenticate, permit 등 configure(HttpSecurity http) 123456789101112131415161718192021222324252627282930313233343536@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // 인가 http .authorizeRequests() // 인가에 대한 설정을 한다. .antMatchers(&quot;/loginPage&quot;).permitAll() // /loginPage 접근시에는 인증이 필요하지 않다. .anyRequest().authenticated(); // 다른 모든 리소스에 접그하기 위해서는 인증이 필요하다 // 인증 http .formLogin() // Form Login 방식의 인증을 사용한다. .loginPage(&quot;/loginPage&quot;) // 로그인 페이지를 설정한다. .defaultSuccessUrl(&quot;/&quot;) // Login을 성공한 후 / 페이지로 이동하게 된다. .failureUrl(&quot;/loginPage&quot;) // 로그인 실패시 /loginPage로 이동하게 된다. .usernameParameter(&quot;username&quot;) // 요청 파라미터에서 username을 usernameParameter로 사용한다. .passwordParameter(&quot;password&quot;) // 요청 파라미터에서 password를 passwordParameter로 사용한다. .loginProcessingUrl(&quot;/login_proc&quot;) // 로그인을 진행하기 위한 URL // 로그인이 성공했을 때 처리하기 위한 Handler .successHandler(new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse , Authentication authentication) throws IOException, ServletException &#123; httpServletResponse.sendRedirect(&quot;/&quot;); &#125; &#125;) // 로그인이 실패했을 때 처리하기 위한 Handler .failureHandler(new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse , AuthenticationException e) throws IOException, ServletException &#123; httpServletResponse.sendRedirect(&quot;/loginPage&quot;); &#125; &#125;);&#125; 패스워드 암호화Spring Boot에서는 사용자의 Password는 암호화된 상태로 저장이 돼야 한다. 암호화가 안된 상태로 저장하게 되면 사용자 인증시에 오류가 발생하게 된다. 그래서 Password를 암호화된 상태로 저장할 수 있도록 PasswordEncoder 인터페이스를 제공한다. PasswordEncoder PasswordEncoder 인터페이스는 보통 패스워드를 단방향으로 변환한다. 즉 다시 원래대로 되돌릴 수 없다는 의미이다. 그래서 Hash 알고리즘을 사용한다. BcryptPasswordEncoder Argon2PasswordEncoder Pbkdf2PasswordEncoder SCryptPasswordEncoder 1234@Beanpublic PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"}]},{"title":"백준 1406 - 후위표기식","slug":"algorithm/baekjoon/자료구조/스택/1918-후위표기식","date":"2021-03-15T11:10:40.000Z","updated":"2021-03-19T17:12:36.807Z","comments":true,"path":"2021/03/15/algorithm/baekjoon/자료구조/스택/1918-후위표기식/","link":"","permalink":"https://ckck803.github.io/2021/03/15/algorithm/baekjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/1918-%ED%9B%84%EC%9C%84%ED%91%9C%EA%B8%B0%EC%8B%9D/","excerpt":"","text":"https://www.acmicpc.net/problem/1918 문제 해설문제를 해결할 때 후위 표기식에 대한 명확한 이해와 연산자 우선순위에 대해 고려 해야 한다. 연산자를 별도의 stack에 쌓아가면서 후위 표기식을 만든다. stack에 연산자를 넣기 전에 연산자 비교를 통해 stack에 넣을 려는 연산자 우선순위 보다 stack에 있는 연산자의 우선순위가 작을 때까지 계속해서 stack에서 연산자를 꺼내 후위 표기식에 추가해준다. 연산자 우선순위 (가 제일 높은 우선순위다. * 와 /가 그 다음 우선순위 + 와 -가 다음 우선순위를 갖고 있다. )가 제일 낮은 우선순위다. (를 만날때까지 모든 연산자를 stack에서 꺼낸다. 소스 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;string str;string result;int main(void) &#123; cin &gt;&gt; str; stack&lt;char&gt; operation; for (int i = 0; i &lt; str.length(); i++) &#123; char cntChar = str[i]; if (cntChar == &#x27;(&#x27;) &#123; operation.push(cntChar); &#125; else if (cntChar == &#x27;*&#x27; || cntChar == &#x27;/&#x27;) &#123; while (!operation.empty() &amp;&amp; (operation.top() == &#x27;*&#x27; || operation.top() == &#x27;/&#x27;)) &#123; result += operation.top(); operation.pop(); &#125; operation.push(cntChar); &#125; else if (cntChar == &#x27;+&#x27; || cntChar == &#x27;-&#x27;) &#123; while (!operation.empty() &amp;&amp; (operation.top() != &#x27;(&#x27;)) &#123; result += operation.top(); operation.pop(); &#125; operation.push(cntChar); &#125; else if (cntChar == &#x27;)&#x27;) &#123; while (!operation.empty() &amp;&amp; operation.top() != &#x27;(&#x27;) &#123; result += operation.top(); operation.pop(); &#125; operation.pop(); &#125; else &#123; result += cntChar; &#125; &#125; while (!operation.empty()) &#123; result += operation.top(); operation.pop(); &#125; cout &lt;&lt; result &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"}]},{"title":"프로그래머스 - 수식 최대화","slug":"algorithm/프로그래머스/자료구조/스택/67257-수식최대화","date":"2021-03-15T11:10:40.000Z","updated":"2021-03-19T17:13:01.600Z","comments":true,"path":"2021/03/15/algorithm/프로그래머스/자료구조/스택/67257-수식최대화/","link":"","permalink":"https://ckck803.github.io/2021/03/15/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/67257-%EC%88%98%EC%8B%9D%EC%B5%9C%EB%8C%80%ED%99%94/","excerpt":"","text":"https://programmers.co.kr/learn/courses/30/lessons/67257 문제 해설경우의 수 문제이다. 모든 경우의 연산자 우선순위를 만들어 해당 연산자 우선순위를 이용해 연산을 진행하면 된다. 중위표기식으로 나타난 식을 후위 표기식으로 바꿔서 문제를 해결 했다. 경우의 수 만들기만들 수 있는 모든 연산자 우선순위를 만들어줘야 한다. DFS를 이용해 모든 경우의 수를 만들어 줬다. 12345678910111213141516void makeAllCase(int depth) &#123; if (depth == 3) &#123; allCase.push_back(cntCase); &#125; for (int i = 0; i &lt; 3; i++) &#123; int cntOper = operation[i]; if (check[i] == false) &#123; check[i] = true; cntCase[depth] = cntOper; makeAllCase(depth + 1); check[i] = false; &#125; &#125;&#125; 연산자 우선순위를 가반으로 한 연산 가장 높은 우선순위의 연산자가 들어왔을 때 Stack을 확인해 같은 먼저 들어온 같은 우선순위의 연산자가 있는지 확인한다. 같은 우선순위의 연산자가 Stack에 있는 경우 pop 해서 해당 연산을 진행한 후 지금 들어온 연산자를 push한다. 없는 경우에는 Stack에 push 한다. 두번째 우선 순위가 연산자가 들어온 경우 Stack을 확인해 우선순위가 같거나 큰 연산자가 없어질 때까지 연산을 진행한 후 pop 한다. Stack에 우선순위가 같거나 큰 연산자가 없을 경우에는 Stack에 push 한다. 세번째 우선 순위의 연산자가 들어온 경우 Stack을 확인해 우선순위가 같거나 큰 연산자가 없어질 때까지 연산을 진행한 후 pop 한다. Stack에 우선순위가 같거나 큰 연산자가 없을 경우에는 Stack에 push 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 첫번째 우선순위의 연산자가 들어온 경우if (cntChar == cnt_priority[0]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() == cnt_priority[0]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar);&#125;// 두번째 우선순위의 연산자가 들어온 경우if (cntChar == cnt_priority[1]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() != cnt_priority[2]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar);&#125;// 세번째 우선순위의 연산자가 들어온 경우if (cntChar == cnt_priority[2]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty()) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar);&#125; Stack을 이용한 소스 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;char operation[3] = &#123;&#x27;*&#x27;, &#x27;+&#x27;, &#x27;-&#x27;&#125;;bool check[3];vector&lt;char&gt; cntCase(3);vector&lt;vector&lt;char&gt;&gt; allCase;void makeAllCase(int depth) &#123; if (depth == 3) &#123; allCase.push_back(cntCase); &#125; for (int i = 0; i &lt; 3; i++) &#123; int cntOper = operation[i]; if (check[i] == false) &#123; check[i] = true; cntCase[depth] = cntOper; makeAllCase(depth + 1); check[i] = false; &#125; &#125;&#125;long long calValue1Value2(long long value1, long long value2, char oper) &#123; long long result = 0; if (oper == &#x27;*&#x27;) &#123; result = value2 * value1; &#125; else if (oper == &#x27;+&#x27;) &#123; result = value2 + value1; &#125; else &#123; result = value2 - value1; &#125; return result;&#125;long long solveExpression(string expression) &#123; long long maxValue = 0; for (vector&lt;char&gt; cnt_priority : allCase) &#123; stack&lt;long long&gt; opernand; stack&lt;char&gt; operation; string value = &quot;&quot;; for (int i = 0; i &lt; expression.size(); i++) &#123; char cntChar = expression[i]; if (&#x27;0&#x27; &lt;= cntChar &amp;&amp; cntChar &lt;= &#x27;9&#x27;) &#123; value += cntChar; &#125; if (cntChar == cnt_priority[0]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() == cnt_priority[0]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar); &#125; if (cntChar == cnt_priority[1]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty() &amp;&amp; operation.top() != cnt_priority[2]) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar); &#125; if (cntChar == cnt_priority[2]) &#123; opernand.push(stol(value)); value = &quot;&quot;; while (!operation.empty()) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(result); &#125; operation.push(cntChar); &#125; &#125; opernand.push(stol(value)); while (!operation.empty()) &#123; long long value1 = opernand.top(); opernand.pop(); long long value2 = opernand.top(); opernand.pop(); char oper = operation.top(); operation.pop(); long long result = calValue1Value2(value1, value2, oper); opernand.push(abs(result)); &#125; if (maxValue &lt; opernand.top()) &#123; maxValue = opernand.top(); &#125; &#125; return maxValue;&#125;long long solution(string expression) &#123; long long answer = 0; makeAllCase(0); answer = solveExpression(expression); return answer;&#125; dq를 이용한 문제 해결123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char operation[3] = &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;&#125;;bool check[3];vector&lt;char&gt; op(3);vector&lt;vector&lt;char&gt;&gt; operations;deque&lt;long long&gt; dq_opernand;deque&lt;char&gt; dq_operator;ll max_value = 0;void nPr(int depth) &#123; if (3 == depth) &#123; vector&lt;char&gt; v(op); operations.push_back(op); return; &#125; for (int i = 0; i &lt; 3; i++) &#123; if (check[i] == true) continue; op[depth] = operation[i]; check[i] = true; nPr(depth + 1); check[i] = false; &#125;&#125;void divideOperaion(string expression) &#123; string s; for (int i = 0; i &lt; expression.size(); i++) &#123; if (&#x27;0&#x27; &lt;= expression[i] &amp;&amp; expression[i] &lt;= &#x27;9&#x27;) &#123; s += expression[i]; &#125; else &#123; dq_opernand.push_back(stol(s)); dq_operator.push_back(expression[i]); s = &quot;&quot;; &#125; &#125; dq_opernand.push_back(stol(s));&#125;long long operValue(ll a, ll b, char op) &#123; if (op == &#x27;+&#x27;) &#123; return a + b; &#125; else if (op == &#x27;-&#x27;) &#123; return a - b; &#125; else &#123; return a * b; &#125;&#125;void operate(string expression) &#123; deque&lt;ll&gt; temp_opernand; deque&lt;char&gt; temp_operator; for (auto o : operations) &#123; deque&lt;ll&gt; copy_opernand(dq_opernand); deque&lt;char&gt; copy_operator(dq_operator); for (int i = 0; i &lt; 3; i++) &#123; char cnt_operation = o[i]; while (!copy_operator.empty()) &#123; if (copy_operator.front() == cnt_operation) &#123; ll value1 = copy_opernand.front(); copy_opernand.pop_front(); ll value2 = copy_opernand.front(); copy_opernand.pop_front(); char oper = copy_operator.front(); copy_operator.pop_front(); ll result = operValue(value1, value2, oper); copy_opernand.push_front(result); &#125; else &#123; temp_opernand.push_back(copy_opernand.front()); temp_operator.push_back(copy_operator.front()); copy_opernand.pop_front(); copy_operator.pop_front(); &#125; &#125; while (!copy_opernand.empty()) &#123; temp_opernand.push_back(copy_opernand.front()); copy_opernand.pop_front(); &#125; while (!temp_operator.empty()) &#123; copy_operator.push_back(temp_operator.front()); temp_operator.pop_front(); &#125; while (!temp_opernand.empty()) &#123; copy_opernand.push_back(temp_opernand.front()); temp_opernand.pop_front(); &#125; &#125; max_value = max(max_value, abs(copy_opernand.front())); &#125;&#125;long long solution(string expression) &#123; long long answer; nPr(0); divideOperaion(expression); operate(expression); answer = max_value; return answer;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Programmers","slug":"Programming/Programmers","permalink":"https://ckck803.github.io/categories/Programming/Programmers/"},{"name":"자료구조","slug":"Programming/Programmers/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Programmers/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Programmers/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Programmers/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"Programmers","slug":"Programmers","permalink":"https://ckck803.github.io/tags/Programmers/"}]},{"title":"백준 1406 - 에디터","slug":"algorithm/baekjoon/자료구조/스택/1406 - 에디터","date":"2021-03-15T06:23:54.000Z","updated":"2021-03-19T17:12:36.642Z","comments":true,"path":"2021/03/15/algorithm/baekjoon/자료구조/스택/1406 - 에디터/","link":"","permalink":"https://ckck803.github.io/2021/03/15/algorithm/baekjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/1406%20-%20%EC%97%90%EB%94%94%ED%84%B0/","excerpt":"","text":"https://www.acmicpc.net/problem/1406 문제 해설Stack을 이용한 문제 풀이기본적인 자료구조를 사용해 문제를 해결하는 문제이다. 두개의 스택을 이용해서 커서를 기점으로 커서 왼쪽에 있는 것들은 left 스택에 커서 오른쪽에 있는 단어들은 right 스택에 넣어서 관리를 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.IOException;import java.util.Scanner;import java.util.Stack;public class Main &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); Stack&lt;Character&gt; left = new Stack&lt;&gt;(); Stack&lt;Character&gt; right = new Stack&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; left.push(str.charAt(i)); &#125; int numOfCmd = sc.nextInt(); for (int i = 0; i &lt; numOfCmd; i++) &#123; String cmd = sc.next(); if (cmd.equals(&quot;L&quot;)) &#123; if (!left.isEmpty()) &#123; right.push(left.peek()); left.pop(); &#125; &#125; else if (cmd.equals(&quot;D&quot;)) &#123; if (!right.isEmpty()) &#123; left.push(right.peek()); right.pop(); &#125; &#125; else if (cmd.equals(&quot;B&quot;)) &#123; if (!left.isEmpty()) &#123; left.pop(); &#125; &#125; else if (cmd.equals(&quot;P&quot;)) &#123; char value = sc.next().charAt(0); left.push(value); &#125; &#125; while (!left.isEmpty()) &#123; right.push(left.peek()); left.pop(); &#125; StringBuilder stringBuilder = new StringBuilder(); while (!right.isEmpty()) &#123; stringBuilder.append(right.peek()); right.pop(); &#125; System.out.println(stringBuilder.toString()); &#125;&#125; LinkedList와 ListIterator를 이용한 문제 풀이해당 문제는 LinkedList를 이용해서도 문제를 해결할 수 있다. LinkedList의 원소에 List로 접근을 하게 되면 O(n) 의 시간이 걸려 시간 초과가 뜨게 된다. 때문에 다행이 문제는 Cursor위치를 한칸씩 밖에 못 움직이므로 ListIterator 라는 객체를 이용해 LinkedList를 관리하도록 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out)); String[] str = br.readLine().split(&quot;&quot;); List&lt;Character&gt; charList = new LinkedList&lt;&gt;(); ListIterator&lt;Character&gt; iter = charList.listIterator(); for (int i = 0; i &lt; str.length; i++) &#123; iter.add(str[i].charAt(0)); &#125; int index = charList.size(); int numOfCmd = Integer.parseInt(br.readLine()); for (int i = 0; i &lt; numOfCmd; i++) &#123; char[] inputs = br.readLine().toCharArray(); if (inputs[0] == &#x27;L&#x27;) &#123; if (iter.hasPrevious()) &#123; iter.previous(); &#125; &#125; else if (inputs[0] == &#x27;D&#x27;) &#123; if (iter.hasNext()) &#123; iter.next(); &#125; &#125; else if (inputs[0] == &#x27;B&#x27;) &#123; if (iter.hasPrevious()) &#123; iter.previous(); iter.remove(); &#125; &#125; else if (inputs[0] == &#x27;P&#x27;) &#123; char value = inputs[2]; iter.add(value); &#125; &#125; for (char c : charList) &#123; wr.write(c); &#125; wr.flush(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"}],"tags":[{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"}]},{"title":"Spring-JWT(JSON Web Token) - 4. JWT 다루기","slug":"springboot/security/JWT/spring-jwt-4","date":"2021-03-14T17:20:47.000Z","updated":"2021-03-15T03:29:10.164Z","comments":true,"path":"2021/03/15/springboot/security/JWT/spring-jwt-4/","link":"","permalink":"https://ckck803.github.io/2021/03/15/springboot/security/JWT/spring-jwt-4/","excerpt":"","text":"4. JWT 다루기JWT를 다루기 위한 Util Class만들기JwtUtil 객체는 Jwts.builder를 이용해 JWT를 생성하고 Jwts.parser를 이용해 Token을 JWT로 변환시켜 데이터를 가져오도록 한다. Jwts.builder(JwtBuilder) setHeader JWT의 Header에 대한 설정을 위한 메소드 setXXX setSubject, setExpiration, setIssuer, … Registed Payload는 각각에 해당하는 set 메소드들이 제공된다. setClaims JWT의 Claim 데이터를 추가하기 위한 메소드 signWith Header와 Payload를 갖고 screteKey로 서명한다. 암호화 알고리즘으로는 보통 HMAC or RSA 알고리즘을 사용한다. Jwts.parser(JwtParser) setSigningKey 데이터 위변조 확인을 위해 secretKey를 이용해 JWS에 대한 유효성 검증을 한다. secretKey를 이용한 검증 실패시 해당 JWT는 사용하지 못한다. parseClaimsJws token을 JWS로 파싱해준다. JwtUtil.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Componentpublic class JwtUtil &#123; private final String secretKey = &quot;ThisIsA_SecretKeyForJwtExample&quot;; public String generateToken(String username) &#123; String JSONWebToken = Jwts.builder() .setHeader(createHeader()) .setClaims(createClaims(username)) .setExpiration(createExpireDateForOneYear()) .signWith(SignatureAlgorithm.HS256, secretKey) .compact(); return JSONWebToken; &#125; private Map&lt;String, Object&gt; createHeader() &#123; Map&lt;String, Object&gt; header = new HashMap&lt;&gt;(); header.put(&quot;typ&quot;, &quot;JWT&quot;); header.put(&quot;alg&quot;, &quot;HS256&quot;); header.put(&quot;regDate&quot;, System.currentTimeMillis()); return header; &#125; private Map&lt;String, Object&gt; createClaims(String username) &#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&quot;username&quot;, username); &#125; private Date createExpireDateForOneYear() &#123; // 토큰 만료시간은 30일으로 설정 Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DATE, 30); return calendar.getTime(); &#125; private Claims getAllClaims(String token) &#123; return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(token) .getBody(); &#125; public String getUsername(String token) &#123; Claims claims = getAllClaims(token); String username = claims.get(&quot;username&quot;, String.class); return username; &#125; public Date getExpiration(String token) &#123; Claims claims = getAllClaims(token); return claims.getExpiration(); &#125; public Boolean validateToken(String token, UserDetails userDetails) &#123; final String username = getUsername(token); return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token)); &#125; private Boolean isTokenExpired(String token) &#123; return getExpiration(token).before(new Date()); &#125;&#125; JWT를 이용한 인증을 위해 새로운 Filter정의하기OncePerRequestFilter를 상속 받아 JWT로 인증을 진행하는 JwtAuthenticationFilter를 생성한다.JwtAuthenticationFilter에서는 요청이 들어왔을 때 Token이 있는지 확인하고 해당 Token을 이용해 인증을 진행한 후 AuthenticationToken을 생성해 SecurityContextHolder에 저장한다. UsernamePasswordAuthenticationToken 사용자의 Username과 Password를 이용하여 AuthenticationToken을 생성한다. JwtAuthenticationFilter.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Componentpublic class JwtAuthenticationFilter extends OncePerRequestFilter &#123; private final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class); @Autowired private JwtUtil jwtUtil; @Autowired private CustomUserDetailsService service; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; // Http 요청이 들어왔을 때 header를 검사해 Authorization 값을 가져온다. String authorizationHeader = request.getHeader(&quot;Authorization&quot;); String token = null; String username = null; // 인증 토큰을 받았을 경우 // Bearer 토큰인지 확인한다. if (authorizationHeader != null &amp;&amp; authorizationHeader.startsWith(&quot;Bearer &quot;)) &#123; token = authorizationHeader.substring(7); username = jwtUtil.extractUsername(token); &#125; // Bearer 토큰으로부터 추출한 username을 이용해 // 해당 유저가 등록된 유저인지 검증한다. if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123; UserDetails userDetails = service.loadUserByUsername(username); if (jwtUtil.validateToken(token, userDetails)) &#123; UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); usernamePasswordAuthenticationToken .setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; 로그인을 위한 Controller 추가Username과 Password를 이용해 /api/user/login 경로로 인증을 시도하면 AuthenticationManager 객체를 이용해 인증을 진행하고 인증이 성공적으로 완료 되면 JWT를 생성해 Header에 JWT를 넣어 Status code : 200과 함께 반환한다. JwtController.java 1234567891011121314151617181920212223242526....private final AuthenticationManager authenticationManager;private final JwtUtil jwtUtil;@PostMapping(&quot;/login&quot;)public ResponseEntity login(@RequestBody AuthRequest authRequest) throws Exception &#123; String username = authRequest.getUsername(); String password = authRequest.getPassword(); try &#123; // AuthnRequest로부터 받은 username과 password를 이용하여 UsernamePasswordAuthenticationToken을 생성한 후 // 생성된 토큰을 이용해 인증을 시도한다. authenticationManager.authenticate( new UsernamePasswordAuthenticationToken(username, password)); &#125; catch (Exception ex) &#123; throw new Exception(&quot;inavalid username/password&quot;); &#125; String token = jwtUtil.generateToken(authRequest.getUsername()); HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.add(&quot;Authorization&quot;, &quot;Bearer &quot; +token); // 인증이 정상적으로 이루어진 경우 username을 이용해 JWT를 생성해 반환한다. return new ResponseEntity(httpHeaders, HttpStatus.OK);&#125; 권한을 갖고 접근하기 위한 Controller 추가 반환받은 JWT를 갖고 /api/user/access 경로로 접근하면 Permission to Access 문구가 반환된다. JwtController.java 1234@GetMapping(&quot;/access&quot;)public String accessByToken()&#123; return &quot;Permission to Access&quot;;&#125; Security 설정 추가하기AuthenticationManagerBuilder객체의 userDetailsService 메소드를 이용해 사용자가 정의한 CustomUserDetailsService 객체를 사용하도록 등록한다. SecurityConfig.java 12345@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 사용자가 정의한 UserDetailsService를 사용한다. auth.userDetailsService(customUserDetailsService);&#125; 회원가입을 위한 /api/user/signup 경로와 로그인을 위한 /api/user/login 경로는 인증전에 접근하기 위한 경로이므로 권한 없이 접근 가능해야 한다. 그외 모든 경로는 인증된 사용자만 접근 할 수 있도록 설정한다. 사용자 정의 Filter인 JwtAuthenticationFilter를 Spring Filter에 추가한다. SecurityConfig.java 123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable().authorizeRequests() .antMatchers(&quot;/api/user/login&quot;).permitAll() .antMatchers(&quot;/api/user/signup&quot;).permitAll() .anyRequest().authenticated() .and() // 토큰을 활용하면 세션이 필요 없으므로 STATELESS로 설정하여 Session을 사용하지 않는다. .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() // form 기반의 로그인에 대해 비활성화 한다. .formLogin().disable() // 새롭게 정의한 Filter를 등록한다. .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"JWT","slug":"Spring-Boot/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/JWT/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"JWT","slug":"JWT","permalink":"https://ckck803.github.io/tags/JWT/"}]},{"title":"Spring-JWT(JSON Web Token) - 3. Spring Security 적용하기","slug":"springboot/security/JWT/spring-jwt-3","date":"2021-03-14T15:49:30.000Z","updated":"2021-03-14T17:22:22.806Z","comments":true,"path":"2021/03/15/springboot/security/JWT/spring-jwt-3/","link":"","permalink":"https://ckck803.github.io/2021/03/15/springboot/security/JWT/spring-jwt-3/","excerpt":"","text":"3. 로그인의존성 추가Spring Boot에 Security를 적용하기 위해 Spring Security 의존성과 JWT를 사용하기위해 jjwt 의존성을 추가해주도록 한다. build.gradle 1234567dependencies &#123; .... implementation &#x27;org.thymeleaf.extras:thymeleaf-extras-springsecurity5&#x27; // https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt implementation group: &#x27;io.jsonwebtoken&#x27;, name: &#x27;jjwt&#x27;, version: &#x27;0.9.1&#x27; ....&#125; Security 설정하기Spring Security는 인증에 필요한 사용자 정보를 저장할 때 비밀번호는 PasswordEncoder 객체를 이용해 암호화된 Password로 저장돼야 한다. 현재 프로젝트에서는 PasswordEncoder를 구현한 BcryptPasswordEncoder 객체를 이용해 암호화를 할 것이다. 정적자원에 대한 접근은 Spring Filter를 거치지 않도록 설정을 추가한다. SecurityConfig.java 1234567891011121314151617181920212223242526272829303132333435363738394041@EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/static/&quot; , &quot;classpath:/public/&quot; , &quot;classpath:/&quot; , &quot;classpath:/resources/&quot; , &quot;classpath:/META-INF/resources/&quot; , &quot;classpath:/META-INF/resources/webjars/&quot; &#125;; @Override public void configure(WebSecurity web) &#123; web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations()); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable().authorizeRequests() .antMatchers(&quot;/api/user/signup&quot;).permitAll() .anyRequest().authenticated() .and() // 토큰을 활용하면 세션이 필요 없으므로 STATELESS로 설정하여 Session을 사용하지 않는다. .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() // form 기반의 로그인에 대해 비활성화 한다. .formLogin().disable(); &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 회원 가입 Service에 암호화 적용하기PasswordEncoder 객체를 이용해 암호화된 Password를 갖는 Account 객체를 생성하도록 변경한다. AccountService.java 1234567891011121314151617@Service@RequiredArgsConstructorpublic class AccountService &#123; private final AccountRepository accountRepository; private final PasswordEncoder passwordEncoder; public Account saveAccount(SignUpRequest signUpRequest) &#123; Account newAccount = Account.builder() .username(signUpRequest.getUsername()) .password(passwordEncoder.encode(signUpRequest.getPassword())) .role(Role.USER) .build(); return accountRepository.save(newAccount); &#125;&#125; username을 이용한 Account 객체 조회 조건 추가하기 AccountRepository.java 1234@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, String&gt; &#123; Optional&lt;Account&gt; findByUsername(String username);&#125; 인증에 필요한 User 객체 생성하기CustomUserDetailsService는 저장된 Account객체를 가져와 UserDetails객체로 변환해주는 역할을 한다. CustomUserDetailsService.java 12345678910111213141516@Service@RequiredArgsConstructorpublic class CustomUserDetailsService implements UserDetailsService &#123; private final AccountRepository accountRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; Account account = accountRepository .findByUsername(username) .orElseThrow(() -&gt; new UsernameNotFoundException(username + &quot;사용자 없음&quot;)); return new User(account.getUsername(), account.getPassword(), AuthorityUtils.createAuthorityList(account.getRole().getValue())); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"JWT","slug":"Spring-Boot/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/JWT/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"JWT","slug":"JWT","permalink":"https://ckck803.github.io/tags/JWT/"}]},{"title":"Spring-JWT(JSON Web Token) - 2. 회원가입","slug":"springboot/security/JWT/spring-jwt-2","date":"2021-03-14T13:11:14.000Z","updated":"2021-03-14T16:06:03.171Z","comments":true,"path":"2021/03/14/springboot/security/JWT/spring-jwt-2/","link":"","permalink":"https://ckck803.github.io/2021/03/14/springboot/security/JWT/spring-jwt-2/","excerpt":"","text":"2. 회원가입의존성 관계build.gradle 12345678910111213dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-security&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;org.springframework.security:spring-security-test&#x27;&#125; 회원가입을 위한 DTO 만들기SignUpRequest.java 1234567@Data@AllArgsConstructor@NoArgsConstructorpublic class SignUpRequest &#123; private String username; private String password;&#125; 회원 정보를 저장하기 위한 Entity 생성Account.java 12345678910111213141516@Data@NoArgsConstructor@AllArgsConstructor@Entity@Builderpublic class Account &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @Column(unique = true) private String username; private String password; private Role role;&#125; Account를 저장하기 위한 Repository 생성123@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, String&gt; &#123;&#125; 회원 가입 요청을 처리하기 위한 Service 생성12345678910111213141516@Service@RequiredArgsConstructorpublic class AccountService &#123; private final AccountRepository accountRepository; public Account saveAccount(SignUpRequest signUpRequest) &#123; Account newAccount = Account.builder() .username(signUpRequest.getUsername()) .password(signUpRequest.getPassword()) .role(Role.USER) .build(); return accountRepository.save(newAccount); &#125;&#125; Controller회원가입에 필요한 Username과 Password를 갖고 /api/user/signup에 Post 요청을 보내면 회원가입이 정상적으로 이루어진 경우 Status Code : 200이 반환되게 된다. JwtController.java 12345678910111213@RestController@RequestMapping(&quot;/api/user&quot;)@RequiredArgsConstructorpublic class UserController &#123; private final AccountService accountService; @PostMapping(&quot;/signup&quot;) public ResponseEntity signup(@RequestBody SignUpRequest signUpRequest)&#123; accountService.saveAccount(signUpRequest); return ResponseEntity.ok().build(); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"JWT","slug":"Spring-Boot/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/JWT/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"JWT","slug":"JWT","permalink":"https://ckck803.github.io/tags/JWT/"}]},{"title":"메모리 관리","slug":"computer-science/os/memory-management","date":"2021-03-07T15:16:13.000Z","updated":"2021-03-11T13:18:09.050Z","comments":true,"path":"2021/03/08/computer-science/os/memory-management/","link":"","permalink":"https://ckck803.github.io/2021/03/08/computer-science/os/memory-management/","excerpt":"","text":"메모리 관리 기본적인 메모리 관리 swapping 가상 메모리 Page replacement 알고리즘 세그멘테이션 프로그래머들이 가장 바라는 메모리는 바로 크고 빠르고 비 휘발성인것을 원한다. Memory Manager(메모리 관리자) 메모리 계층을 관리하는 운영체제의 일부분 사용하고 있는 메모리와 사용하고있지 않는 메모리를 계속해서 추적한다. 메모리를 프로세스에 할당하고 해제한다. 프로세스의 용량이 커서 메모리에 용량이 작을 경우 메모리와 디스크를 swapping한다. 기본적인 메모리 관리 기법paging이나 swapping이 없는 단일 프로그램메모리보다 더 큰 Program의 등장프로그램이 점점 커지다 보니 우리가 사용하는 메인 메모리보다 큰 프로그램이 생겨나게 됐다.이를 해결하기 위한 방법으로 overlay와 virtual memory 방법이 나왔다. overlay와 virtual memory의 기본 아이디어는 하나의 프로그램을 여러가지 조각으로 나누어 실행한다는 공통점이 있다. 하지만, overlay의 경우에는 프로그래머가 직접 프로그램들을 나누어야 하고 virtual memory의 경우에는 컴퓨터가 대신해준다는 차이점이 있다. Virtual MemoryVirtual Memory는 paging기법과 segmentation 기법을 이용한다. paging : 고정분할 segmentation : 가변분할","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"OS","slug":"CS/OS","permalink":"https://ckck803.github.io/categories/CS/OS/"}],"tags":[]},{"title":"TCP","slug":"computer-science/network/TCP","date":"2021-03-07T14:21:17.000Z","updated":"2021-03-11T13:17:42.371Z","comments":true,"path":"2021/03/07/computer-science/network/TCP/","link":"","permalink":"https://ckck803.github.io/2021/03/07/computer-science/network/TCP/","excerpt":"","text":"TCP(Transmission Control Protocol) TCP 서비스 연결 지향의 신뢰성이 있는 바이트 스트림 서비스를 제공한다. 양방향 통신을 지원한다.(Full-Duplex Communication) 흐름제어와 에러제어, 그리고 혼잡제어를 제공한다.(신뢰성 있는 전송) 신뢰성 있는 전송이란? 데이터가 손실, 중복되지 않고 순서가 어긋나지 않는 전송방식 바이트 스트림 서비스란? 데이터 송 수신시 버퍼 기능을 이용해 Byte 단위로 처리 TCP는 데이터 송/수신시 버퍼를 이용하기 때문에 흐름제어를 할 수 있다. Connection Oriented Protocal(연결 지향 프로토콜)연결지향 프로토콜은 다음과 같은 3가지 단계를 거치게 된다. 연결 데이터 전송 연결 종료 3-way handskaing 클라이언트가 서버로 SYN 패킷을 보낸다. 그리고 클라이언트는 SYN/ACK응답을 기다리는 SYN_SENT상태가 된다. 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN flog가 설정된 패킷을 발송하고 클라이언트가 ACK로 응답하기를 기다린다. 서버는 SYN_RECEIVED 상태가 된다. 클라이언트는 서버로 ACK를 보내게 되면 서버와 클라이언트가 연결이 이루어진다. 서버 상태는 ESTABLISHED가 된다. SYN(클라이언트) -&gt; SYN/ACK(서버) -&gt; ACK(클라이언트)SYN_SENT(클라이언트) -&gt; SYN_RECEIVED(서버) -&gt; ESTABLISED(서버) 4-way handshaking 클라이언트가 연결을 종료하겠다는 FIN 패킷을 전송한다. FIN 패킷을 받은 서버는 클라이언트에서 서버로 데이터를 전송하는 연결을 끊는다. 서버에서 클라이언트로 데이터를 전송하는 연결은 아직 살아있다.(Half-closed) 서버에서 클라이언트로의 통신이 끝나게 되면 서버에서 FIN 패킷을 전송한다. FIN 패킷을 받은 클라이언트는 마지막으로 ACK패킷을 보내게 되면 연결이 끊기게 된다. TCP에 사용되는 flag(control field) ACK(Acknowledgment) : 확인을 위한 flag SYN(Synchronize sequence numbers) : TCP를 이용해 연결을 만들 때 사용하는 flag FIN(Terminate the connection) : TCP 연결을 끊을 때 사용한다. URG(Urgent) : urgent data가 존재함을 알려준다. urgent data는 다른 데이터를 무시하고 바로 process로 보내진다. RST(Reset the connection) : 비정상적으로 connection을 끊을 때 사용한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"클라우드 서비스","slug":"computer-science/network/cloud","date":"2021-03-07T14:16:32.000Z","updated":"2021-03-11T13:17:36.327Z","comments":true,"path":"2021/03/07/computer-science/network/cloud/","link":"","permalink":"https://ckck803.github.io/2021/03/07/computer-science/network/cloud/","excerpt":"","text":"클라우드 서비스 종류IaaS(Infrastructure as a Service)인프라를 제공하는 방식 - 컴퓨터를 대여해주는 거라고 생각하면 이해하기 쉽다. 아마존의 AWS, MS의 Azure, 구글의 GCP Platform as a Service플랫폼을 제공하는 방식 - IaaS 서비스에 Runtime환경까지 설정이 이미 되어 있기 때문에 Software as a Service특정 소프트웨어를 제공하는 방식 - 드랍박스, 구글 Docs, 오피스365 장점 컴퓨팅 환경을 빠르게 구축할 수 있다는 장점이 있다. 사용한 만큼만 돈을 지불하면 된다. 특정기간 트래픽이 폭주하는 경우에 자원의 리소스 추가와 삭제가 기존의 on-premise방식에 비해 용이하다. 서버를 관리하기 위한 물리적 공간과 인적 자원에 대해 신경쓸 필요가 없어진다. 단점 트래픽처리에 따른 초과비용 위험 보안 이슈 - 자사의 프라이빗 서버에 저장하는것이 다른 외부인이 볼 수 있다는 단점이 있다.","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"}],"tags":[]},{"title":"스프링부트를 이용한 게시판 만들기 22 - Log4jdbc를 이용해 Query 로그 기록하기","slug":"springboot/sample-board/board-22-logging","date":"2021-03-06T12:59:57.000Z","updated":"2021-03-13T11:29:21.304Z","comments":true,"path":"2021/03/06/springboot/sample-board/board-22-logging/","link":"","permalink":"https://ckck803.github.io/2021/03/06/springboot/sample-board/board-22-logging/","excerpt":"","text":"22. Log4jdbc를 이용해 Query 로그 기록하기로그 레벨 TRACE &gt; DEBUG &gt; INFO &gt; WARN &gt; ERROR 로그 레벨은 TRACE로 갈 수록 표현되는 Log의 양이 많아지고 ERROR로 갈 수록 표현되는 Log의 양이 적어진다. Configure 파일 문법Logback Configure파일을 구성하는 3가지 태그가 있다. appender 로그의 출력 위치, 출력 형식및 로깅에 대한 설정(ex. 기간, 용량 등)을 지정한다 root 전역적인 로그 설정을 위해 사용한다. appender를 사용해 appender에 정의된 형식과 위치로 로그를 출력 여러개의 appender를 사용할 수 있다. logger root와는 반대로 class나 Package단위로 Logging 정책을 설정할 수 있다. 로그 메시지를 작성하기 위해 사용하는 클래스를 명시하고 appender를 사용해 appender에 정의된 형식과 위치로 로그를 출력한다. 여러개의 appender를 사용할 수 있다. appender 클래스의 종류 ch.qos.logback.core.ConsoleAppender 콘솔에 로그를 찍음 ch.qos.logback.core.FileAppender 파일에 로그를 찍음 ch.qos.logback.core.rolling.RollingFileAppender 여러개의 파일을 순회하면서 로그를 찍음 ch.qos.logback.classic.net.SMTPAppender 로그를 메일에 찍어 보냄 ch.qos.logback.classic.db.DBAppender 데이터베이스에 로그를 찍음 의존성 추가하기쿼리 로그를 저장하기 위해서는 log4jdbc 의존성을 추가해줄 필요가 있다. build.gradle 1implementation group: &#x27;com.integralblue&#x27;, name: &#x27;log4jdbc-spring-boot-starter&#x27;, version: &#x27;2.0.0&#x27; 설정 추가하기 jdbc.sqlonly SQL문만을 로그로 남긴다. jdbc.sqltiming SQL문과 해당 SQL을 수행한 시간을 로그로 남긴다. jdbc.audit ResultSet을 제외한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그를 생성하므로 JDBC 문제를 추적해야 할 필요를 죄외하고는 사용하지 않는다. jdbc.resultset ResultSet을 포함한 모든 JDBC 호출 정보를 로그로 남긴다. 많은 양의 로그를 생성하므로 JDBC 문제를 추적해야 할 필요를 죄외하고는 사용하지 않는다. jdbc.resultsettable SQL문을 수행한 후 조회된 table을 로그로 남긴다. logback-spring.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS_PATH&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;INFO&quot;/&gt; &lt;root level=&quot;off&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; DataBase 접속 설정 추가하기DataBase 접속 URL과 Driver를 변경해줄 필요가 있다. URL에서는 jdbc하고 접속하고 싶은 DB사이에 log4jdbc를 추가해주면 된다. Driver는 log4jdbc에서 제공해주는 Driver를 사용하면 된다. url: jdbc:log4jdbc:h2:mem:testdb driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy appplication.yml 123456datasource: # url: jdbc:h2:mem:testdb url: jdbc:log4jdbc:h2:mem:testdb driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy username: sa password: Console에 SQL문이 찍히는 것을 확인할 수 있다. 이상하게 Memory DB를 사용하는 경우 SQL문이 중복으로 찍힌다. MySQL 접속 설정 변경하기H2 DataBase했던 것과 마찬가지로 Driver와 URL을 변경해준다. application-mysql.yml 12345678spring: datasource: driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy# driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:log4jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;characterEncoding=UTF-8# url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: [DataBase ID] password: [DataBase Password] Create시 engine=InnoDB가 나타난 것을 보아 MySQL을 이용한 SQL문이 제대로 생성됨을 알 수 있다. 파일에 Log 출력하기파일에 로그를 남기기 위해 appender 클래스로 ch.qos.logback.core.FileAppender를 사용할 것이다. 로그파일을 관리하는 정책 세우기rollingPolicy 태그를 이용해 로그파일을 관리하는 정책을 세울 수 있다. rollingPolicy ch.qos.logback.core.rolling.RollingFileAppender 일자별로 로그파일을 관리한다. 일자가 바뀌면 fileNamePattern에 따라 별도의 로그파일이 생성된다. timeBasedFileNamingAndTriggeringPolicy 일자 외에도 파일의 용량에 따라 별도의 로그파일이 생성된다. maxFileSize보다 로그 파일의 크기가 커지면 별도의 로그파일이 생성된다. logback-spring.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS_PATH&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;LOGS_PATH&#125;/logback.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125;- %-5level - %msg%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOGS_PATH&#125;/$&#123;LOG_PREFIX&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt;&lt;!-- &lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;INFO&quot;/&gt;--&gt; &lt;logger name=&quot;jdbc.sqlonly&quot; level=&quot;INFO&quot;/&gt; &lt;root level=&quot;off&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot;&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; logs라는 폴더가 생성되고 여기에 logback.log라는 파일이 생성되 로그가 찍히는 것을 확인할 수 있다. logback.log http://logback.qos.ch/manual/index.html","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Logging","slug":"Logging","permalink":"https://ckck803.github.io/tags/Logging/"}]},{"title":"스프링부트를 이용한 게시판 만들기 21 - Github Action 사용하기","slug":"springboot/sample-board/board-21-github-action","date":"2021-03-06T05:12:05.000Z","updated":"2021-03-13T11:29:24.371Z","comments":true,"path":"2021/03/06/springboot/sample-board/board-21-github-action/","link":"","permalink":"https://ckck803.github.io/2021/03/06/springboot/sample-board/board-21-github-action/","excerpt":"","text":"21. Github Action 사용하기이전에 Jenkins를 이용해 CI 환경을 구성했다. Jenkins를 이용한 CI 환경의 가장 큰 단점은 Github로부터 Web Hook을 받을 수 있게 Port를 열어둬야 한다는 것이다. ngrok을 이용하더라도 계속해서 Port를 열어둘 수는 없는 노릇이라서 Github에서 제공하는 CI 도구인 Github Action을 이용하기로 했다. Github Action Workflow Template 선택하기Github에서 프로젝트를 선택하면 상단에 Action을 선택하면 본인의 환경에 맞는 Build 환경을 위한 Template를 선택할 수 있다. Gradle을 이용해 Spring Boot 프로젝트를 진행하고 있으므로 Gradle을 선택하도록 한다. Template 수정하기Gradle을 선택하게 되면 기본적으로 Gradle을 이용한 Build Plan Template가 주어진다. 기본적인 Template에서는 JDK 버전이 1.8인데 프로젝트는 JDK 11을 이용해 진행하고 있으므로 변경해줄 필요가 있다. 그 외에 운영체제나 원하는 Build Branch들을 선택할 수 있다. on-push-branch Push를 했을 때 Build를 진행할 Branch를 선택한다. 현재는 master에서 Push가 일어났을 때만 Build를 진행한다. on-pull_request-branch Pull Request를 진행했을 때 Build를 진행할 Branch를 선택한다. 현재는 master로 Pull Requst를 진행할 때만 Build를 진행한다. jobs-build-runs-on Build를 진행할 환경(운영체제)를 선택한다. jobs-build-steps Build를 진행할 단계를 정의한다. jobs-build-steps-name Build 단계 이름을 명시한다. jobs-build-steps-uses Build 단계에서 사용할 것들을 나타낸다. actions/checkout@v2 : 현재 Repository의 Project를 확인한다. actions/setup-java@v1 : 사용할 자바 버전을 명시한다. with를 사용해 사용 버전까지 명시 jobs-build-steps-run 명령어들을 수핸한다. chmod +x ./gradlew : gradlew에 대한 실행 권한을 부여한다. ./gradlew clean build : gradlew를 이용해서 Build를 진행한다. Github Action을 통한 Build 진행하기Template 작성을 완료한 후 우측 상단의 commit을 누르게 되면 Build가 진행되게 된다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Github Action","slug":"Github-Action","permalink":"https://ckck803.github.io/tags/Github-Action/"}]},{"title":"복수의 테이블 다루기","slug":"computer-science/database/SQL/union-join","date":"2021-03-06T01:02:35.000Z","updated":"2021-03-11T13:17:24.068Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/union-join/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/union-join/","excerpt":"","text":"07장 복수의 테이블 다루기UNION으로 합집합 구하기UNION으로 합집합 구하기12345678910SELECT * FROM sample71_a;+------+| a |+------+| 1 || 2 || 3 |+------+3 rows in set (0.00 sec) 12345678910SELECT * FROM sample71_b;+------+| b |+------+| 2 || 10 || 11 |+------+3 rows in set (0.00 sec) 두개의 SELECT 명령을 UNION해서 합집합 구하기123SELECT * FROM sample71_aUNIONSELECT * FROM sample71_b; 결과 12345678910+------+| a |+------+| 1 || 2 || 3 || 10 || 11 |+------+5 rows in set (0.00 sec) UNION 연산을 하기 위해서는 SELECT 명령의 열의 내용이 서로 일치해야 한다. UNION을 사용할 경우 각 SECECT명령에 ORDER BY를 지정해 정렬할 수는 없다. 마지막 SELECT 명령에만 지정하도록 한다. 두개의 SELECT 명령에 UNION ALL을 적용해 합집합 구하기123SELECT * FROM sample71_aUNION ALLSELECT * FROM sample71_b; 결과 1234567891011+------+| a |+------+| 1 || 2 || 3 || 2 || 10 || 11 |+------+6 rows in set (0.00 sec) 테이블 결합교차 결합FROM 구로 곱집합 구하기 FROM구에 테이블 두개를 지정해 곱집합 구하기 1SELECT * FROM sample72_x, sample72_y; 결과 1234567891011121314+------+------+| x | y |+------+------+| A | 1 || B | 1 || C | 1 || A | 2 || B | 2 || C | 2 || A | 3 || B | 3 || C | 3 |+------+------+9 rows in set (0.00 sec) 내부 결합상품 테이블과 재고수 테이블을 교차결합하기1SELECT * FROM 상품, 재고수; 결과 1234567891011121314+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 상품코드 | 상품명 | 메이커명 | 가격 | 상품분류 | 상품코드 | 입고일 | 재고수 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0001 | 2014-01-03 | 200 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0001 | 2014-01-03 | 200 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0001 | 2014-01-03 | 200 || 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0002 | 2014-02-10 | 500 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0002 | 2014-02-10 | 500 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0002 | 2014-02-10 | 500 || 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0003 | 2014-02-14 | 10 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0003 | 2014-02-14 | 10 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0003 | 2014-02-14 | 10 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+9 rows in set (0.00 sec) 상품코드가 같은 행을 검색하기1SELECT* FROM 상품, 재고수 WHERE 상품. 상품코드 = 재고수.상품코드; 결과 1234567+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 상품코드 | 상품명 | 메이커명 | 가격 | 상품분류 | 상품코드 | 입고일 | 재고수 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+| 0001 | 상품1 | 메이커1 | 100 | 식료품 | 0001 | 2014-01-03 | 200 || 0002 | 상품2 | 메이커2 | 200 | 식료품 | 0002 | 2014-02-10 | 500 || 0003 | 상품3 | 메이커3 | 1980 | 생활용품 | 0003 | 2014-02-14 | 10 |+--------------+-----------+--------------+--------+--------------+--------------+------------+-----------+ 검색할 행과 반환할 열 제한하기123SELECT 상품.상품명, 재고수.재고수 FROM 상품, 재고수WHERE 상품.상품코드 = 재고수.상품코드AND 상품.상품분류 = &#x27;식료품&#x27;; 결과 1234567+-----------+-----------+| 상품명 | 재고수 |+-----------+-----------+| 상품1 | 200 || 상품2 | 500 |+-----------+-----------+2 rows in set (0.00 sec) 내부결합을 활용한 데이터 관리상품 테이블과 메이커 테이블을 내부 결합하기123SELECT S.상품명, M.메이커명FROM 상품2 S INNER JOIN 메이커 MON S.메이커코드 = M.메이커코드; 결과 12345678+-----------+--------------+| 상품명 | 메이커명 |+-----------+--------------+| 상품1 | 메이커1 || 상품2 | 메이커1 || 상품3 | 메이커2 |+-----------+--------------+3 rows in set (0.01 sec) 상품 테이블을 자기결합 하기123SELECT S1.상품명, S2.상품명FROM 상품 S1 INNER JOIN 상품 S2ON S1.상품코드 = S2.상품코드; 결과 12345678+-----------+-----------+| 상품명 | 상품명 |+-----------+-----------+| 상품1 | 상품1 || 상품2 | 상품2 || 상품3 | 상품3 |+-----------+-----------+3 rows in set (0.00 sec) 내부결합에서는 상품코드가 0009인 상품이 제외된다.1234SELECT 상품3.상품명, 재고수.재고수FROM 상품3 INNER JOIN 재고수ON 상품3.상품코드 = 재고수.상품코드WHERE 상품3.상품분류=&#x27;식료품&#x27;; 결과 1234567+-----------+-----------+| 상품명 | 재고수 |+-----------+-----------+| 상품1 | 200 || 상품2 | 500 |+-----------+-----------+2 rows in set (0.01 sec) 외부결합으로 상품코드 0009인 상품도 결과에 포함하기1234SELECT 상품3.상품명, 재고수.재고수FROM 상품3 LEFT JOIN 재고수ON 상품3.상품코드 = 재고수.상품코드WHERE 상품3.상품분류 = &#x27;식료품&#x27;; 결과 12345678+--------------+-----------+| 상품명 | 재고수 |+--------------+-----------+| 상품1 | 200 || 상품2 | 500 || 추가상품 | NULL |+--------------+-----------+3 rows in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"데이터베이스 객체 작성과 삭제","slug":"computer-science/database/SQL/delete","date":"2021-03-06T01:01:46.000Z","updated":"2021-03-11T13:13:41.626Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/delete/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/delete/","excerpt":"","text":"6장 데이터베이스 객체 작성과 삭제26장 테이블 작성, 삭제, 변경CREATE TABLE로 테이블 작성하기12345CREATE TABLE sample62( no INTEGER NOT NULL, a VARCHAR(30), b DATE);) 결과 123456789mysql&gt; DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 데이터 행 삭제 TRUNCATE TABLE [테이블명] ALTER TABLE로 테이블에 열 추가하기 명령어 1ALTER TABLE sample62 ADD newcol INTEGER; 결과 12345678910DESC sample62;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | || newcol | int | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) ALTER TABLE ADD로 테이블에 열을 추가할 수 있다. ALTER TABLE로 열 속성 변경하기 명령어 1ALTER TABLE sample62 MODIFY newcol VARCHAR(20); 결과 12345678910DESC sample62;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | || newcol | varchar(20) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) ALTER TABLE로 열 이름 변경하기 명령어 1ALTER TABLE sample62 CHANGE newcol c VARCHAR(20); 결과 12345678910DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | || c | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) ALTER TABLE로 열 삭제하기 명령어 1ALTER TABLE smaple62 DROP c; 결과 123456789DESC sample62;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 27장 제약테이블 열에 제약 정의하기 명령어 12345CREATE TABLE sample631( a INTEGER NOT NULL, b INTEGER NOT NULL UNIQUE, c VARCHAR(30)); 결과 123456789 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 테이블에 ‘테이블 제약’ 정의하기 명령어 123456CREATE TABLE sample632( no INTEGER NOT NULL, sub_no INTEGER NOT NULL, name VARCHAR(30), PRIMARY KEY(no, sub_no)); 결과 123456789DESC sample632;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | PRI | NULL | || sub_no | int | NO | PRI | NULL | || name | varchar(30) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) ‘테이블 제약’에 이름 부이기 명령어 123456CREATE TABLE sample632( no INTEGER NOT NULL, sub_no INTEGER NOT NULL, name VARCHAR(30), CONSTRAINT pkey_sample PRIMARY KEY(no, sub_no)); 결과 123456789 DESC sample632;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| no | int | NO | PRI | NULL | || sub_no | int | NO | PRI | NULL | || name | varchar(30) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 열 제약 추가하기 기존 테이블 123456789 DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 명령어 1ALTER TABLE sample631 MODIFY c VARCHAR(30) NOT NULL; 123456789DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 테이블 제약 추가하기 기존 테이블 123456789DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 기본키 제약 추가하기 1ALTER TABLE sample631 ADD CONSTRAINT pkey_sample631 PRIMARY KEY(a); 결과 123456789DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 제약 삭제열 제약 삭제하기 기존 테이블 12345678+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | NO | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec) c 열의 NOT NULL 제약 없애기 1ALTER TABLE sample631 MODIFY c VARCHAR(30); 결과 123456789DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 테이블 제약 삭제하기 기존 테이블 123456789DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | PRI | NULL | || b | int | NO | UNI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) pkey_sample631 제약 삭제하기 1ALTER TABLE sample631 DROP CONSTRAINT pkey_sample631; my_sql의 경우 1ALTER TABLE sample631 DROP PRIMARY KEY; 결과 123456789DESC sample631;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| a | int | NO | | NULL | || b | int | NO | PRI | NULL | || c | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 기본키sample634 테이블 작성하기12345CREATE TABLE sample634( p INTEGER NOT NULL, a VARCHAR(30), CONSTRAINT pkey_sample634 PRIMARY KEY(p)); sample634에 행 추가하기123INSERT INTO sample634 VALUES(1, &#x27;첫째줄&#x27;);INSERT INTO sample634 VALUES(2, &#x27;둘째줄&#x27;);INSERT INTO sample634 VALUES(3, &#x27;셋째줄&#x27;); saple634에 중복하는 행 추가하기1INSERT INTO sample634 VALUES(2, &#x27;둘째줄&#x27;); 결과 1ERROR 1062 (23000): Duplicate entry &#x27;2&#x27; for key &#x27;sample634.PRIMARY&#x27; sample634을 중복된 값으로 갱신하기1UPDATE sample634 SET p=2 WHERE p=3; 1ERROR 1062 (23000): Duplicate entry &#x27;2&#x27; for key &#x27;sample634.PRIMARY&#x27; 29장 인덱스 작성과 삭제30장 뷰 작성과 삭제","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"집계와 서브쿼리","slug":"computer-science/database/SQL/subquery","date":"2021-03-06T01:01:04.000Z","updated":"2021-03-11T13:17:16.353Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/subquery/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/subquery/","excerpt":"","text":"집계와 서브쿼리행 개수 구하기 - COUNTCOUNT로 행 개수 구하기 테이블 1234567891011SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 1SELECT COUNT(*) FROM sample51; 결과 123456+----------+| COUNT(*) |+----------+| 5 |+----------+1 row in set (0.00 sec) 행 개수를 WHERE 구를 지정하여 구하기 테이블 12345678SELECT* FROM sample51 WHERE name=&#x27;A&#x27;;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 |+------+------+----------+2 rows in set (0.00 sec) 명령어 1SELECT COUNT(*) FROM sample51 WHERE name = &#x27;A&#x27;; 결과 123456+----------+| COUNT(*) |+----------+| 2 |+----------+1 row in set (0.00 sec) 집계함수와 NULL값 명령어 1SELECT COUNT(no), COUNT(name) FROM sample51; 결과 123456+-----------+-------------+| COUNT(no) | COUNT(name) |+-----------+-------------+| 5 | 4 |+-----------+-------------+1 row in set (0.00 sec) DISTINCT로 중복 제거 테이블 1234567891011SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 1SELECT DISTINCT name FROM sample51; 123456789+------+| name |+------+| A || B || C || NULL |+------+4 rows in set (0.00 sec) 집계함수에서 DISTINCT 명령어 1SELECT COUNT(ALL name), COUNT(DISTINCT name) FROM sample51; 결과 123456+-----------------+----------------------+| COUNT(ALL name) | COUNT(DISTINCT name) |+-----------------+----------------------+| 4 | 3 |+-----------------+----------------------+1 row in set (0.00 sec) COUNT 이외의 집계함수SUM으로 합계 구하기 테이블 1234567891011SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) 명령어 1SELECT SUM(quantity) FROM sample51; 결과 123456+---------------+| SUM(quantity) |+---------------+| 16 |+---------------+1 row in set (0.00 sec) AVG로 평균내기 명령어 1SELECT AVG(quantity), SUM(quantity)/COUNT(quantity) FROM sample51; 결과 123456+---------------+-------------------------------+| AVG(quantity) | SUM(quantity)/COUNT(quantity) |+---------------+-------------------------------+| 4.0000 | 4.0000 |+---------------+-------------------------------+1 row in set (0.01 sec) MIN, MAX로 최솟값, 최댓값 구하기 명령어 1SELECT MIN(quantity), MAX(quantity), MIN(name), MAX(name) FROM sample51; 결과 123456+---------------+---------------+-----------+-----------+| MIN(quantity) | MAX(quantity) | MIN(name) | MAX(name) |+---------------+---------------+-----------+-----------+| 1 | 10 | A | C |+---------------+---------------+-----------+-----------+1 row in set (0.00 sec) 그룹화 - GROUP BYGROUP BY로 그룹화 명령어 1SELECT name FROM sample51 GROUP BY name; 결과 123456789+------+| name |+------+| A || B || C || NULL |+------+4 rows in set (0.00 sec) name 열을 그룹화해 계산하기 명령어 1SELECT name, COUNT(name), SUM(quantity) FROM sample51 GROUP BY name; 결과 123456789+------+-------------+---------------+| name | COUNT(name) | SUM(quantity) |+------+-------------+---------------+| A | 2 | 3 || B | 1 | 10 || C | 1 | 3 || NULL | 0 | NULL |+------+-------------+---------------+4 rows in set (0.00 sec) HAVING 구로 조건 지정 테이블 12345678910SELECT name, COUNT(name) FROM sample51 GROUP BY name;+------+-------------+| name | COUNT(name) |+------+-------------+| A | 2 || B | 1 || C | 1 || NULL | 0 |+------+-------------+4 rows in set (0.00 sec) 명령어 1SELECT name, COUNT(name) FROM sample51 GROUP BY name HAVING COUNT(name) = 1; 결과 1234567+------+-------------+| name | COUNT(name) |+------+-------------+| B | 1 || C | 1 |+------+-------------+2 rows in set (0.00 sec) 내부 처리 순서WHERE 구 -&gt; GROUP BY 구 -&gt; HAVING 구 -&gt; SELECT 구 -&gt; ORDER BY 구 복수열의 그룹화 테이블 1234567891011SELECT* FROM sample51;+------+------+----------+| no | name | quantity |+------+------+----------+| 1 | A | 1 || 2 | A | 2 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+------+------+----------+5 rows in set (0.00 sec) GROUP BY를 사용할 때 주의할 점 : GROUP BY 에 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 SELECT구에 기술해서는 안된다. 명령어 1SELECT no, name, quantity FROM sample51 GROUP BY name; 결과 1ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;sample.sample51.no&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by GROUP BY로 그룹화 하면 클라이언트로 반환되는 결과는 그룹당 하나의 행이 된다. 하지만, name 열 값이 A인 그룹의 quantity 열 값은 1과 2로 두개이므로, 어떤 값을 반환할지 몰라 에러가 뜬다. 명령어 1SELECT MIN(no), name, SUM(quantity) FROM sample51 GROUP BY name; 결과 123456789+---------+------+---------------+| MIN(no) | name | SUM(quantity) |+---------+------+---------------+| 1 | A | 3 || 3 | B | 10 || 4 | C | 3 || 5 | NULL | NULL |+---------+------+---------------+4 rows in set (0.00 sec) 결과 값 정렬1SELECT name, COUNT(name), SUM(quantity) FROM sample51 GROUP BY name ORDER BY SUM(quantity) DESC; 123456789+------+-------------+---------------+| name | COUNT(name) | SUM(quantity) |+------+-------------+---------------+| B | 1 | 10 || A | 2 | 3 || C | 1 | 3 || NULL | 0 | NULL |+------+-------------+---------------+4 rows in set (0.01 sec) 서브 쿼리DELETE의 WHERE 구에서 서브쿼리 사용하기 테이블 12345678910SELECT* FROM sample54;+------+------+| no | a |+------+------+| 1 | 100 || 2 | 900 || 3 | 20 || 4 | 80 |+------+------+4 rows in set (0.01 sec) 최솟값을 가지는 행 삭제하기 명령어 1DELETE FROM sample54 WHERE a=(SELECT MIN(a) FROM sample54); 결과 1ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;sample54&#x27; for update in FROM clause 데이터를 추가하거나 갱신할 경우 동일한 테이블을 서브쿼리에서 사용할 수 없도록 되어 있기 때문에 이런 에러가 뜬다. 명령어 1DELETE FROM sample54 WHERE a=(SELECT a FROM(SELECT MIN(a) AS a FROM sample54) AS x); 결과 123456789SELECT* FROM sample54;+------+------+| no | a |+------+------+| 1 | 100 || 2 | 900 || 4 | 80 |+------+------+3 rows in set (0.00 sec) 스칼라 값하나의 값을 반환하는 패턴 명령어 1SELECT MIN(a) FROM sample54; 결과 123456+--------+| MIN(a) |+--------+| 80 |+--------+1 row in set (0.00 sec) 복수의 행이 반환되지만 열은 하나인 패턴 명령어 1SELECT no FROM sample54; 결과 12345678+------+| no |+------+| 1 || 2 || 4 |+------+3 rows in set (0.00 sec) 하나의 행이 반환되지만 열이 복수인 패턴 명령어 1SELECT MIN(a), MAX(no) FROM sample54; 결과 123456+--------+---------+| MIN(a) | MAX(no) |+--------+---------+| 80 | 4 |+--------+---------+1 row in set (0.00 sec) 복수의 행, 복수의 열이 반환되는 패턴 명령어 1SELECT no, a FROM sample54; 결과 12345678+------+------+| no | a |+------+------+| 1 | 100 || 2 | 900 || 4 | 80 |+------+------+3 rows in set (0.00 sec) SELECT 명령이 하나의 값만 반환하는 것을 스칼라 값을 반환한다.고 한다. SELECT 구에서 서브쿼리 사용하기 명령어 123SELECT (SELECT COUNT(*) FROM sample51) AS sq1, (SELECT COUNT(*) FROM sample51) AS sq2; My SQL에서는 FROM 구를 생략할 수 있다. 하지만 Oracle등 전통적인 데이터 베이스 제품에서는 FROM을 생략할 수 없습니다. 결과 123456+------+------+| sq1 | sq2 |+------+------+| 5 | 5 |+------+------+1 row in set (0.00 sec) SET 구에서 서브쿼리 사용하기 명령어 1UPDATE sample54 SET a = (SELECT a FROM (SELECT MAX(a) AS a FROM sample54)as x); 결과 123456789SELECT* FROM sample54;+------+------+| no | a |+------+------+| 1 | 900 || 2 | 900 || 4 | 900 |+------+------+3 rows in set (0.00 sec) FROM 구에서 서브쿼리 사용하기 명령어 1SELECT* FROM (SELECT* FROM sample54) sq; 결과 12345678+------+------+| no | a |+------+------+| 1 | 900 || 2 | 900 || 4 | 900 |+------+------+3 rows in set (0.00 sec) INSERT 명령과 서브쿼리 명령어 1234INSERT INTO sample541 VALUES( (SELECT COUNT(*) FROM sample51), (SELECT COUNT(*) FROM sample54)); 결과 1234567SELECT* FROM sample541;+------+------+| a | b |+------+------+| 5 | 3 |+------+------+1 row in set (0.00 sec) INSERT SELECT 명령어 1INSERT INTO sample541 SELECT 1,2; 결과 12345678SELECT* FROM sample541;+------+------+| a | b |+------+------+| 5 | 3 || 1 | 2 |+------+------+2 rows in set (0.00 sec) 상관 서브쿼리EXISTS 테이블 12345678910SELECT* FROM sample551;+------+------+| no | a |+------+------+| 1 | NULL || 2 | NULL || 3 | NULL || 4 | NULL || 5 | NULL |+------+------+ 테이블 12345678SELECT* FROM sample552;+------+| no2 |+------+| 3 || 5 |+------+2 rows in set (0.00 sec) sample 552 테이블에 있는지를 조사한 결과 값을 넣고 싶다. 명령어 1UPDATE sample551 SET a = &#x27;있음&#x27; WHERE EXISTS (SELECT* FROM sample552 WHERE no2 = no); 1234567891011SELECT* FROM sample551;+------+--------+| no | a |+------+--------+| 1 | NULL || 2 | NULL || 3 | 있음 || 4 | NULL || 5 | 있음 |+------+--------+5 rows in set (0.00 sec) NOT EXISTS 명령어 12UPDATE sample551 SET a = &#x27;없음&#x27; WHERE NOT EXISTS (SELECT* FROM sample552 WHERE no2 = no); 결과 12345678910SELECT* FROM sample551;+------+--------+| no | a |+------+--------+| 1 | 없음 || 2 | 없음 || 3 | 있음 || 4 | 없음 || 5 | 있음 |+------+--------+ 테이블 명 붙이기양쪽 테이블에 동일한 이름의 열이 있을 경우 상관 서브 쿼리가 제대로 작동하지 않으므로 테이블 명을 붙일 필요가 있다. 12UPDATE sample551 SET a = &#x27;있음&#x27; WHERE EXISTS (SELECT* FROM sample552 WHERE sample552.no2 = sample551.no); IN집합 안의 값이 존재하는지를 조사할 수 있다. 명령어 1SELECT* FROM sample551 WHERE no IN(3, 5); 결과 123456+------+--------+| no | a |+------+--------+| 3 | 있음 || 5 | 있음 |+------+--------+ IN의 오른쪽을 서브쿼리로 지정하기 명령어 1SELECT* FROM sample551 WHERE no IN(SELECT no2 FROM sample552); 결과 1234567+------+--------+| no | a |+------+--------+| 3 | 있음 || 5 | 있음 |+------+--------+2 rows in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"데이터 추가, 삭제, 갱신","slug":"computer-science/database/SQL/dml","date":"2021-03-06T01:00:09.000Z","updated":"2021-03-11T13:13:45.305Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/dml/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/dml/","excerpt":"","text":"데이터 추가, 삭제, 갱신행 추가하기 - INSERT 명령어 1SELECT * FROM sample41; 결과 1Empty set (0.00 sec) 현재는 비어있는 테이블이다. sample41 열 구성 확인하기 명령어 1DESC sample41; 결과 12345678+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no | int | NO | | NULL | || a | varchar(30) | YES | | NULL | || b | date | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) no 열은 int(11)이므로 수치형 데이터를 저장할 수 있다. a 열은 varchar(30)이므로 최대 길이가 30인 문자열을 저장할 수 있다. b 열은 날짜 시간형 데이터를 저장할 수 있다. 행 추가 하기 명령어 1INSERT INTO sample41 VALUES(1, &#x27;ABC&#x27;, &#x27;2014-01-25&#x27;); 결과 1Query OK, 1 row affected (0.00 sec) 확인하기 명령어 1SELECT* FROM sample41; 결과 123456+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 |+----+------+------------+1 row in set (0.00 sec) 값을 저장할 열 지정하기 명령어 12INSERT INTO sample41(a, no) VALUES(&#x27;XYZ&#x27;, 2);Query OK, 1 row affected (0.00 sec) 결과 12345678SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL |+----+------+------------+2 rows in set (0.00 sec) NOT NULL 제약 명령어 12INSERT INTO sample41(no, a, b) VALUES(NULL, NULL, NULL);ERROR 1048 (23000): Column &#x27;no&#x27; cannot be null 행에 값이 없는 상태(NULL)로 두고 싶을 경우 VALUES구에서 NULL로 값을 지정할 수 있다. no 열에 대해서는 NULL값을 허용하지 않으므로 위 명령어는 에러가 발생한다. 명령어 12INSERT INTO sample41(no, a, b) VALUES(3, NULL, NULL);Query OK, 1 row affected (0.01 sec) 결과 123456789SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL || 3 | NULL | NULL |+----+------+------------+3 rows in set (0.00 sec) DEFAULT에 대해 알아보기 명령어 1DESC sample411; 결과 1234567+-------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------+------+-----+---------+-------+| no | int | NO | | NULL | || d | int | YES | | 0 | |+-------+------+------+-----+---------+-------+2 rows in set (0.01 sec) sample411테이블 d 열에 대해서는 디폴트 값으로 0이 설정되어 있다. 값을 생략하지 앟고 행 추가하기 명령어 12INSERT INTO sample411(no, d) VALUES(1,1);Query OK, 1 row affected (0.00 sec) 결과 123456SELECT * FROM sample411;+----+------+| no | d |+----+------+| 1 | 1 |+----+------+ DEFAULT로 값을 지정해 행 추가하기 명령어 12INSERT INTO sample411(no, d) VALUES(2, DEFAULT);Query OK, 1 row affected (0.00 sec) 결과 1234567SELECT * FROM sample411;+----+------+| no | d |+----+------+| 1 | 1 || 2 | 0 |+----+------+ 암묵적으로 디폴트값을 가지는 행 추가하기 명령어 12INSERT INTO sample411(no) VALUES(3);Query OK, 1 row affected (0.00 sec) 결과 123456789SELECT * FROM sample411;+----+------+| no | d |+----+------+| 1 | 1 || 2 | 0 || 3 | 0 |+----+------+3 rows in set (0.00 sec) 열을 지정하지 않으면 디폴트값으로 행이 추가된다. 삭제하기 - DELETE 테이블 123456789SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL || 3 | NULL | NULL |+----+------+------------+3 rows in set (0.00 sec) DELETE FROM sample41;로 DELETE 명령을 실행하면 sample41 테이블의 모든 데이터가 삭제된다. 행 삭제하기 명령어 1DELETE FROM sample41 WHERE no=3; 결과 1234567+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL |+----+------+------------+2 rows in set (0.00 sec) DELETE 명령은 WHERE 조건에 일치하는 모든 행을 삭제한다. 데이터 갱신하기 - UPDATE 테이블 12345678SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | NULL |+----+------+------------+2 rows in set (0.00 sec) DELETE와 달리UPDATE는 셀 단위로 데이터를 갱신할 수 있다.UPDATE 명령에서는 set구를 사용하여 갱신할 열과 값을 지정한다. SET 열명 = 값 이때 =는 비교연산자가 아닌, 값을 대입하는 대입 연산자이다. 명령어 123UPDATE sample41 SET b = &#x27;2014-09-08&#x27; WHERE no=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 결과 12345678SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 1 | ABC | 2014-01-25 || 2 | XYZ | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) UPDATE 명령에서는 WHERE 조건에 일치하는 ‘모든 행’이 갱신된다. UPDATE 명령으로 증가 연산하기 명령어 123UPDATE sample41 SET no = no+1;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0 결과 12345678 SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 2 | ABC | 2014-01-25 || 3 | XYZ | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) 모든 행의 no값에 1씩 더해진 것을 알 수 있다. 복수열 갱신 명령어 123UPDATE sample41 SET a=&#x27;xxx&#x27;, b=&#x27;2014-01-01&#x27; WHERE no=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 콤마,로 구분하여 갱신할 열을 여러 개 지정할 수 있다. 결과 12345678SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 2 | xxx | 2014-01-01 || 3 | XYZ | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) NULL로 갱신하기 명령어 123UPDATE sample41 SET a=NULL;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0 결과 12345678SELECT* FROM sample41;+----+------+------------+| no | a | b |+----+------+------------+| 2 | NULL | 2014-01-01 || 3 | NULL | 2014-09-08 |+----+------+------------+2 rows in set (0.00 sec) NOT NULL 제약이 설정되어 있는 열은 NULL이 허용되지 않는다. 물리 삭제와 논리 삭제 물리삭제 : SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하는 방법 논리삭제 : 삭제 플래그와 같은 열을 미리 준비해 서 삭제 플레그의 값을 유효하게 갱신해두는 삭제 방법(실제 테이블안에 데이터는 남아있다.)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"정렬과 연산","slug":"computer-science/database/SQL/sort-and-operation","date":"2021-03-06T00:58:46.000Z","updated":"2021-03-11T13:16:42.803Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/sort-and-operation/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/sort-and-operation/","excerpt":"","text":"정렬과 연산정렬하기 - ORDER BY 기존 테이블 123456789mysql&gt; SELECT * FROM sample31;+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 |+------+------+---------------------------+3 rows in set (0.00 sec) age를 기준으로 테이블 정렬하기 명령어 1SELECT* FROM sample31 ORDER BY age; 나이를 기준으로 테이블sample31을 정렬하였다. 결과 12345678+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 || A씨 | 36 | 대구광역시 중구 |+------+------+---------------------------+3 rows in set (0.01 sec) 오름차순으로 정렬되었음을 확인할 수 있다. address를 기준으로 테이블 정리하기 명령어 1SELECT* FROM sample31 ORDER BY address; address를 기준으로 테이블을 정렬 시켰다. 결과 1234567+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 |+------+------+---------------------------+ 사전순으로 테이블이 정렬되었다. 내림 차순으로 정렬하기 - DESC 명령어 1SELECT* FROM sample31 ORDER BY age DESC; DESC를 붙임으로써 테이블을 내림차순으로 정렬한다. 결과 12345678+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| A씨 | 36 | 대구광역시 중구 || C씨 | 25 | 서울특별시 중구 || B씨 | 18 | 부산광역시 연제구 |+------+------+---------------------------+3 rows in set (0.00 sec) 오름 차순으로 정렬하기 - AES 명령어 1SELECT* FROM sample31 ORDER BY age ASC; ASC를 붙임으로써 테이블을 오름차순으로 정렬한다. ASC는 생략 가능 12345678+------+------+---------------------------+| name | age | address |+------+------+---------------------------+| B씨 | 18 | 부산광역시 연제구 || C씨 | 25 | 서울특별시 중구 || A씨 | 36 | 대구광역시 중구 |+------+------+---------------------------+3 rows in set (0.00 sec) 복수의 열을 지정해 정렬하기1SELECT* FROM sample32 ORDER BY a; 결과12345678910+------+------+| a | b |+------+------+| 1 | 1 || 1 | 3 || 1 | 2 || 2 | 1 || 2 | 2 |+------+------+5 rows in set (0.00 sec) 1SELECT* FROM sample32 ORDER BY b,a; 결과12345678910+------+------+| a | b |+------+------+| 1 | 1 || 2 | 1 || 1 | 2 || 2 | 2 || 1 | 3 |+------+------+5 rows in set (0.00 sec) 정렬방법 지정하기1SELECT* FROM sample32 ORDER BY a ASC, b DESC; 결과12345678910+------+------+| a | b |+------+------+| 1 | 3 || 1 | 2 || 1 | 1 || 2 | 2 || 2 | 1 |+------+------+5 rows in set (0.00 sec) 결과 행 제한하기 - LIMIT 테이블 123456789101112+------+| no |+------+| 1 || 2 || 3 || 4 || 5 || 6 || 7 |+------+7 rows in set (0.00 sec) 명령어 1SELECT* FROM sample33 LIMIT 3; 결과 12345678+------+| no |+------+| 1 || 2 || 3 |+------+3 rows in set (0.00 sec) 정렬 후 LIMIT로 행수 제한하기 명령어 1SELECT* FROM sample33 ORDER BY no DESC LIMIT 3; 결과 12345678+------+| no |+------+| 7 || 6 || 5 |+------+3 rows in set (0.00 sec) LIMIT를 사용할 수 없는 데이터베이스에서의 행 제한 SQL Server 1SELECT TOP 3 * FROM sample33; ORACLE 1SELECT * FROM sample33 WHERE ROWNUM&lt;=3; 오프셋 지정 - OFFSET 명령어 1SELECT* FROM sample33 LIMIT 3 OFFSET 0; 수치 연산 기본 테이블 123456789mysql&gt; SELECT* FROM sample34;+------+-------+----------+| no | price | quantity |+------+-------+----------+| 1 | 100 | 10 || 2 | 230 | 24 || 3 | 1980 | 1 |+------+-------+----------+3 rows in set (0.01 sec) 명령어 1SELECT*, price*quantity FROM sample34; 결과 12345678+------+-------+----------+----------------+| no | price | quantity | price*quantity |+------+-------+----------+----------------+| 1 | 100 | 10 | 1000 || 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 |+------+-------+----------+----------------+3 rows in set (0.00 sec) 열의 별명 - AS 명령어 1SELECT*, price*quantity AS amount FROM sample34; 결과 12345678+------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 1 | 100 | 10 | 1000 || 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 |+------+-------+----------+--------+3 rows in set (0.00 sec) 명령어 1SELECT*, price*quantity &quot;금액&quot; FROM sample34; 결과 12345678+------+-------+----------+--------+| no | price | quantity | 금액 |+------+-------+----------+--------+| 1 | 100 | 10 | 1000 || 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 |+------+-------+----------+--------+3 rows in set (0.00 sec) WHERE 구에서 계산, 검색하기 명령어 1SELECT*, price*quantity AS amount FROM sample34 WHERE price*quantity &gt;= 2000; 결과 123456+------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 2 | 230 | 24 | 5520 |+------+-------+----------+--------+1 row in set (0.00 sec) 명령어 1SELECT*, price*quantity AS amount FROM sample34 WHERE amount &gt;= 2000; 결과 1ERROR 1054 (42S22): Unknown column &#x27;amount&#x27; in &#x27;where clause&#x27; 명령어 1SELECT*, price*quantity AS amount FROM sample34 ORDER BY price*quantity DESC; 결과 12345678+------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 || 1 | 100 | 10 | 1000 |+------+-------+----------+--------+3 rows in set (0.01 sec) 명령어 1SELECT*, price*quantity AS amount FROM sample34 ORDER BY amount DESC; 결과 12345678+------+-------+----------+--------+| no | price | quantity | amount |+------+-------+----------+--------+| 2 | 230 | 24 | 5520 || 3 | 1980 | 1 | 1980 || 1 | 100 | 10 | 1000 |+------+-------+----------+--------+3 rows in set (0.01 sec) ROUND 함수 - 반올림 기존 테이블 123456789SELECT* FROM sample341;+---------+| amount |+---------+| 5961.60 || 2138.40 || 1080.00 |+---------+3 rows in set (0.00 sec) 명령어 1SELECT amount, ROUND(amount) FROM sample341; 결과 12345678+---------+---------------+| amount | ROUND(amount) |+---------+---------------+| 5961.60 | 5962 || 2138.40 | 2138 || 1080.00 | 1080 |+---------+---------------+3 rows in set (0.00 sec) 소수점 둘째 자리에서 반올림하기 명령어 1SELECT amount, ROUND(amount, 1) FROM sample341; 결과 12345678+---------+------------------+| amount | ROUND(amount, 1) |+---------+------------------+| 5961.60 | 5961.6 || 2138.40 | 2138.4 || 1080.00 | 1080.0 |+---------+------------------+3 rows in set (0.00 sec) 10 단위를 반올림 하기 명령어 1SELECT amount, ROUND(amount, -2) FROM sample341; 결과 12345678+---------+-------------------+| amount | ROUND(amount, -2) |+---------+-------------------+| 5961.60 | 6000 || 2138.40 | 2100 || 1080.00 | 1100 |+---------+-------------------+3 rows in set (0.00 sec) 문자열 연산문자열 결합 - CONCAT 테이블 123456789select * from sample35;+------+-------+----------+------+| no | price | quantity | unit |+------+-------+----------+------+| 1 | 100 | 10 | 개 || 2 | 230 | 24 | 통 || 3 | 1980 | 1 | 장 |+------+-------+----------+------+3 rows in set (0.00 sec) 명령어 1SELECT CONCAT(quantity, unit) FROM sample35; 결과 12345678+------------------------+| CONCAT(quantity, unit) |+------------------------+| 10개 || 24통 || 1장 |+------------------------+3 rows in set (0.04 sec) CASE 문으로 데이터 변환하기CASE로 NULL 값을 0으로 변환하기123456SELECT a, CASE WHEN a IS NULL THEN 0 ELSE a END &quot;a(null=0)&quot; FROM sample37; 12345678+------+-----------+| a | a(null=0) |+------+-----------+| 1 | 1 || 2 | 2 || NULL | 0 |+------+-----------+3 rows in set (0.00 sec) COALESCE 함수를 이용한 NULL값 변환 테이블 123456789SELECT * FROM sample37;+------+| a |+------+| 1 || 2 || NULL |+------+3 rows in set (0.00 sec) 명령어 1SELECT a, COALESCE(a,0) FROM sample37; 결과 12345678+------+---------------+| a | COALESCE(a,0) |+------+---------------+| 1 | 1 || 2 | 2 || NULL | 0 |+------+---------------+3 rows in set (0.00 sec) CASE로 NULL 값을 0으로 반환하기 명령어 1234567SELECT a AS &quot;코드&quot;, CASE WHEN a=1 THEN &#x27;남자&#x27; WHEN a=2 THEN &#x27;여자&#x27; ELSE &#x27;미지정&#x27; END AS &quot;성별&quot; FROM sample37; 결과 12345678+--------+-----------+| 코드 | 성별 |+--------+-----------+| 1 | 남자 || 2 | 여자 || NULL | 미지정 |+--------+-----------+3 rows in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"테이블에서 데이터 검색","slug":"computer-science/database/SQL/search","date":"2021-03-06T00:56:37.000Z","updated":"2021-03-11T13:13:50.950Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/search/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/search/","excerpt":"","text":"테이블에서 데이터 검색1use sample SELECT 명령어1SELECT * FROM sample21; SELECT는 DML에 속하는 멸령으로 SQL에서 자주 사용된다.SELECT명령으로 데이터 베이스의 데이터를 읽어올 수 있다.*는 모든 열을 의미하는 메타문자이다.FROM은 처리 대상 테이블을 지정하는 키워드 결과12345678+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 || 2 | 김재진 | NULL | 대구광역시 동구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+------------+---------------------------+3 rows in set (0.00 sec) NULL은 데이터 값으로 아무것도 저장되어 있지 않은 상태를 의미한다. DESC 명령어1DESC sample21; 테이블에 어떤 열이 정의도어 있는지 알 수 있다. 결과123456789+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| no | int | YES | | NULL | || name | varchar(20) | YES | | NULL | || birthday | date | YES | | NULL | || address | varchar(40) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+4 rows in set (0.01 sec) int : Integer를 의미한다.char(N) : 문자열형의 하나, 문자열을 저장할 수 있는 자료형이다. 문자열형에서는 열의 최대 길이를 저장해야 한다.VARCHAR : 문자열을 저장할 수 있는 자료형. 데이터 크기에 맞춰 저장공간의 크기도 변경된다.(가변 길이 문자열)DATE : 날짜값을 저장할 수 있는 자료형TIME : 시간을 저장할 수 있는 자료형 Null : NULL 값을 허용할 것인지 아닌지를 나타내는 제약사항 YES : NULL값을 허용 NO : NULL값을 허용하지 않는다. Default : 열에 주어진 기본값(생략했을 경우 적용되는 값) WHERE 명령어일치하는 결과값만 가져오기1SELECT * FROM sample21 WHERE no = 2; 행 속에서 필요한 데이터만 검색하기 위한 명령어WHERE구는 생략이 가능하다. 결과123456+------+-----------+----------+------------------------+| no | name | birthday | address |+------+-----------+----------+------------------------+| 2 | 김재진 | NULL | 대구광역시 동구 |+------+-----------+----------+------------------------+1 row in set (0.00 sec) 제외하고 검색하기1SELECT * FROM sample21 WHERE no &lt;&gt; 2; 결과1234567+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+------------+---------------------------+2 rows in set (0.00 sec) 문자열 검색하기1SELECT* FROM sample21 WHERE name=&#x27;박준용&#x27;; (&#39; &#39;)작은 따옴표로 문자를 묶어서 검색해야 한다. 결과123456+------+-----------+------------+---------------------------+| no | name | birthday | address |+------+-----------+------------+---------------------------+| 1 | 박준용 | 1976-10-18 | 대구광역시 수성구 |+------+-----------+------------+---------------------------+1 row in set (0.00 sec) NULL값 검색하기1SELECT* FROM sample21 WHERE birthday IS NULL; NULL인 행은 =연산자를 이용하여 검색할 수 없다.IS NULL을 이용하여 검색해야 한다. 1234567+------+-----------+----------+---------------------------+| no | name | birthday | address |+------+-----------+----------+---------------------------+| 2 | 김재진 | NULL | 대구광역시 동구 || 3 | 홍길동 | NULL | 서울특별시 마포구 |+------+-----------+----------+---------------------------+2 rows in set (0.00 sec) 조건 조합하기AND 연산자1SELECT * FROM sample24 WHERE a&lt;&gt;0 AND b&lt;&gt;0; 좌우의 식 모두 참일 경우 AND 연산자는 참을 반환한다.모든 조건을 만족하는 경우 조건식은 참이된다고 할때 AND 연산자로 조건식을 조합한다.AND 연산은 논리곱을 계산하는 논리 연산자이다. 결과123456+------+------+------+------+| no | a | b | c |+------+------+------+------+| 4 | 2 | 2 | 0 |+------+------+------+------+1 row in set (0.00 sec) OR 연산자1SELECT* FROM sample24 WHERE no=1 OR no=2; 어느 쪽이든 하나만 참이 되는 조건식은 참이 된다.라고 할 경우 OR로 조건식을 연결한다.OR연산자는 논리합을 계산하는 논리 연산자이다. 1234567+------+------+------+------+| no | a | b | c |+------+------+------+------+| 1 | 1 | 0 | 0 || 2 | 0 | 1 | 0 |+------+------+------+------+2 rows in set (0.00 sec) NOT 연산자1SELECT* FROM sample24 WHERE NOT(a&lt;&gt;0 OR b&lt;&gt;0); NOT연산자는 단항 연산자이다. 123456+------+------+------+------+| no | a | b | c |+------+------+------+------+| 3 | 0 | 0 | 1 |+------+------+------+------+1 row in set (0.00 sec) 패턴 매칭에 의한 검색특정 문자나 문자열이 포함되어 있는지를 검색하고 싶은 경우 사용한다. LIKE로 패턴 매칭하기1SELECT * FROM sample25 WHERE text LIKE &#x27;SQL%&#x27;; LIKE술어를 사용하면 열 값이 부분적으로 일치하는 경우에도 참이 된다.%, _ 같은 특수 문자와 함께 사용한다.% : 임의의 문자열을 의미한다._ :임의의 문자 하나를 의미한다. 123456+------+---------------------------------------------------+| no | text |+------+---------------------------------------------------+| 1 | SQL은 RDBMS를 조작하기 위한 언어이다. |+------+---------------------------------------------------+1 row in set (0.01 sec) SQL로 시작하는 문자열을 검색했다. 1SELECT* FROM sample25 WHERE text LIKE &#x27;%SQL%&#x27;; SQL이 들어간 문자열 모두를 검색한다. 1234567+------+-----------------------------------------------------------------+| no | text |+------+-----------------------------------------------------------------+| 1 | SQL은 RDBMS를 조작하기 위한 언어이다. || 3 | LIKE는 SQL에서 사용할 수 있는 술어 중 하나이다. |+------+-----------------------------------------------------------------+2 rows in set (0.00 sec) 1SELECT* FROM sample25 WHERE text LIKE &#x27;%\\%%&#x27;; 123456+------+------------------------------------------------------------+| no | text |+------+------------------------------------------------------------+| 2 | LIKE에서는 메타문자 %와 _를 사용할 수 있다. |+------+------------------------------------------------------------+1 row in set (0.00 sec)","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"SQL - DDL DML DCL","slug":"computer-science/database/SQL/ddl-dml-dcl","date":"2021-03-05T16:21:23.000Z","updated":"2021-03-11T13:13:37.594Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/ddl-dml-dcl/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/ddl-dml-dcl/","excerpt":"","text":"DDL DML DCLDDL 데이터 베이스 스키마를 정의하기 하거나 조작하기 위한 명령어 명령어 설명 CREATE 데이터 베이스, 테이블을 생성하기 위한 명령어 ALTER 테이블을 수정하기 위한 명령어 DROP 데이터베이스, 테이블을 삭제하기 위한 명령어 RENAME TRUNCATE 데이터베이스를 초기화 시키기 위한 명령어 DML 데이터 베이스에 저장된 데이터를 조회, 수정, 삽입, 삭제하기 위한 언어 명령어 설명 SELECT 데이터를 조회 하기 위한 명령어 INSERT 데이터를 삽입하기 위한 명령어 UPDATE 데이터를 수정하기 위한 명령어 DELETE 데이터를 삭제하기 위한 명령어 DCL 데이터 베이스에 접근하거나 객체에 권한을 주는 역할을 하는 언어 명령어 설명 GRANT 데이터 베이스 사용자에게 특정 작업에 대한 권한을 주기 위한 명령어 REVOKE 데이터 베이스 사용자에게 특정 작업에 대한 권한을 회수, 박탈 하기 위한 명령어 COMMIT 트랜잭션 작업 결과를 반영하기 위한 명령어 ROLLBACK 트랜잭션 작업을 취소 및 원래대로 복구하기 위한 명령어","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"트랜잭션과 ACID","slug":"computer-science/database/SQL/ACID","date":"2021-03-05T16:15:42.000Z","updated":"2021-03-11T13:13:32.030Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/ACID/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/ACID/","excerpt":"","text":"트랜잭션과 ACID 원자성(Atomicity) 트랜잭션이 부분적으로 실행되거나 중단되지 않음을 보장한다. 즉, 분해가 불가능한 최소 단위인 하나의 원자처럼 동작한다는 의미 All or nothing의 개념으로 작업의 일부분만을 실행시키지 않는다. 일관성(Consistency) 트랜잭션이 성공적으로 수행되면 일관적인 DB상태를 유지함을 보장한다. 여기서 말하는 일관성이란, 작업을 수행한 후 자료형이 변하지 않음을 보장한다는 것이다. 격리성(Isolation) 트랜잭션이 수행되고 있을 때 다른 트랜잭션의 작업이 끼어들지 않음을 보장한다. 트랜잭션끼리는 서로 간섭할 수 없다. 지속성(Durability) 성공적으로 수행한 트랜잭션은 영원히 지속됨을 보장한다. 원자성 보장트랜잭션에 의한 변경 내용을 유지하면서, 이전에 commit된 시점의 데이터를 임시영역에 따로 저장함으로써 원자성을 보장한다. 현재 수행하고 있는 트랜잭션에 오류가 나면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 rollback을 한다. 이전 데이터들이 저장된 영역을 롤백 세그먼트라고 부른다. 현재 수행중인 트랜잭션에 의해 새롭게 변경되는 내역을 데이터베이스 테이블이라 부른다. 트랜잭션의 원자성은 롤백 세그먼트에 의해 보장이 된다. 일관성 보장격리성 보장 lock &amp; excute unlock을 통해 고립성을 보장한다. 데이터를 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 않도록 고립성을 보장하고, 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용하는 방식이다. shared lock : 트랜잭션에서 데이터를 읽을 때 다른 트랜잭션들이 읽을 수는 있도록 허용하는 lock exelusive lock : 한 트랜잭션에서 데이터를 수정하고 있을 경우 다른 트랜잭션들이 접근을 못하도록하는 lock 지속성 보장","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"sql.md","slug":"computer-science/database/SQL/sql-md","date":"2021-03-05T16:10:22.000Z","updated":"2021-03-11T13:16:53.489Z","comments":true,"path":"2021/03/06/computer-science/database/SQL/sql-md/","link":"","permalink":"https://ckck803.github.io/2021/03/06/computer-science/database/SQL/sql-md/","excerpt":"","text":"SQL 첫걸음 My SQL 설치하기 1장 데이터 베이스 구축 2장 테이블에서 데이터 검색 3장 정렬과 연산 4장 데이터 추가, 삭제, 갱신 5장 집계와 서브쿼리 6장 데이터베이스 객체 작성과 삭제 7장 복수의 테이블 다루기 SELECTFROMWHEREGROUP BYHAVINGORDER BYIFNULL, ISNULL, COALESCE, NVLJOIN INNER JOIN : 두 테이블이 공통적으로 가지고 있는 레코드를 반환한다. LEFT JOIN : 두 테이블이 공통적으로 가지고 있는 레코드와 왼쪽 테이블의 모든 레코드를 반환한다. RIGHT JOIN : 두 테이블이 공통적으로 가지고 있는 레코드와 오른쪽 테이블의 모든 레코드를 반환한다. FULL OUTER JOIN : 두 테이블이 공통적으로 가지고 있는 레코드와 왼쪽 오른쪽 테이블의 레코드를 반환한다. SQL 내 함수숫자 함수 ABS(n) : n의 절대값을 반환한다. CEIL(n), FLOOR(n) : n보다 같거나 큰 함수를 반환한다. ROUND(n, i) : n을 소수점 i+1번째 자리에서 반올림 한다. TRUNC(n, i) : n을 소수점 i+1번째 자리에서 버린다. POWER(n1, n2) : n1을 n2로 거듭제곱한다. MOD(n1, n2) : n1을 n2로 나눈 나머지 값 ROUND &amp; TRUNC 자릿 값 소수쪽으로 가게 되면 양수를 정수쪽으로 가게 되면 음수값을 취하면 된다. 문자 함수 UPPER(char) : char를 대문자로 변환한다. LOWER(char) : char를 소문자로 반환한다. LENGTH(char) : char의 길이를 반환한다. UPPER 명령어 1select UPPER(&#x27;hello&#x27;); 결과 123456+----------------+| UPPER(&#x27;hello&#x27;) |+----------------+| HELLO |+----------------+1 row in set (0.00 sec) LOWER 명령어 1mysql&gt; select LOWER(&#x27;HELLO&#x27;); 결과 123456+----------------+| LOWER(&#x27;HELLO&#x27;) |+----------------+| hello |+----------------+1 row in set (0.00 sec) LENGTH 명령어 1select LENGTH(&#x27;hello&#x27;); 결과 123456+-----------------+| LENGTH(&#x27;hello&#x27;) |+-----------------+| 5 |+-----------------+1 row in set (0.00 sec) 날짜 함수 year(DATE), year(DATETIME) hour(TIME), hour(DATETIME) minute(TIME), minute(DATETIME) second(TIME), second(DATETIME) DATE_FORMAT(DATE, format) year(DATE) 명령어 1select year(&#x27;2020-06-05&#x27;); 결과 123456+--------------------+| year(&#x27;2020-06-05&#x27;) |+--------------------+| 2020 |+--------------------+1 row in set (0.00 sec) hour(TIME) 명령어 1select hour(&#x27;11:42:55&#x27;); 결과 123456+------------------+| hour(&#x27;11:42:55&#x27;) |+------------------+| 11 |+------------------+1 row in set (0.00 sec) minute(TIME) 명령어 1select minute(&#x27;11:42:55&#x27;); 결과 123456+--------------------+| minute(&#x27;11:42:55&#x27;) |+--------------------+| 42 |+--------------------+1 row in set (0.00 sec) second(TIME) 명령어 1select second(&#x27;11:42:55&#x27;); 결과 123456+--------------------+| second(&#x27;11:42:55&#x27;) |+--------------------+| 55 |+--------------------+1 row in set (0.00 sec) DATE_FORMAT123SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%y-%m-%d&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 모두 소문자로 데이터 형식을 표시하게 되면 2글자 형식으로 표현을 한다. 123SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%Y-%m-%d&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 년도를 대문자로 데이텨 형식을 표현하게 되면 구체적인 년도를 표시한다. 123SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%y-%M-%d&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 달을 대문자로 표시하게 되면 영문으로 해당 달을 표시해준다. 123SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#x27;%y-%m-%D&#x27;) AS &#x27;날짜&#x27;from ANIMAL_INSorder by ANIMAL_ID 일을 대문자로 표시하게 되면 기수로 해당 일을 표시해준다. SQL문 처리순서 FROM WHERE GROUP BY HAVING SELECT ORDER BY 원하는 테이블을 찾아가(FROM) 조건을 이용해 원하는 데이터를 검색한 후(WHERE) 그룹으로 묶은 뒤(GROUP BY) 그룹화된 데이터를 조건을 이용해 검색한 후(HAVING) 원하는 데이터를 선택해(SELECT) 정렬해서 내보낸다.(ORDER BY) 프로그래머스 sql문제select 문 모든 레코드 조회하기 https://programmers.co.kr/learn/courses/30/lessons/59034 역순 정렬하기 https://programmers.co.kr/learn/courses/30/lessons/59035 아픈 동물 찾기 https://programmers.co.kr/learn/courses/30/lessons/59036 어린 동물 찾기 https://programmers.co.kr/learn/courses/30/lessons/59037 동물의 아이디와 이름 https://programmers.co.kr/learn/courses/30/lessons/59403 여러 기준으로 정렬하기 https://programmers.co.kr/learn/courses/30/lessons/59404 상위 n개 레코드 https://programmers.co.kr/learn/courses/30/lessons/59405 집계함수 (SUM, MAX, MIN) 최댓 값 구하기 https://programmers.co.kr/learn/courses/30/parts/17043 최솟 값 구하 https://programmers.co.kr/learn/courses/30/lessons/59038 동물 수 구하기 https://programmers.co.kr/learn/courses/30/lessons/59406 중복 제거하기 https://programmers.co.kr/learn/courses/30/lessons/59408 그룹화 (GROUP BY) 고양이와 개는 몇마리 있을까 https://programmers.co.kr/learn/courses/30/lessons/59040 동명 동물 수 찾기 https://programmers.co.kr/learn/courses/30/lessons/59041 입양 시각 구하기 https://programmers.co.kr/learn/courses/30/lessons/59412 입양 시각 구하기2 https://programmers.co.kr/learn/courses/30/lessons/59413 NULL 처리하기 이름이 없는 동물의 아이디 https://programmers.co.kr/learn/courses/30/lessons/59039 이름이 있는 동물의 아이디 https://programmers.co.kr/learn/courses/30/lessons/59407 NULL 처리하기 https://programmers.co.kr/learn/courses/30/lessons/59410 JOIN문 없어진 기록 찾기 https://programmers.co.kr/learn/courses/30/lessons/59042 있었는데요 없었습니다. https://programmers.co.kr/learn/courses/30/lessons/59043 오랜 기간 보호한 동물(1) https://programmers.co.kr/learn/courses/30/lessons/59044 보호소에서 중성화한 동물 https://programmers.co.kr/learn/courses/30/lessons/59045 String, Date 루시와 엘라 찾기 https://programmers.co.kr/learn/courses/30/lessons/59046 이름에 el이 들어가는 동물 찾기 https://programmers.co.kr/learn/courses/30/lessons/59047 중성화 여부 파악하기 https://programmers.co.kr/learn/courses/30/lessons/59409 오랜기간 보호한 동물(2) https://programmers.co.kr/learn/courses/30/lessons/59411 DATETIME에서 DATE로 형 변환 https://programmers.co.kr/learn/courses/30/lessons/59414","categories":[{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"}],"tags":[]},{"title":"스프링 MVC 시작하기 - XML로 세팅하기","slug":"spring/Spring5MVC/Spring5MVC-1-xml-setting","date":"2021-03-04T06:42:21.000Z","updated":"2021-02-07T09:50:17.034Z","comments":true,"path":"2021/03/04/spring/Spring5MVC/Spring5MVC-1-xml-setting/","link":"","permalink":"https://ckck803.github.io/2021/03/04/spring/Spring5MVC/Spring5MVC-1-xml-setting/","excerpt":"","text":"Web.xml 설정하기 root-context.xml 설정하기 servlet-context 설정하기 Web.xml 설정하기 톰캣 DispatcherServlet 을 스프링 DispatcherServlet 으로 바꾸기 Bean을 정의할 xml 파일을 정의하기 Listener 를 설정한다. 파라미터 인코더 를 설정한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;4.0&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;&gt; &lt;!-- 요청 정보를 분석해서 컨트롤러를 선택하는 서블릿을 지정한다. --&gt; &lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;!-- Spring MVC에서 제공하고 있는 기본 서블릿을 지정한다. --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring MVC 설정을 위한 xml 파일을 지정한다. --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 현재 웹 애플리케이션에서 받아들이는 모든 요청에 대해 appServlet이라는 이름으로 정의되어 있는 서블릿을 사용하겠다. --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- Bean을 정의할 xml 파일을 지정한다. --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/root-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 리스너설정 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 파라미터 인코딩 필터 설정 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; root-context.xml 설정하기123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; servlet-context 설정하기 어노테이션을 가진 클래스들을 Bean으로 등록 Component들을 Scan할 위치를 지정한다. View경로를 위한 prefix, suffix를 지정한다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring5 MVC","slug":"Spring/Spring5-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring5-MVC/"}],"tags":[]},{"title":"스프링부트를 이용한 게시판 만들기 20 - 젠킨스를 이용해 배포하기","slug":"springboot/sample-board/board-20-jenkins-deploy","date":"2021-03-01T15:13:12.000Z","updated":"2021-03-13T11:29:27.732Z","comments":true,"path":"2021/03/02/springboot/sample-board/board-20-jenkins-deploy/","link":"","permalink":"https://ckck803.github.io/2021/03/02/springboot/sample-board/board-20-jenkins-deploy/","excerpt":"","text":"20. 젠킨스를 이용해 배포하기플러그인 설치Jenkins 관리 &gt; 플러그인 관리 Publish Over SSH를 설치해준다. 원격 서버 접속 설정하기","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://ckck803.github.io/tags/Jenkins/"}]},{"title":"스프링부트를 이용한 게시판 만들기 19 - 프록시 서버 이용하기","slug":"springboot/sample-board/board-19-nginx","date":"2021-03-01T05:07:30.000Z","updated":"2021-03-13T11:29:31.082Z","comments":true,"path":"2021/03/01/springboot/sample-board/board-19-nginx/","link":"","permalink":"https://ckck803.github.io/2021/03/01/springboot/sample-board/board-19-nginx/","excerpt":"","text":"19. 프록시 서버 이용하기현재는 client 가 Web Application에 접근하기 위해서는 8080포트를 사용해야 한다. client가 쉽게 접근 할 수 있도록 80번 포트로 어플리케이션을 띄어야 하는데 ubuntu에서는 일반 사용자가 80번 포트를 사용할 수 있는 권한이 없다. 만약 80번 포트로 프로그램을 실행하게 되면 아래와 같은 권한 오류가 뜨게 된다. 그렇다고 어플리케이션을 띄울 때 마다 매번 sudo권한으로 실행시킬 수도 없는 노릇이다. 맥에서는 80번 포트로 잘 열리는데 우분투에서 오류가 떠서 당황 했다. 우분투에서 1024미만 포트는 일반 사용자가 사용할 수 없는 포트이다. 12345678910111213Caused by: java.net.SocketException: Permission denied at java.base/sun.nio.ch.Net.bind0(Native Method) ~[na:na] at java.base/sun.nio.ch.Net.bind(Net.java:455) ~[na:na] at java.base/sun.nio.ch.Net.bind(Net.java:447) ~[na:na] at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:227) ~[na:na] at java.base/sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:80) ~[na:na] at org.apache.tomcat.util.net.NioEndpoint.initServerSocket(NioEndpoint.java:228) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:211) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.AbstractEndpoint.bindWithCleanup(AbstractEndpoint.java:1159) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.tomcat.util.net.AbstractEndpoint.start(AbstractEndpoint.java:1245) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.coyote.AbstractProtocol.start(AbstractProtocol.java:603) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] at org.apache.catalina.connector.Connector.startInternal(Connector.java:1064) ~[tomcat-embed-core-9.0.41.jar!/:9.0.41] ... 29 common frames omitted nginx를 이용해 프록시 서버 만들어주기80번 포트를 사용하기 위해 Proxy 서버를 띄어 놓고 Proxy 서버로 요청이 들어오면 Spring Boot 프로그램으로 Forwarding 해주도록 설정을 할 것이다. sudo 명령어를 사용해 프로그램을 시키는 방법도 있지만, 매번하기에는 번거롭다는 단점도 있고 /etc/sudoers에 패스워드 권한을 풀어줄 수도 있지만 보안상의 문제가 있어서 가장 안전한 방법으로 Proxy 서버를 이용하기로 했다. nginx 설치하기1sudo apt-get install nginx nginx 실행1sudo service nginx start 프로그램을 실행행한 후 80번 포트로 접속하게 되면 환영한다는 nginx 페이지가 보인다. nginx 설정 확인하기nignx의 기본적인 설정은 nginx.conf파일에 저장돼 있다. 마지막 부분을 보면 conf.d폴더에 nginx에 추가적인 설정 정보를 불러오게 하는 설정이 있다. 여기에 80번 요청이 들어오면 8080포트로 포워딩 할 수 있게 설정 파일을 만들어 주도록한다. 설정 파일을 살펴보면 conf.d 디렉터리와 sites-enabled(sites-available) 디렉터리 내의 구성을 읽어오는 부분이 있다.sites-enabled에는 nginx에 대한 기본 설정값이 있다. 둘 중 아무곳에나 설정 값을 넣어도 되지만, 설정과 관련된 부분이라 conf.d 디렉터리에 저장하도록 했다. /etc/nginx/nginx.conf 12345http &#123; ... include /etc/nginx/conf.d/*.conf; # include /etc/nginx/sites-enabled/*; 덮어쓰기를 방지하기 위한 주석 처리&#125; /etc/nginx/conf.d 폴더로 이동해 포트 포워딩 설정을 위한 server.conf파일을 생성한다.nginx listen 포트로는 80번 포트를 사용하고 해당 url로 들어오는 모든 요청을 8080포트로 보내주는 설정을 추가한다. proxy_set_header X-Real-Ip $remote_addr : X-Real-Ip 헤더 값으로 Client의 IP값을 넣어준다.proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for : X-Forwarded-For 헤더 값으로 포워딩 된 프록시 서버의 IP값을 넣어준다.proxy_set_header Host $http_host : Host 헤더에는 서버의 주소 or 도메인을 넣어준다. (도메인 정보를 매핑하고 싶을 때도 사용) /etc/nginx/conf.d/server.conf 1234567891011server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:8080; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; &#125;&#125; 80번 포트로 접근 했을 때 8080포트에 떠있는 Web Application이 나타나는 것을 확인할 수 있다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"nginx","slug":"nginx","permalink":"https://ckck803.github.io/tags/nginx/"}]},{"title":"스프링부트를 이용한 게시판 만들기 18 - Build시 DB 연결 Bug Fix 및 Profile 설정","slug":"springboot/sample-board/board-18-profile","date":"2021-02-25T23:03:09.000Z","updated":"2021-03-13T11:29:35.699Z","comments":true,"path":"2021/02/26/springboot/sample-board/board-18-profile/","link":"","permalink":"https://ckck803.github.io/2021/02/26/springboot/sample-board/board-18-profile/","excerpt":"","text":"18. Build시 DB 연결 Bug Fix 및 Profile 설정Jenkins에서 build 오류Jenkins에서 Build를 진행하면 Test시 해당 오류가 발생하게 된다. Test를 진행하면서 DBConfigByYml 클래스내 필드를 Application-mysql.yml 를 이용해 채우게 되는데 Application-mysql.yml 파일이 Github에는 올라가 있지 않아 문제가 생기게 되는 것이다. 1234567891011121314151617181920212223242526272829&gt; Task :testSampleBoardApplicationTests &gt; contextLoads() FAILED java.lang.IllegalStateException at DefaultCacheAwareContextLoaderDelegate.java:132 Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException at ConstructorResolver.java:800 Caused by: org.springframework.beans.factory.BeanCreationException at AutowiredAnnotationBeanPostProcessor.java:405 Caused by: java.lang.IllegalArgumentException at PropertyPlaceholderHelper.java:1782021-02-24 16:17:02.458 INFO 1610 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &#x27;applicationTaskExecutor&#x27;17 tests completed, 1 failed&gt; Task :test FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task &#x27;:test&#x27;.&gt; There were failing tests. See the report at: file:///var/jenkins_home/workspace/sample-board/build/reports/tests/test/index.html* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 53s7 actionable tasks: 7 executedBuild step &#x27;Invoke Gradle script&#x27; changed build result to FAILUREBuild step &#x27;Invoke Gradle script&#x27; marked build as failureFinished: FAILURE 여러개의 @PropertySource 사용하기첫번째로 해결한 방법은 @PropertySource를 두개 사용하여 test를 진행할 시에는 H2 database를 바라보게 하고 운영시에는 MySQL을 바라 볼 수 있게 설정 파일을 두게 만들어 사용했다. @PropertySource는 순서에 따라 아래 값이 이전 값을 덮어 쓰게 된다. DBConfigByYml.java 123456789101112131415161718192021222324252627@Configuration@PropertySource(value = &quot;classpath:application-h2.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource() &#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125; 여러개의 PropertySource 묶기PropertySources 어노테이션을 사용하면 여러개의 PropertySource를 묶을 수 있다. 1234@PropertySources(&#123; @PropertySource(value = &quot;classpath:application-h2.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true), @PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)&#125;) Profile 어노테이션을 이용한 방법두번째로 해결한 방법은 Profile 어노테이션을 사용해 운영시에만 설정을 구성하도록 했다. 운영외에는 MySQL 설정을 구성하지 않도록 해 오류가 발생하지 않게 했다. DBConfigByYml.java 123456789101112131415161718192021222324252627@Configuration@Profile(&quot;prod&quot;)@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class, ignoreResourceNotFound = true)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource() &#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"properties","slug":"properties","permalink":"https://ckck803.github.io/tags/properties/"}]},{"title":"스프링부트를 이용한 게시판 만들기 17 - 외부로부터 설정 받기(yml)","slug":"springboot/sample-board/board-17-yml","date":"2021-02-24T12:34:39.000Z","updated":"2021-03-13T11:29:39.922Z","comments":true,"path":"2021/02/24/springboot/sample-board/board-17-yml/","link":"","permalink":"https://ckck803.github.io/2021/02/24/springboot/sample-board/board-17-yml/","excerpt":"","text":"17. 외부로부터 설정 받기(yml)YamlPropertySourceFactory.java 1234567891011121314151617181920212223242526272829public class YamlPropertySourceFactory implements PropertySourceFactory &#123; @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123; Properties propertiesFromYaml = loadYamlIntoProperties(resource); String sourceName = name != null ? name : resource.getResource().getFilename(); return new PropertiesPropertySource(sourceName, propertiesFromYaml); &#125; private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException &#123; try &#123; YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean(); factory.setResources(resource.getResource()); factory.afterPropertiesSet(); return factory.getObject(); &#125; catch (IllegalStateException e) &#123; // for ignoreResourceNotFound Throwable cause = e.getCause(); if (cause instanceof FileNotFoundException) &#123; throw (FileNotFoundException) e.getCause(); &#125; throw e; &#125; &#125;&#125; DBConfigByYml.java 1234567891011121314151617181920212223242526@Configuration@PropertySource(value = &quot;classpath:application-mysql.yml&quot;, factory = YamlPropertySourceFactory.class)public class DBConfigByYml &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"properties","slug":"properties","permalink":"https://ckck803.github.io/tags/properties/"}]},{"title":"스프링부트를 이용한 게시판 만들기 16 - 외부로부터 설정 받기(property)","slug":"springboot/sample-board/board-16-properties","date":"2021-02-24T10:31:58.000Z","updated":"2021-03-13T11:29:42.863Z","comments":true,"path":"2021/02/24/springboot/sample-board/board-16-properties/","link":"","permalink":"https://ckck803.github.io/2021/02/24/springboot/sample-board/board-16-properties/","excerpt":"","text":"16. 외부로부터 설정 받기(property)Github에 프로젝트를 올릴때 데이터 베이스 접속 연결과 같은 민감한 정보는 다른 사람이 열람해서는 안되는 정보라 형상관리에서 제외한 상태로 올리게 된다. .gitignore 12**/application-mysql.yml**/application-mysql.properties 데이터베이스 접속을 위한 properties 만들기application-mysql.properties 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/&#123;테이블&#125;serverTimezone=UTC&amp;characterEncoding=UTF-8spring.datasource.username=&#123;Username&#125;spring.datasource.password=&#123;Password&#125; TransactionManagementConfigurer은 Spring에서 데티어베이스 연결을 지원한다. DBConfig.java 12345678910111213141516171819202122232425262728293031@Configuration@PropertySource(value = &quot;classpath:/application-mysql.properties&quot;)public class DBConfig implements TransactionManagementConfigurer &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; return DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(username) .password(password) .build(); &#125; @Override public TransactionManager annotationDrivenTransactionManager() &#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Github","slug":"Github","permalink":"https://ckck803.github.io/tags/Github/"}]},{"title":"스프링 핵심 원리4 - 싱글톤 컨테이너","slug":"springboot/Spring-Core/basic/basic4-singleton","date":"2021-02-22T14:45:34.000Z","updated":"2021-03-13T11:33:45.076Z","comments":true,"path":"2021/02/22/springboot/Spring-Core/basic/basic4-singleton/","link":"","permalink":"https://ckck803.github.io/2021/02/22/springboot/Spring-Core/basic/basic4-singleton/","excerpt":"","text":"스프링 핵심 원리4 - 싱글톤 컨테이너","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"},{"name":"스프링 핵심 원리 - 기본편","slug":"Spring-Boot/Spring-Core/스프링-핵심-원리-기본편","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"}],"tags":[{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"}]},{"title":"스프링 핵심 원리3 - 스프링 컨테이너와 스프링빈","slug":"springboot/Spring-Core/basic/basic3-spring","date":"2021-02-21T03:03:10.000Z","updated":"2021-03-13T11:34:27.322Z","comments":true,"path":"2021/02/21/springboot/Spring-Core/basic/basic3-spring/","link":"","permalink":"https://ckck803.github.io/2021/02/21/springboot/Spring-Core/basic/basic3-spring/","excerpt":"","text":"스프링 핵심 원리3 - 스프링 컨테이너와 스프링빈Config 파일 등록하기123456789101112131415161718192021222324@Configurationpublic class AppConfig &#123; @Bean public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; @Bean public MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; @Bean public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; @Bean public DiscountPolicy discountPolicy() &#123;// return new FixDiscountPolicy(); return new RateDiscountPolicy(); &#125;&#125; Configuration 어노테이션을 통해 AppConfig를 설정(구성) 정보로 사용한다.Bean 어노테이션을 통해 스프링 컨테이너에 등록한다. Spring Container생섬 및 등록된 Bean들 가져오기123456789101112131415161718192021public class OrderApp &#123; public static void main(String[] args) &#123;// AppConfig appConfig = new AppConfig();//// MemberService memberService = appConfig.memberService();// OrderService orderService = appConfig.orderService(); ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MemberService memberService = applicationContext.getBean(&quot;memberService&quot;, MemberService.class); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); Long memberId = 1L; Member member = new Member(memberId, &quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId, &quot;itemA&quot;, 20000); System.out.println(&quot;order = &quot; + order); &#125;&#125; ApplicationContext를 통해 Spring Container를 생성한다. 어노테이션 기반의 Config를 사용하므로 AnnotationConfigApplicationContext 클래스를 통해 Spring Container를 생성하고 Bean 어노테이션이 붙은 메소드를 호출해 Spring Container에 등록한 후 Bean의 의존 관계를 주입한다. Container에 등록된 Bean은 getBean메소드를 통해 가져온다. 스프링에 등록된 빈 확인하기등록된 모든 빈 확인12345678910111213141516171819202122232425@Test@DisplayName(&quot;모든 빈 출력하기&quot;)void findAllBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;bean = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125;&#125;@Test@DisplayName(&quot;애플리케이션 빈 출력하기&quot;)void findApplicationBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION)&#123; Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;name = &quot; + beanDefinitionName + &quot; object = &quot; + bean); &#125; &#125;&#125; 동일한 타입이 둘 이상1234567891011121314151617181920212223242526272829303132333435public class ApplicationContextBasicFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(&quot;빈 이름으로 조회&quot;) void findBeanByName()&#123; MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;이름없이 타입으로 조회&quot;) void findBeanByType()&#123; MemberService memberService = ac.getBean(MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;구체 타입으로 조회&quot;) void findBeanByType2()&#123; MemberServiceImpl memberService = ac.getBean(&quot;memberService&quot;, MemberServiceImpl.class); // 구체적으로 적는 것은 별로 않좋다. // 될 수 있는한 추상화한 인터페이스에 테스트를 맞춘다. assertThat(memberService).isInstanceOf(MemberServiceImpl.class); &#125; @Test @DisplayName(&quot;빈 이름으로 조회X&quot;) void findBeanByNameX()&#123; assertThatThrownBy(()-&gt;&#123; MemberService xxxxx = ac.getBean(&quot;xxxxx&quot;, MemberService.class); &#125;).isInstanceOf(NoSuchBeanDefinitionException.class); &#125;&#125; 상속 관계1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ApplicationContextSameBeanFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class); @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.&quot;) void findBeanByTypeDuplicate()&#123; assertThatThrownBy(() -&gt;&#123; ac.getBean(MemberRepository.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class); &#125; @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.&quot;) void findBeanByName()&#123; MemberRepository memberRepository = ac.getBean(&quot;memberRepository1&quot;, MemberRepository.class); assertThat(memberRepository).isEqualTo(MemberRepository.class); &#125; @Test @DisplayName(&quot;특정 타입을 모두 조회하기&quot;) void findAllBeanByType()&#123; Map&lt;String, MemberRepository&gt; beansOfType = ac.getBeansOfType(MemberRepository.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value =&quot; + beansOfType.get(key)); &#125; System.out.println(&quot;beansOfType = &quot; + beansOfType); assertThat(beansOfType.size()).isEqualTo(2); &#125; @Configuration static class SameBeanConfig &#123; @Bean public MemberRepository memberRepository1() &#123; return new MemoryMemberRepository(); &#125; @Bean public MemberRepository memberRepository2() &#123; return new MemoryMemberRepository(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ApplicationContextExtendsFindTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다.&quot;) void findBeanByParentTypeDuplicate()&#123; assertThatThrownBy(() -&gt; &#123; ac.getBean(DiscountPolicy.class); &#125;).isInstanceOf(NoUniqueBeanDefinitionException.class); &#125; @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정한다.&quot;) void findBeanByParentTypeBeanName()&#123; DiscountPolicy rateDiscountPolicy = ac.getBean(&quot;rateDiscountPolicy&quot;, DiscountPolicy.class); assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class); &#125; @Test @DisplayName(&quot;특정 하위 타입으로 조회&quot;) void findBeanBySubType()&#123; // 구체적인 타입을 지정 RateDiscountPolicy bean = ac.getBean(RateDiscountPolicy.class); assertThat(bean).isInstanceOf(RateDiscountPolicy.class); &#125; @Test @DisplayName(&quot;부모 타입으로 모두 조회하기&quot;) void findAllBeanByParentType()&#123; Map&lt;String, DiscountPolicy&gt; beansOfType = ac.getBeansOfType(DiscountPolicy.class); assertThat(beansOfType.size()).isEqualTo(2); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); &#125; &#125; @Test @DisplayName(&quot;부모 타입으로 모두 조회하기 - Object&quot;) void findAllBeanByObjectType()&#123; Map&lt;String, Object&gt; beansOfType = ac.getBeansOfType(Object.class); for(String key : beansOfType.keySet())&#123; System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); &#125; &#125; @Configuration static class TestConfig&#123; @Bean public DiscountPolicy rateDiscountPolicy()&#123; return new RateDiscountPolicy(); &#125; @Bean public DiscountPolicy fixDiscountPolicy()&#123; return new FixDiscountPolicy(); &#125; &#125;&#125; XML을 이용해 스프링 설정하기최근 스프링 부트의 등장으로 xml을 이용해 스프링을 설정하는 방법은 잘 사용하지 않는다.xml을 이용해 스프링 컨테이너를 설정하는 것의 장점은 컴파일 없이 빈 설정 정보를 변경할 수 있다는 점이다. appConfig.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;memberService&quot; class = &quot;com.example.springbasic.member.MemberServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;memberRepository&quot; class=&quot;com.example.springbasic.member.MemoryMemberRepository&quot;/&gt; &lt;bean id=&quot;orderService&quot; class=&quot;com.example.springbasic.order.OrderServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot;/&gt; &lt;constructor-arg name=&quot;discountPolicy&quot; ref=&quot;discountPolicy&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;discountPolicy&quot; class=&quot;com.example.springbasic.discount.RateDiscountPolicy&quot;/&gt;&lt;/beans&gt; xmlAppContext.java 123456789public class XmlAppContext &#123; @Test void xmlAppContext()&#123; ApplicationContext ac = new GenericXmlApplicationContext(&quot;appConfig.xml&quot;); MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); assertThat(memberService).isInstanceOf(MemberService.class); &#125;&#125; BeanDefinition AnnotationConfigApplicationContext는 AnnotatedBeanDefinitionReader를 이용해 AppConfig.class를 읽고 BeanDefinition을 생성한다. GenericXmlApplicationContext는 XmlBeanDefinitionReader를 이용해 appConfig.xml을 읽고 BeanDefinition을 생성한다. BeanDefinition 확인12345678910111213141516171819public class BeanDefinitionTest &#123; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(&quot;빈 설정 메타정보 확인&quot;) void findApplicationBean()&#123; String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for(String beanDefinitionName : beanDefinitionNames)&#123; BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION)&#123; System.out.println(&quot;beanDefinition = &quot; + beanDefinition + &quot;beanDefinition = &quot; + beanDefinition); &#125; &#125; &#125;&#125; Bean을 등록하는 방법은 크게 두가지가 있다 1. Bean을 직접 등록하는 방법, 2. FactoryBean을 이용한 방법","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"},{"name":"스프링 핵심 원리 - 기본편","slug":"Spring-Boot/Spring-Core/스프링-핵심-원리-기본편","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"}],"tags":[{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"}]},{"title":"스프링 핵심 원리 이해2 - 객체 지향 원리 적용","slug":"springboot/Spring-Core/basic/basic2","date":"2021-02-20T07:58:27.000Z","updated":"2021-03-13T11:31:56.989Z","comments":true,"path":"2021/02/20/springboot/Spring-Core/basic/basic2/","link":"","permalink":"https://ckck803.github.io/2021/02/20/springboot/Spring-Core/basic/basic2/","excerpt":"","text":"스프링 핵심 원리 이해2 - 객체 지향 원리 적용DIP 원칙 위반 - 추상화와 구체화 둘다 의존MemberServiceImpl.java 1234567891011121314public class MemberServiceImpl implements MemberService&#123; private final MemberRepository memberRepository = new MemoryMemberRepository(); @Override public void join(Member member) &#123; memberRepository.save(member); &#125; @Override public Member findMember(Long memberId) &#123; return memberRepository.findById(memberId); &#125;&#125; MemberServiceImpl 클래스는 MemberRepository 인터페이스를 의존하면서 구현 클래스인 MemoryMemberRepository도 의존하고 있다. OrderServiceImpl.java 1234567891011121314public class OrderServiceImpl implements OrderService &#123; private final MemberRepository memberRepository = new MemoryMemberRepository(); private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125; OrderServiceImpl 클래스는 MemberRepository 인터페이스와 DiscountPolicy 인터페이스를 의존하면서 구현 클래스인 MemoryMemberRepository와 RateDiscountPolicy를 의존하고 있다. 추상화와 구체화 둘다 의존하는 문제가 있다.=&gt; DIP 위반 DIP : 구현 class가 아닌 추상화 되어 있는 Interface에 의존해야 한다.DIP의 원칙을 지키기 위해 의존 class내에서 구현 클래스를 가져오는 부분을 삭제하게 되면객체가 존재하지 않아서 nullPointException이 발생한다. OCP 원칙 위반 - 정책 변경시 client 코드를 수정OrderServiceImpl.java 123456789101112131415public class OrderServiceImpl implements OrderService &#123; private final MemberRepository memberRepository = new MemoryMemberRepository(); // private final DiscountPolicy discountPolicy = new FixDiscountPolicy(); private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125; DiscountPolicy의 구현체가 FixDiscountPolicy에서 RateDiscountPolicy로 바뀌게 되면 OrderServiceImpl에서 FixDiscountPolicy를 RateDiscountPolicy로 변경하기 위해서 코드를 수정해줘야 한다. 구현 객체를 변경하기 위해서 클라이언트 코드를 변경=&gt; OCP 위반 객체의 생성 및 연결과 실행하는 부분을 분리애플리케이션의 전체 동작방식을 구성하기 위해 구현 객체 생성 및 연결을 위한 별도의 설정 class 관심사의 분리가 이루어지게 됐다.=&gt; 객체 생성 및 연결과 실행하는 부분의 logic이 분리가 됐다. AppConfig.java 12345678910public class AppConfig &#123; public MemberService memberService()&#123; return new MemberServiceImpl(new MemoryMemberRepository()); &#125; public OrderService orderService()&#123; return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy()); &#125;&#125; AppConfig 클래스 내의 memberService 메소드는 MemberService의 구현체인 MemberServiceImpl를 반환한다.MemberServiceImpl 객체를 생성할 때 MemberRepository의 구현체인 MemoryMemberRepository 객체를 주입해준다. MemberServiceImpl 생성자를 통해 MemoryMemberRepository 객체를 주입해주는 것을 생성자를 통한 의존성 주입이라 한다. MemberServiceImpl.java 123456789101112131415161718public class MemberServiceImpl implements MemberService&#123; private final MemberRepository memberRepository; public MemberServiceImpl(MemberRepository memberRepository)&#123; this.memberRepository = memberRepository; &#125; @Override public void join(Member member) &#123; memberRepository.save(member); &#125; @Override public Member findMember(Long memberId) &#123; return memberRepository.findById(memberId); &#125;&#125; MemberServiceImpl는 이제 MemberRepository 인터페이스에만 의존하게 되므로 DIP 원칙을 지키게 됐다. OrderServiceImpl.java 12345678910111213141516171819public class OrderServiceImpl implements OrderService &#123; private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy)&#123; this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; &#125; @Override public Order createOrder(Long memberId, String itemName, int itemPrice) &#123; Member member = memberRepository.findById(memberId); int discountPrice = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discountPrice); &#125;&#125; OrderServiceImpl는 MemberRepository 인터페이스와 DiscountPolicy 인터페이스에 의존하므로 DIP 원칙을 지키게 됐다. MemberServiceImpl와 OrderServiceImpl는 인터페이스에만 의존하게 함으로 코드상으로는 어떤 구현 객체가 들어올지는 알 수 없고, 생성자를 통해 외부에서 구현객체를 주입 받게 된다. AppConfig를 통해 객체의 생성과 연결을 진행 하고MemberServiceImpl와 OrderServiceImpl는 실행만 하면 되므로 역할이 분리가 됐다.또한 외부에서 MemberServiceImpl와 OrderServiceImpl에 구현객체를 넣어주는 것을 보고 의존성 주입이라 한다. AppConfig 리펙터링AppConfig.java 123456789101112131415161718public class AppConfig &#123; public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; private MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; private DiscountPolicy discountPolicy() &#123; return new FixDiscountPolicy(); &#125;&#125; 메소드명과 return 타입을 통해 역할을 할 수 있게 됐고, 반환 객체를 통해 구현 객체를 알기 쉽게 됐다. 구현 객체 변경AppConfig.java 12345678910111213141516171819public class AppConfig &#123; public MemberService memberService()&#123; return new MemberServiceImpl(memberRepository()); &#125; private MemberRepository memberRepository() &#123; return new MemoryMemberRepository(); &#125; public OrderService orderService()&#123; return new OrderServiceImpl(memberRepository(), discountPolicy()); &#125; private DiscountPolicy discountPolicy() &#123;// return new FixDiscountPolicy(); return new RateDiscountPolicy(); &#125;&#125; 구현 객체를 변경하게 되면 AppConfig만 변경하면 된다. AppConfig의 등장으로 구현 객체들은 자신의 로직을 실행하는 역할만 담당하게 됐다. 프로그램의 제어 흐름은 이제 AppConfig에서 담당한다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"},{"name":"스프링 핵심 원리 - 기본편","slug":"Spring-Boot/Spring-Core/스프링-핵심-원리-기본편","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"}],"tags":[{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"}]},{"title":"스프링 핵심 원리1 - 객체 지향 설계 5원칙 SOLID","slug":"springboot/Spring-Core/basic/basic1-solid","date":"2021-02-20T05:16:17.000Z","updated":"2021-03-13T11:31:48.682Z","comments":true,"path":"2021/02/20/springboot/Spring-Core/basic/basic1-solid/","link":"","permalink":"https://ckck803.github.io/2021/02/20/springboot/Spring-Core/basic/basic1-solid/","excerpt":"","text":"객체 지향 설계 5원칙 SOLID1. SRP(Single Responsibility Principle) - 단일 책임 원칙한 클래스는 하나의 책임(역할)만 가져야 한다. 역할의 분리라고 생각하면 편하다!변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따르는 것 2. OCP(Open Close Principle) - 개방 폐쇄 원칙확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 3. LSP(The Liskov Substitution Principle) - 라스코프 치환 원칙프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 인터페이스 규약을 잘 지켜야 한다. 4. ISP(Interface Segregation Principle) - 인터페이스 분리 원칙하나의 범용 인터페이스보다 특정 클라이언트를 위한 여러 인터페이스가 좋다. 5. DIP(Dependency Inversion Principle) - 의존 관계 역전 원칙프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.구현 클래스에 의존하지 않고, 인터페이스에 의존하라는 뜻이다. 스프링과 객체 지향 원칙스프링은 DI(Dependency Injection)과 DI 컨테이너를 통해 OCP와 DIP를 가능하게 지원한다. client의 코드 변경 없이 개발이 가능하다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"},{"name":"스프링 핵심 원리 - 기본편","slug":"Spring-Boot/Spring-Core/스프링-핵심-원리-기본편","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"}],"tags":[{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"}]},{"title":"Spring Boot - 독립적으로 실행 가능한 JAR","slug":"springboot/spring-framework/springboot-jar","date":"2021-02-18T16:05:00.000Z","updated":"2021-03-13T11:38:30.381Z","comments":true,"path":"2021/02/19/springboot/spring-framework/springboot-jar/","link":"","permalink":"https://ckck803.github.io/2021/02/19/springboot/spring-framework/springboot-jar/","excerpt":"","text":"독립적으로 실행 가능한 JAR앱을 어딘가에 배포하거나 도커 이미지로 만들거나 하기 위해서는 jar패키지로 패키징한 후 jar파일을 실행하는게 유용하다. jar파일 생성1mvn package mvn pakcage명령어를 통해 앱을 jar파일로 생성한다. jar파일이 생성됨을 확인할 수 있다. jar파일 안에는 앱을 실행하기 위한 의존성(library)들이 전부 다 포함되어 있다. jar 파일 실행1java -jar springinit-1.0-SNAPSHOT.jar java -jar명령어를 통해 jar파일을 실행할 수 있다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring Boot - 내장 웹 서버 응용 2부(HTTPS와 HTTP2)","slug":"springboot/spring-framework/springboot-http2","date":"2021-02-18T16:01:22.000Z","updated":"2021-03-13T11:38:25.133Z","comments":true,"path":"2021/02/19/springboot/spring-framework/springboot-http2/","link":"","permalink":"https://ckck803.github.io/2021/02/19/springboot/spring-framework/springboot-http2/","excerpt":"","text":"내장 웹 서버 응용 2부 : HTTPS와 HTTP2https를 사용하기 위해서는 키스토어가 필요하다. 키스토어 생성12345678# 저는 줄 바꿈 문자 해결 했습니당 ^^keytool -genkey \\ -alias tomcat \\ -storetype PKCS12 \\ -keyalg RSA \\ -keysize 2048 \\ -keystore keystore.p12 \\ -validity 4000 위 명령어를 사용하여 키 스토어를 생성할 수 있다. 12345678910111213141516키 저장소 비밀번호 입력:새 비밀번호 다시 입력:이름과 성을 입력하십시오. [Unknown]: dongwoo yang조직 단위 이름을 입력하십시오. [Unknown]: island조직 이름을 입력하십시오. [Unknown]: ceo구/군/시 이름을 입력하십시오? [Unknown]: seongbuk시/도 이름을 입력하십시오. [Unknown]: seoul이 조직의 두 자리 국가 코드를 입력하십시오. [Unknown]: krCN=dongwoo yang, OU=island, O=ceo, L=seongbuk, ST=seoul, C=kr이(가) 맞습니까? [아니오]: 예 해당 질문들이 나오는데, 마지막에 “네” 혹은 “yes”를 하게 되면 무한루프에 빠지게 된다….. 예라고 꼭!!!! 적어주도록…. key를 생성하게 된 다음에 git을 사용하고 있는 중이라면 꼭!!! gitignore에 추가하자!!! 키스토어 사용을 위한 세팅해주기 application.properties 1234server.ssl.key-store=keystore.p12server.ssl.key-store-type=PKCS12server.ssl.key-store-password=123456server.ssl.key-alias=tomcat 위에 기입했던 내용하고 일치해야 한다 특히 alias 백기선 님이 tomcat이라 올려놓고 강의에는 spring이라고 해서 실행이 계속 안됬다… Application.java 12345678910111213@SpringBootApplication@RestControllerpublic class Application &#123; @GetMapping(&quot;&#x2F;hello&quot;) public String hello()&#123; return &quot;Hello Spring&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; localhost:8080으로 http 접속을 하게 되면 해당 결과를 받게 된다.이제부터 우리는 https를 이용하여 접속해야 한다. https://localhost:8080 형식으로 접속을 시도 하면 위의 문구가 뜨게 된다.(웹 브라우저마다 살짝 다르게 표시됨.) 이는 웹 브라우저가 public키를 가지고 있지 않기 때문에 이렇게 뜨는 것이다. 우리가 만든 인증서는 브라우저가 모르는 인증서이기 때문에 보안 문구가 뜨게 되는 것이다. (이젠 다음으로 넘어가는 것도 안되는 듯….) Curl 명령1curl -I -k --http2 https://localhost:8080/hello Get 요청해보기1curl -k -X GET --http2 https://localhost:8080/hello curl 명령어를 이용해 터미널 환경에서도 반환 값을 확인 할 수 있다. 결과1234HTTP/1.1 200Content-Type: text/plain;charset=UTF-8Content-Length: 12Date: Sun, 15 Mar 2020 16:50:14 GMT -I에 대한 요청 정보로 해더를 보여준다. 1Hello Spring Get요청에 대한 결과로 Hello Spring이 반환되었다. 커넥터 생성하기https를 사용하게 되면 더 이상 http를 사용할 수 없게 된다. HTTP 커넥터가 한개인데, 그 커넥터에 ssl을 적용함으로써 HTTPS로 사용하고 있기 때문이다. 만약 HTTP도 사용하고 싶으면 또 하나의 커넥터를 만들어 주어야 한다. Application.java에 내용 추가 1234567891011121314......@Beanpublic ServletWebServerFactory serverFactory()&#123; TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory(); tomcat.addAdditionalTomcatConnectors(createStandardConnector()); return tomcat;&#125;private Connector createStandardConnector()&#123; Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;); connector.setPort(8080); return connector;&#125; application.properties에 내용 추가 123......server.port&#x3D;8443 HTTP연결의 경우 8080포트를 사용하게 되고, HTTPS연결의 경우는 8443포트를 사용하게 된다. HTTP2 활성화 하기 application.properties에 내용 추가 12...server.http2.enabled&#x3D;true application.properties에 http2사용에 대한 설정을 추가해주고 각 servlet 컨테이너 마다 다른 설정을 해주어야 한다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring Boot - 내장 웹 서버 응용 1부(컨테이너와 포트)","slug":"springboot/spring-framework/springboot-webserver2","date":"2021-02-18T15:58:27.000Z","updated":"2021-03-13T11:38:39.585Z","comments":true,"path":"2021/02/19/springboot/spring-framework/springboot-webserver2/","link":"","permalink":"https://ckck803.github.io/2021/02/19/springboot/spring-framework/springboot-webserver2/","excerpt":"","text":"내장 웹 서버 응용 1부 : 컨테이너와 포트https://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-web-servers.html에 다른 서블릿 컨테이너를 사용하는 방법이 적혀져 있다. tomcat 빼기 일단, spring-boot-starter-web에 적재되어 있는 tomcat을 뺄 필요가 있다. 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 톰켓을 뺀 후 아무것도 추가하지 않으면 웹 어플리케이션으로 작동하지 않고 어플리케이션으로 작동하기 때문에 그냥 종료된다. 다른 컨테이너 추가하기Jetty1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 새로운 서블릿 컨테이너로 jetty를 추가해 주었다. tomcat은 빠지고 jetty가 추가된 것을 볼 수 있다. 결과1Jetty started on port(s) 8080 (http/1.1) with context path &#x27;/&#x27; 스프링 부트를 실행해 보면 Jetty가 실행된 것을 볼 수 있다. undertow1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt; 다른 서블릿 컨테이너로 undertow를 추가해봤다. properties를 사용하는 방법웹 어플리케이션 타입 끄기 application.properties 1spring.main.web-application-type&#x3D;none spring.main.web-application-type에 none을 주게 되면 의존성이 있다고 해도 none web-application으로 작동을 하고 실행하고 바로 끝내게 된다. 1234567891011121314 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.5.RELEASE)2020-03-15 23:58:13.136 INFO 80825 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 80825 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_7/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_7/springbootgettingstarted)2020-03-15 23:58:13.139 INFO 80825 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 23:58:13.724 INFO 80825 --- [ main] com.example.Application : Started Application in 0.919 seconds (JVM running for 1.529)Process finished with exit code 0 바로 종료가 됨을 확인할 수 있다. 포트 변경 하기 application.properties 1server.port&#x3D;7070 7070포트로 변경하였다. 결과1Undertow started on port(s) 7070 (http) with context path &#39;&#39; 8080(기본)포트에서 7070포트로 바뀐 것을 확인할 수 있따. 랜덤 포트1server.port&#x3D;0 포트번호로 0을 주게 되면 비어있는 포트를 선택해서 만들어준다. 실시간으로 포트정보 알아보기1234567891011@Componentpublic class PortListener implements ApplicationListener&lt;ServletWebServerInitializedEvent&gt; &#123; @Override public void onApplicationEvent(ServletWebServerInitializedEvent event) &#123; // getApplicationContext()메소드를 이용하여 ApplicationContext를 얻는다. // ApplicationContext는 servlet ApplicationContext이기 때문 웹 서버를 알 수 있다. ServletWebServerApplicationContext applicationContext = event.getApplicationContext(); // 얻어진 웹서버를 통해 포트를 알아낼 수 있다. System.out.println(applicationContext.getWebServer().getPort()); &#125;&#125; ApplicationListner&lt;ServletWebServerInitializedEvent&gt;인터페이스를 구현함으로써 포트번호를 알아 낼 수 있다.ApplicationListner&lt;ServletWebServerInitializedEvent&gt;를 구현한 PortListener는 웹서버가 초기화가 되면 호출 된다. 이벤트 발생시 얻어진 ServletWebServerInitializedEvent인스턴스에 getApplicationContext()메소드를 이용하여 ApplicationContext객체를 얻어낼 수 있다. 얻어진 ApplicationContext객체는 servlet ApplicationContext 객체이므로 웹 서버를 알 수 있고 얻어진 웹 서버를 통해 포트를 알아낼 수 있다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring Boot - 내장 웹 서버 이해","slug":"springboot/spring-framework/springboot-webserver","date":"2021-02-18T15:56:18.000Z","updated":"2021-03-13T11:38:35.022Z","comments":true,"path":"2021/02/19/springboot/spring-framework/springboot-webserver/","link":"","permalink":"https://ckck803.github.io/2021/02/19/springboot/spring-framework/springboot-webserver/","excerpt":"","text":"내장 웹 서버 이해내장 서버를 스프링 부트 없이 만들어 보기 springbootgetttingstarted 1234567891011121314151617181920212223242526272829303132333435public class Application &#123; public static void main(String[] args) throws LifecycleException &#123; // 톰캣 만들기 Tomcat tomcat = new Tomcat(); tomcat.setPort(8888); Context context = tomcat.addContext(&quot;/&quot;, &quot;/&quot;); // servlet 만들기 HttpServlet servlet = new HttpServlet()&#123; @Override // get요청에 관한 메소드 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // response 객체의 writer객체를 반환받아 // 응답으로 전해줄 servlet을 작성해준다. PrintWriter writer = resp.getWriter(); writer.println(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;); writer.println(&quot;Hey, Tomcat&quot;); writer.println(&quot;&lt;/title&gt;&lt;/head&gt;&quot;); writer.println(&quot;&lt;body&gt;&lt;h1&gt;Hello Tomcat&lt;/h1&gt;&lt;/body&gt;&quot;); writer.println(&quot;&lt;/html&gt;&quot;); &#125; &#125;; String servletName = &quot;helloServlet&quot;; // 톰켓에 서블릿을 추가해준 후 tomcat.addServlet(&quot;/&quot;, servletName, servlet); // /hello url과 해당 서블릿을 매핑 시켜준다. context.addServletMappingDecoded(&quot;/hello&quot;, servletName); tomcat.getConnector(); tomcat.start(); tomcat.getServer().await(); &#125;&#125; tomcat9부터는 tomcat.start()를 하기 전에 tomcat.getConnector()를 해야 실행이 된다. tomcat 객체를 생성 servlet 객체를 생성했다. 결과 스프링 부트에서는 위와 같은 설정을 AutoConfiguration에서 자동으로 잡아준다. spring-boot-autoconfigure/spring.factories ServletWebServerFactoryAutoConfiguration는 서블릿 웹 서버를 설정해주는 자동 설정이다.TomcatServletWebServerFactoryCustomizer을 통해 톰켓을 커스터 마이징 한다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring Boot - 자동 설정 만들기 1부","slug":"springboot/spring-framework/springboot-cutome-autoconfigure2","date":"2021-02-18T15:52:54.000Z","updated":"2021-03-13T11:38:17.553Z","comments":true,"path":"2021/02/19/springboot/spring-framework/springboot-cutome-autoconfigure2/","link":"","permalink":"https://ckck803.github.io/2021/02/19/springboot/spring-framework/springboot-cutome-autoconfigure2/","excerpt":"","text":"자동 설정 만들기 2부EnableAutoConfiguration이 불러오는 같은 Bean 무시하기 maplespringbootstarter 프로젝트 12345678910111213@Configurationpublic class HolomanConfiguration &#123; @Bean @ConditionalOnMissingBean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setHowLong(5); holoman.setName(&quot;maple&quot;); return holoman; &#125;&#125; @ConditionalOnMissingBean을 사용하면 해당 Bean이 없는 경우에만 EnableAutoConfiguration을 통해 Bean이 추가 된다. 결과1234562020-03-15 21:31:49.936 INFO 67228 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 67228 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted)2020-03-15 21:31:49.938 INFO 67228 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 21:31:50.581 INFO 67228 --- [ main] com.example.Application : Started Application in 0.937 seconds (JVM running for 1.598)Holoman&#123;name=&#x27;동장군&#x27;, howLong=60&#125;Process finished with exit code 0 springbootgetttingstarted프로젝트의 Bean이 출력됨을 확인할 수 있다. application.properties를 이용한 방법 springbootgetttingstarted 프로젝트 src/resource에 application.properties파일을 생성 12holoman.name &#x3D; 아 집에 가고 싶다.holoman.how-long &#x3D; 10000 application.propertie에 해당 내용을 추가 의존성 추가 maplespringbootstarter 프로젝트 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @ConfigurationProperties를 사용하기 위해서는 해당 의존성을 추가해주어야 한다. HolomanProperties maplespringbootstarter 프로젝트 123456789101112131415161718192021@ConfigurationProperties(&quot;holoman&quot;)public class HolomanProperties &#123; private String name; private int howLong; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHowLong() &#123; return howLong; &#125; public void setHowLong(int howLong) &#123; this.howLong = howLong; &#125;&#125; HolomanConfiguration 수정 maplespringbootstarter 프로젝트 1234567891011121314@Configuration@EnableConfigurationProperties(HolomanProperties.class)public class HolomanConfiguration &#123; @Bean @ConditionalOnMissingBean public Holoman holoman(HolomanProperties properties)&#123; Holoman holoman = new Holoman(); holoman.setHowLong(properties.getHowLong()); holoman.setName(properties.getName()); return holoman; &#125;&#125; @EnableConfigurationProperties를 추가Bean을 만들 때 HolomanProperties를 참조해서 Bean을 생성한다.springbootgetttingstarted의 application.properties를 가져다가 Bean을 생성한다. springbootgetttingstarted내의 holoman Bean을 없애주어야 한다…. 오류 잡느라 시간 오래 걸렸다. 결과1234562020-03-15 22:07:53.804 INFO 70087 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 70087 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_5/springbootgettingstarted)2020-03-15 22:07:53.808 INFO 70087 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 22:07:54.628 INFO 70087 --- [ main] com.example.Application : Started Application in 1.148 seconds (JVM running for 1.631)Holoman&#123;name=&#x27;A... I want to go home&#x27;, howLong=10000&#125;Process finished with exit code 0","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring Boot - 자동 설정 만들기 1부","slug":"springboot/spring-framework/springboot-cutome-autoconfigure","date":"2021-02-18T15:45:34.000Z","updated":"2021-03-13T11:38:12.648Z","comments":true,"path":"2021/02/19/springboot/spring-framework/springboot-cutome-autoconfigure/","link":"","permalink":"https://ckck803.github.io/2021/02/19/springboot/spring-framework/springboot-cutome-autoconfigure/","excerpt":"","text":"자동 설정 만들기 1부 Xxx-Spring-Boot-Autoconfigure 모듈: 자동 설정 Xxx-Spring-Boot-Starter 모듈: 필요한 의존성 정의 그냥 하나로 만들고 싶을 때는?Xxx-Spring-Boot-Starter spring-boot-starter 만들기 프로젝트 명 : maplespringbootstarter ArtifactId : maple-spring-boot-starter 의존성 추가 maplespringbootstarter 프로젝트 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Holoman.java maplespringbootstarter 프로젝트 12345678910111213141516171819202122232425262728293031package com.example;public class Holoman &#123; String name; int howLong; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHowLong() &#123; return howLong; &#125; public void setHowLong(int howLong) &#123; this.howLong = howLong; &#125; @Override public String toString() &#123; return &quot;Holoman&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, howLong=&quot; + howLong + &#x27;&#125;&#x27;; &#125;&#125; HolomanConfiguration maplespringbootstarter 프로젝트 123456789101112@Configurationpublic class HolomanConfiguration &#123; @Bean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setHowLong(5); holoman.setName(&quot;maple&quot;); return holoman; &#125;&#125; Holoman 인스턴스를 반환하는 설정 파일을 만들었다. 자동 설정 파일 추가 src/main/resource/위치에 META-INF폴더를 생성한다. 12org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\ com.example.HolomanConfiguration META-INF폴더에 spring.factories파일을 생성한 후 위 내용을 추가해준다.해당 프로젝트를 의존성에 추가한 프로젝트는 EnableAutoConfiguration이 HolomanConfiguration을 scan하여 configuration의 Bean을 추가해 준다. mvn install install을 더블클릭하거나콘솔에가서 mvn install명령어를 실행하면 된다. 1mvn install 프로젝트가 빌드되고 jar파일이 생성된다. 다른 maven 프로젝트에서 가져다 쓸 수 있도록 local maven저장소에 설치를 한다. 의존성 추가 springbootgetttingstarted 프로젝트를 새로 생성 123&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;maple-spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; pom.xml에 dependency를 추가한다. maple-spring-boot-starter가 추가 된 것을 확인할 수 있다. HolomanRunner.java springbootgettingstarted 프로젝트 123456789101112@Componentpublic class HolomanRunner implements ApplicationRunner &#123; // maple-spring-boot-starter에서 Holoman Bean을 가져와 의존성을 주입해준다. @Autowired Holoman holoman; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(holoman); &#125;&#125; Holoman Bean이 추가된 것을 확인하기 위한 코드해당 프로젝트에는 Holoman에 관한 Configuration이 없는 상태이므로 Holoman Bean이 추가되었는지 해당 코드를 통해 확인 할 수 있다. 결과1234567891011121314 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.5.RELEASE)2020-03-15 20:29:06.744 INFO 53354 --- [ main] com.example.Application : Starting Application on yangdong-uui-MacBookPro.local with PID 53354 (/Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_4/springbootgettingstarted/target/classes started by dongwoo-yang in /Users/dongwoo-yang/dev/study/spring/everyday_spring/chapter3/ch3_4/springbootgettingstarted)2020-03-15 20:29:06.749 INFO 53354 --- [ main] com.example.Application : No active profile set, falling back to default profiles: default2020-03-15 20:29:07.495 INFO 53354 --- [ main] com.example.Application : Started Application in 1.395 seconds (JVM running for 2.439)Holoman&#123;name=&#x27;maple&#x27;, howLong=5&#125;Process finished with exit code 0 Holoman&#123;name=&#39;maple&#39;, howLong=5&#125;을 통해 정상적으로 작동함을 알 수 있다. 만약 프로젝트에 같은 같은 Bean이 있는 경우 springbootgettingstarted 프로젝트 12345678910111213141516@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication springApplication = new SpringApplication(Application.class); springApplication.setWebApplicationType(WebApplicationType.NONE); springApplication.run(args); &#125; @Bean public Holoman holoman()&#123; Holoman holoman = new Holoman(); holoman.setName(&quot;동장군&quot;); holoman.setHowLong(60); return holoman; &#125;&#125; 해당 프로젝트의 Bean이 무시가 된다. ComponentScan을 통해 먼저 Bean이 등록이 되고 EnableAutoConfiguration을 통해 Bean이 등록이 될때 해당 Bean을 덮어쓰게 된다. 다른 결과123456789101112131415***************************APPLICATION FAILED TO START***************************Description:The bean &#x27;holoman&#x27;, defined in class path resource [com/example/HolomanConfiguration.class], could not be registered. A bean with that name has already been defined in com.example.Application and overriding is disabled.Action:Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=trueProcess finished with exit code 1 스프링 부트 2.2로 올라가면서 Bean 오버라이딩이 막혀서 에러 메시지가 뜨게 된다. 만약 Bean 오버라이딩을 하려고 하면 spring.main.allow-bean-definition-overriding=true 설정을 추가하면 Bean 오버라이딩이 가능해 진다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring MVC Request Life Cycle","slug":"springboot/spring-framework/spring-mvc-request-lifecycle","date":"2021-02-18T13:39:59.000Z","updated":"2021-03-13T11:38:04.097Z","comments":true,"path":"2021/02/18/springboot/spring-framework/spring-mvc-request-lifecycle/","link":"","permalink":"https://ckck803.github.io/2021/02/18/springboot/spring-framework/spring-mvc-request-lifecycle/","excerpt":"","text":"스프링 MVC Request Life CycleFilterFilter는 Spring Context 이전에 실행되기 때문에 Spring자체와는 무관하며 Web Application에 등록이 된다.요청이 DispatcherServlet에 도착하기 전에 처리를 하거나 요청이 끝나고 응답할 때 마지막으로 처리를 하는 역할을 한다.주로 인코딩, 요청에 대한 인증, 권한 체크를 하는데 많이 사용된다. Filter의 실행 메소드init() : 필터 인스턴스 초기화doFilter() : 실제 로직 처리(Filter Chain을 따라 다을 Filter로 움직인다.)destroy() : 필터 인스턴스 종료 web.xml 123456789101112131415161718&lt;!-- 파라미터 인코딩 필터 설정 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Filter ChainFilter는 Client와 Servlet사이에 존재해 Client가 보내는 요청정보를 가공해 Servlet으로 보내고 Servelt이 보내는 응답정보를 가공해 Client에게 전달하는 역할을 한다. Filter는 일반적인 경우 1개가 존재하지만 여러개의 필터를 모아 Filter Chain을 형성할 수 있다. 또한, Spring Security의 Filter를 보게 되면 Filter자체가 사용자의 요청에 대한 응답을 할 수 있다. DispatcherServlet사용자의 요청을 제일 먼저 받는 Front-Controller HandlerMappingHandlerInterceptorControllerServiceRepositoryViewResolver","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"},{"name":"MVC","slug":"MVC","permalink":"https://ckck803.github.io/tags/MVC/"}]},{"title":"Spring Boot - 자동 설정 이해","slug":"springboot/spring-framework/springboot-autoconfiguration","date":"2021-02-17T23:09:05.000Z","updated":"2021-03-13T11:38:07.827Z","comments":true,"path":"2021/02/18/springboot/spring-framework/springboot-autoconfiguration/","link":"","permalink":"https://ckck803.github.io/2021/02/18/springboot/spring-framework/springboot-autoconfiguration/","excerpt":"","text":"Spring Boot - 자동 설정 이해@SpringBootApplication은 크게 3가지 어노테이션으로 이루어져 있다. @SpringBootConfiguration @ComponentScan @EnableAutoConfiguration @SpringBootConfiguration은 기존의 Configuration과 비슷하다.@ComponentScan에서 1차적으로 @Bean을 읽어들인 후 @EnableAutoConfiguration에서 2차적으로 @Bean을 읽어들인다. 즉 springboot는 Bean을 두번 등록하는 작업을 거친다. EnableAutoConfiguration스프링부트에서 EnableAutoConfiguration이 없어도 작동은 하지만 문제가 생긴다. 123456789@SpringBootConfiguration@ComponentScan//@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 오류코드 Caused by: org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean. 스프링부트는 코드를 웹 어플리케이션 형태로 제작하는데, 웹 어플리케이션으로 만드는 과정에서 EnableAutoConfiguration에서 읽어들어들이는 ServletWebServerFactory bean을 사용하기 때문에 문제가 생기게 된다. SpringApplication.run()을 바로 사용하게 되면 웹 어플리케이션 형태로 작동을 한다.EnableAutoConfiguration없이는 웹 어플리케이션으로 만드는 것이 불가능 하므로바로 사용할 수 없다. 웹 어플리케이션 설정 꺼주기12345678910111213141516@SpringBootConfiguration@ComponentScan//@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; // SpringApplication.run(Application.class, args); // SpringApplication 인스턴스를 생성하면 커스터마이징 해서 사용이 가능하다. SpringApplication application = new SpringApplication(Application.class); // webApplication만드는 설정을 꺼준다. application.setWebApplicationType(WebApplicationType.NONE); application.run(args); &#125;&#125; SpringApplication 인스턴스를 생성한 후에 setWebApplicationType()메소드를 이용하여 WebApplicationType.NONE인자 값을 넘겨주면 webApplication으로 만들어 주는 설정을 끌 수 있다. 작동은 가능하나 웹 어플리케이션으로 작동하지는 않는다. @ComponentScan @ComponentScan은 Application.class에 있다. 위 그림에서는 a와 b 패키지의 경우는 ComponentScan의 대상이 되나 maple 패키지의 경우 ComponentScan의 대상이 되지 않는다. @ComponentScan에서 Scan하는 것들 @Component @Configuration @Repository @Service @Controller @RestController 위 어노테이션을 가진 class들을 scan하여 Bean으로 등록을 한다.@ComponentScan을 가진 class부터 시작하여 하위 package들을 scan해 위 어노테이션이 달려 있는 것들을 Bean으로 등록한다.scan을 할 때는 TypeExcludeFilter.class와 AutoConfigurationExcludeFilter.class들을 제외하여 scan한다. @EnableAutoConfiguration EnableAutoConfiguration은 springboot의 META file을 읽어 들인다. @ConditionalOnXxxYyyZzz @ConditionalOnWebApplication(type = Type.SERVLET) 웹 어플리케이션 타입에 따라 설정을 다르게 한다. @ConditionalOnMissingBean(HiddenHttpMethodFilter.class) 해당 Bean이 없으면 다른 것을 등록 한다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring Boot의 의존성","slug":"springboot/spring-framework/springboot-dependency","date":"2021-02-17T23:03:58.000Z","updated":"2021-03-13T11:38:21.018Z","comments":true,"path":"2021/02/18/springboot/spring-framework/springboot-dependency/","link":"","permalink":"https://ckck803.github.io/2021/02/18/springboot/spring-framework/springboot-dependency/","excerpt":"","text":"Spring Boot의 의존성pom.xml파일에 의존성 추가1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 스프링이 제공하는 의존성 관리 기능 덕분에의존성 정의시 version을 따로 명시하지 않아도 적절한 version을 가져온다. 의존성 상속 관계spring-boot-starter-parent123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; spring-boot-dependencies123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;...&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;... spring-boot-starter-parent -&gt; spring-boot-dependencies로 가게 되면dependencyManagement태그를 통해 스프링 부트에서 관리하는 의존성과 version들을 확인할 수 있다. spring-boot-dependencies라는 pom안에 정의 되어 있는 것들 중에 하나라도 쓰게 된다면직접 version을 명시하지 않아도 된다. dependencyManagement 기능이 있어서 수 많은 Library들이 들어오게 된다.따라서, 우리가 관리해야 할 의존성의 수가 줄어든다. dependency 확인 Maven Projects Tab에서 dependency들을 쉽게 볼 수 있다. 의존성 추가starter 위주로 의존성을 추가하며 된다.만약 pom에서 지원하지 않는 의존성 추가시 version까지 명시해 주어야 한다.springboot dependency에서 관리하는 의존성은 굳이 version을 명시하지 않아도 되나 특별히 원하는 version이 있으면 version을 명시해 주면 override(덮어쓰기)가 된다. springboot 의존성 관리&lt;parent&gt;를 통해서 의존성을 관리해준다. 만약, 해당 프로젝트에서 parent.pom을 사용하지 않을 경우 project가 상속하는 parent에 spring-boot-starter-parent를 상속하는 방법 &lt;dependencyManagement&gt;색션을 사용하는 방법 &lt;dependecyManagement&gt;를 사용하게 되면 문제점이 생기는데,spring-boot-starter-parent가 단순히 의존성만을 가져오는 것이 아닌 여러가지 설정들을 함께 가져 오기 때문이다. ex) 자바 버전, 문자 인코딩 방식, resource(스프링 부트가 사용하는 properties와 yaml파일들)과 spring-boot를 최정화 시켜주는 여러가지 설정들","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"}],"tags":[{"name":"IoC 컨테이너","slug":"IoC-컨테이너","permalink":"https://ckck803.github.io/tags/IoC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"}]},{"title":"Spring-JWT(JSON Web Token) - 1. JWT 알아보기","slug":"springboot/security/JWT/spring-jwt-1","date":"2021-02-17T03:41:39.000Z","updated":"2021-03-14T13:11:54.215Z","comments":true,"path":"2021/02/17/springboot/security/JWT/spring-jwt-1/","link":"","permalink":"https://ckck803.github.io/2021/02/17/springboot/security/JWT/spring-jwt-1/","excerpt":"","text":"1. JWT(JSON Web Token) 알아보기JWT 란?JWT는 JSON Web Token의 약자로 사용자 정보와 데이터 속성과 같은 Claim 정보를 JSON객체를 이용해 표현한 Web Token.JWT는 Token내에 필요한 모든 정보를 가지고 전달해주는 자가수용적인 특징을 가지고 있다 JWT는 Header, Payload, Signature 세가지로 구성돼 있다. 각 값들은 base64로 인코딩 돼 .로 나뉘어 구분된다. Header토큰 타입과 해시 알고리즘에 대한 정보가 담겨 있다. alg Signature에서 사용하는 암호 알고리즘에 대한 정보가 담겨 있다. 보통은 HMACSHA256(Hash-Based Message Authentication Code) 알고리즘을 사용하거나 공개키/개인키 방식인 RSA 암호화 방식도 사용한다 typ 토큰 타입을 지정한다. JWT(JSON Web Token) PayloadClaim 정보를 담고 있다. Payload에 담기는 key-value 한쌍이 Claim이다. Claim은 크게 3가지로 구분이 된다. Registered Claim Public Claim Private Claim Registered Claim토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터이며, 선택적으로 작성이 가능하다. iss : issuer 토큰 발급자 sub : subject 토큰의 제목 aud : audience 토큰 대상자 exp : expiration 토큰 만료 시간 NumericDate 형식으로 작성 nbf : not before 토큰 활성 날짜 : 이 날이 지나기 전까지 토큰이 활성화 되지 않는다. iat : issued at 토큰 발급 시간 : 토큰 발급 이후의 경과 시간을 알 수 있다. jti : JWT ID JWT 토큰 식별자 Public ClaimPublic Claim은 사용자 정의 Claim으로, 보통 공개용 정보를 표현하기 위해 사용한다. 보통은 충돌 방지를 위해 URI 포맷을 이용해야 한다. Private ClaimPublic Claim이 아니면서 서버와 클라이언트 사이에서 임의로 정한 정보를 저장하기 위해 만들어진 Claim SignatureJWT의 장점JWT의 단점","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"JWT","slug":"Spring-Boot/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/JWT/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"JWT","slug":"JWT","permalink":"https://ckck803.github.io/tags/JWT/"}]},{"title":"Spring Core - Bean","slug":"springboot/Spring-Core/Bean","date":"2021-02-16T15:36:23.000Z","updated":"2021-03-13T11:33:51.148Z","comments":true,"path":"2021/02/17/springboot/Spring-Core/Bean/","link":"","permalink":"https://ckck803.github.io/2021/02/17/springboot/Spring-Core/Bean/","excerpt":"","text":"Bean이란!스프링 IOC 컨테이너가 관리하는 객체를 Bean이라 한다. 스프링 컨테이너에 Bean으로 등록하는 방법 Component Scan을 이용하는 방법 Component 어노테이션이 붙어있는 클래스를 찾아서 Bean으로 등록해준다. Repository Service Controller XML에 직접 등록하는 방법 @Bean을 이용하여 직접적으로 등록을 하면 된다. Bean 어노테이션으로 정의할 때는 Configuration 어노테이션을 가지고 있는 클래스 안에 정의해야 한다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"}],"tags":[{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"}]},{"title":"Spring Core - IoC 컨테이너","slug":"springboot/Spring-Core/IoC-container","date":"2021-02-16T15:14:19.000Z","updated":"2021-03-13T11:33:46.812Z","comments":true,"path":"2021/02/17/springboot/Spring-Core/IoC-container/","link":"","permalink":"https://ckck803.github.io/2021/02/17/springboot/Spring-Core/IoC-container/","excerpt":"","text":"IoC(Inversion of Control) 컨테이너Ioc(Inversion of Control) 한국말로는 제어의 역전이다. 여기서 말하는 제어는 무엇일까?일단 제어의 의미부터 알아보면! 프로그램의 흐름, 객체의 생성, 객체간의 의존성 등을 의미하는데 이런 것들은 보통 프로그래머들이 관리를 하던 요소들이다. 그런데 IoC 컨테이너의 등장으로 이런 것들을 프로그래머가 직접 관리하는 것들을 컨테이너가 대신 해주게 됐다. 이것을 보고 우리는 IoC(제어의 역전) 이라한다. 스프링은 ApplicationContext or BeanFactory라는 IOC 컨테이너 인터페이스를 제공한다. IOC 컨테이너를 직접 쓸 일이 거의 없다. 코드를 통해 알아보기생성자를 통한 의존성 주입 123456789class OwnerController &#123; private OwnerRepository repo; @Autowired public OwnerController(OwnerRepository repo) &#123; this.repo = repo; &#125;// repo를 사용합니다. &#125; IOC컨테이너는 위의 코드를 동작하게 만들어준다.위 코드를 보면 OwnerController는 OwnerRepository 객체를 사용한다. 이것을 OwnerController클래스는 OwnerRepository클래스에 의존한다.라고 말한다. 여기서의 관권은 누가 OwnerRepository를 만드냐? 관리하냐?이다. 바로 IoC 컨테이너 가 OwnerRepository 객체를 생성하고 주입해준다. OwnerController가 IOC컨테이너 내부에 객체로 들어오게 되고 IOC컨테이너 내부에서 OwnerController의 객체를 만들어준다. OwnerRepository 타입의 객체도 만들어준다. IOC컨테이너는 이런 Bean들의 의존성을 관리해준다. Bean : 컨테이너 내부에 만든 객체들 의존성 주입@Autowired와 @Inject를 이용해서 의존성을 주입해준다. @Autowired가 없더라도, Bean에 생성자가 하나만 있고 그 생성자의 parameter로 받는 타입의 Bean이 존재한다면 해당 Bean(parameter)은 주입을 해준다. @Autowired와 @Inject를 붙일 수 있는 위치 생성자 필드 Setter","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"}],"tags":[{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"},{"name":"IoC 컨테이너","slug":"IoC-컨테이너","permalink":"https://ckck803.github.io/tags/IoC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/"}]},{"title":"백준 - 14499 주사위 굴리기","slug":"algorithm/baekjoon/시뮬레이션/14499","date":"2021-02-15T22:51:54.000Z","updated":"2021-03-19T17:11:41.187Z","comments":true,"path":"2021/02/16/algorithm/baekjoon/시뮬레이션/14499/","link":"","permalink":"https://ckck803.github.io/2021/02/16/algorithm/baekjoon/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/14499/","excerpt":"","text":"https://www.acmicpc.net/problem/14499 체점 현황 문제 해설문제를 입력받는 곳에서 함정이 있다. 평소에 세로를 y, 가로를 x로 놓고 문제를 해결하는 사람들에게는 틀리기 너무 좋은 문제주사위의 현재 위치를 계속 추적하면서 주사위 상태도 계속해서 관리해야 한다. 위치를 쉽게 관리하기 위해서 전역변수를 통해 전역적으로 관리했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, x, y, k;int map[22][22];int cube[4][3];vector&lt;int&gt; command;void moveUp() &#123; if (x - 1 &gt;= 0) &#123; x -= 1; int temp01, temp11, temp21, temp31; temp01 = cube[0][1]; temp11 = cube[1][1]; temp21 = cube[2][1]; temp31 = cube[3][1]; cube[0][1] = temp11; cube[1][1] = temp21; cube[2][1] = temp31; cube[3][1] = temp01; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveDown() &#123; if (x + 1 &lt; n) &#123; x += 1; int temp01, temp11, temp21, temp31; temp01 = cube[0][1]; temp11 = cube[1][1]; temp21 = cube[2][1]; temp31 = cube[3][1]; cube[1][1] = temp01; cube[2][1] = temp11; cube[3][1] = temp21; cube[0][1] = temp31; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveRight() &#123; if (y + 1 &lt; m) &#123; y += 1; int temp11, temp12, temp31, temp10; temp11 = cube[1][1]; temp12 = cube[1][2]; temp31 = cube[3][1]; temp10 = cube[1][0]; cube[1][1] = temp10; cube[1][2] = temp11; cube[3][1] = temp12; cube[1][0] = temp31; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveLeft() &#123; if (y - 1 &gt;= 0) &#123; y -= 1; int temp11, temp12, temp31, temp10; temp11 = cube[1][1]; temp12 = cube[1][2]; temp31 = cube[3][1]; temp10 = cube[1][0]; cube[1][0] = temp11; cube[1][1] = temp12; cube[1][2] = temp31; cube[3][1] = temp10; int next = map[x][y]; if (next == 0) &#123; map[x][y] = cube[3][1]; &#125; else &#123; cube[3][1] = map[x][y]; map[x][y] = 0; &#125; cout &lt;&lt; cube[1][1] &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; return; &#125;&#125;void moveCube() &#123; int commandNum = command.size(); for (int i = 0; i &lt; commandNum; i++) &#123; int cntCommand = command[i]; if (cntCommand == 1) &#123; moveRight(); &#125; if (cntCommand == 2) &#123; moveLeft(); &#125; if (cntCommand == 3) &#123; moveUp(); &#125; if (cntCommand == 4) &#123; moveDown(); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; &#125; map[x][y] = 0; for (int i = 0; i &lt; k; i++) &#123; int temp = 0; cin &gt;&gt; temp; command.push_back(temp); &#125; moveCube(); return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://ckck803.github.io/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://ckck803.github.io/tags/%EC%82%BC%EC%84%B1-%EA%B8%B0%EC%B6%9C/"}]},{"title":"백준 3190 - 뱀","slug":"algorithm/baekjoon/BFS/3190","date":"2021-02-15T22:44:52.000Z","updated":"2021-03-19T17:10:41.249Z","comments":true,"path":"2021/02/16/algorithm/baekjoon/BFS/3190/","link":"","permalink":"https://ckck803.github.io/2021/02/16/algorithm/baekjoon/BFS/3190/","excerpt":"","text":"https://www.acmicpc.net/problem/3190 체점 현황 전체 소스 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;int board[110][110];int board_size;int num_of_apple;int num_of_command;map&lt;int, char&gt; command;// 동, 남, 서, 북int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;int direction[4] = &#123;0, 1, 2, 3&#125;;struct snake &#123; int y; int x; int dir;&#125;;int main(void) &#123; cin &gt;&gt; board_size &gt;&gt; num_of_apple; for (int i = 0; i &lt; num_of_apple; i++) &#123; int y, x; cin &gt;&gt; y &gt;&gt; x; board[y][x] = 1; &#125; cin &gt;&gt; num_of_command; for (int i = 0; i &lt; num_of_command; i++) &#123; int time; char dir; cin &gt;&gt; time &gt;&gt; dir; command[time] = dir; &#125; queue&lt;pair&lt;int, int&gt;&gt; snake_tail; int snake_head_y = 1; int snake_haed_x = 1; int snake_dir = 0; snake_tail.push(&#123;1, 1&#125;); board[1][1] = 2; int time = 0; while (true) &#123; time++; snake_head_y += dy[snake_dir]; snake_haed_x += dx[snake_dir]; snake_tail.push(&#123;snake_head_y, snake_haed_x&#125;); if (board[snake_head_y][snake_haed_x] == 2) &#123; cout &lt;&lt; time &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; if (0 &gt;= snake_head_y || snake_head_y &gt; board_size || 0 &gt;= snake_haed_x || snake_haed_x &gt; board_size) &#123; cout &lt;&lt; time &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; if (board[snake_head_y][snake_haed_x] == 1) &#123; board[snake_head_y][snake_haed_x] = 2; &#125; else &#123; board[snake_head_y][snake_haed_x] = 2; board[snake_tail.front().first][snake_tail.front().second] = 0; snake_tail.pop(); &#125; if (command.find(time) != command.end()) &#123; char com = command[time]; command.erase(time); if (com == &#x27;L&#x27;) &#123; snake_dir = (snake_dir + 3) % 4; &#125; else &#123; snake_dir = (snake_dir + 1) % 4; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://ckck803.github.io/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://ckck803.github.io/tags/%EC%82%BC%EC%84%B1-%EA%B8%B0%EC%B6%9C/"}]},{"title":"JPA - Entity의 생명주기","slug":"JPA/persistence","date":"2021-02-15T15:14:03.000Z","updated":"2021-03-19T17:22:30.515Z","comments":true,"path":"2021/02/16/JPA/persistence/","link":"","permalink":"https://ckck803.github.io/2021/02/16/JPA/persistence/","excerpt":"","text":"JPA - Entity의 생명주기Entity 생명주기 비영속 영속 준영속 삭제 비영속JPA와 전혀 관계가 없는 상태(객체만 생성)엔티티 객체를 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태 123Member member = new Member(); member.setId(100L); member.setName(&quot;HelloJPA&quot;); 영속 Entity Manager에 Entity를 저장한 상태 영속상태가 된다고 해서 바로 Database에 query가 날라가는 것이 아니다. transction을 commit하게 되면 DB에 query가 날라가게 된다. persist : 영속성 context에 저장 detech : 영속성 context에서 지움 영속성 context application과 database 사이에서 Cache처럼 객체를 보관하는 중간 계층이 존재한다.Entity를 영구적으로 저장하는 환경 영속성 Context는 내부에 1차 cache가 존재하고 (key, value) 형태로 데이터를 관리한다.장점 : buffering이나 Caching을 할 수 있다. @Id Entity Member1 member @Id : Key Entity : 객체 1차 캐시에서 조회123456789101112131415161718192021222324252627public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member member = new Member(); member.setId(101L); member.setName(&quot;HelloJPA&quot;); em.persist(member); Member findMember = em.find(Member.class, 101L); System.out.println(&quot;findMember.id = &quot; + findMember.getId()); System.out.println(&quot;findMember.name = &quot; + findMember.getName()); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; 123findMember.id = 101 findMember.name = HelloJPA Hibernate: /* insert hellojpa.Member */ insert into Member (name, id) values (?, ?) 조회를 했지만 select 쿼리가 나가지 않는다. persist로 저장 시에는 1차 캐시에 데이터가 저장되기 때문이다. 조회를 할 때 DB를 조회 한 것이 아닌 우선적으로 1차 캐시를 조회해 값을 가져오기 때문에 DB에 select 쿼리가 나가지 않았던 것이다. 1차 캐시에 data가 없는 경우 DB에서 조회 1차 Cache에 데이터를 저장(있으면) 1234567891011121314151617181920public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member findMember1 = em.find(Member.class, 101L); // 첫번째 조회시에는 query가 나간다. Member findMember2 = em.find(Member.class, 101L); // 두번째 조회시에는 나가지 않는다. tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; 1234Hibernate: select member0_.id as id1_0_0_, member0_.name as name2_0_0_ from Member member0_ where member0_.id=? 쿼리가 한번만 나간다. 영속 엔티티의 동일성 보장1234Member findMember1 = em.find(Member.class, 101L); // 첫번째 조회시에는 query가 나간다.Member findMember2 = em.find(Member.class, 101L); // 두번째 조회시에는 나가지 않는다.System.out.println(&quot;result = &quot; + (findMember1 == findMember2)); // true가 나온다. 1result = true 트랜잭션을 지원하는 쓰기 지연12345678910111213141516171819202122232425public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member member1 = new Member(150L, &quot;A&quot;); Member member2 = new Member(160L, &quot;B&quot;); em.persist(member1); em.persist(member2); System.out.println(&quot;==========================&quot;); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; 1234567891011121314151617==========================Hibernate: /* insert hellojpa.Member */ insert into Member (name, id) values (?, ?)Hibernate: /* insert hellojpa.Member */ insert into Member (name, id) values (?, ?) commit()을 실행했을 때 query문이 날라가는 것을 확인할 수 있다. 엔티티 수정1234567891011121314151617181920212223public class JpaMain &#123; public static void main(String[] args) &#123; EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try &#123; Member member = em.find(Member.class, 150L); member.setName(&quot;ZZZZZ&quot;);// em.persist(member); persist를 사용할 필요가 없다. System.out.println(&quot;==========================&quot;); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; em.close(); &#125; emf.close(); &#125;&#125; 1234567891011121314151617Hibernate: select member0_.id as id1_0_0_, member0_.name as name2_0_0_ from Member member0_ where member0_.id=?==========================Hibernate: /* update hellojpa.Member */ update Member set name=? where id=? 준영속","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"JPA","slug":"Programming/JAVA/JPA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"백주 1753 - 최단 경로","slug":"algorithm/baekjoon/다익스트라/1753","date":"2021-02-15T15:13:22.000Z","updated":"2021-03-19T17:11:21.324Z","comments":true,"path":"2021/02/16/algorithm/baekjoon/다익스트라/1753/","link":"","permalink":"https://ckck803.github.io/2021/02/16/algorithm/baekjoon/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/1753/","excerpt":"","text":"https://www.acmicpc.net/problem/1753 문제 해설가장 기본적이고 정형화된 다익스트라 문제이다! 다익스트라 알고리즘에서는 우선순위 큐를 사용하는데 기본적으로 우선순위 큐는 값이 큰 것부터 우선적으로 나가게 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 987654321int V, E;int startPoint;int dist[20002]; // dist[x] : 시작점으로부터 점 x까지의 최단 거리를 저장한다.vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;void dijkstra(int start) &#123; // 초기값은 무한대로 설정해 놓는다. for (int i = 1; i &lt; V + 1; i++) &#123; dist[i] = INF; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; pq.push(&#123;0, start&#125;); dist[start] = 0; while (!pq.empty()) &#123; int cntDist = -pq.top().first; int cntVertex = pq.top().second; pq.pop(); // 현재 점까지의 거리와 저장된 최단거리를 비교한다. // 현재 점까지의 거리가 더 큰 경우는 나중에 최단거리가 갱신된 것이다. // 우리는 각 점에 최단거리로 간 상태에 대해서만 갱신을 진행하므로 밑의 연산은 진행하지 않는다. if (cntDist &gt; dist[cntVertex]) &#123; continue; &#125; // 아래 로직을 대신 사용해도 결과는 똑같이 나온다. // 즉 현재 점까지의 거리가 최단거리까지와 일치하는지 확인하는 단계이다. // if (cntDist != dist[cntVertex]) &#123; // continue; // &#125; for (int i = 0; i &lt; graph[cntVertex].size(); i++) &#123; int nextVertex = graph[cntVertex][i].first; int weight = graph[cntVertex][i].second; // cntDist 대신 dist[cntVertex]를 사용해도 결과는 동일하다 // int nextDist = dist[cntVertex] + weight; int nextDist = cntDist + weight; if (dist[nextVertex] &gt; nextDist) &#123; dist[nextVertex] = nextDist; // 값을 음수로 저장해 우선순위가 반대가 되도록 한다. pq.push(&#123;-nextDist, nextVertex&#125;); &#125; &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; V &gt;&gt; E; cin &gt;&gt; startPoint; graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(V + 1); for (int i = 0; i &lt; E; i++) &#123; int a, b, weight; cin &gt;&gt; a &gt;&gt; b &gt;&gt; weight; graph[a].push_back(&#123;b, weight&#125;); &#125; dijkstra(startPoint); for (int i = 1; i &lt;= V; i++) &#123; if (dist[i] == INF) &#123; cout &lt;&lt; &quot;INF&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; cout &lt;&lt; dist[i] &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; return 0;&#125; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; 우선순위 큐에 greater&lt;pair&lt;int, int&gt;&gt;&gt; pq 정렬 방식을 통해 값이 작은 것부터 우선적으로 나가게 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF 2000000000// 정점의 개수 : v, 간선의 개수 : eint v, e;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;vector&lt;int&gt; dist;vector&lt;bool&gt; check;int start_node;void dijkstra()&#123; for (int i = 1; i &lt;= v; i++) dist[i] = INF; dist[start_node] = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.push(&#123;0, start_node&#125;); while (!pq.empty()) &#123; int weight = pq.top().first; int cnt_node = pq.top().second; pq.pop(); if (check[cnt_node] == true) continue; check[cnt_node] = true; // 점 cnt_node에 연결된 간선의 개수 int edge_num = graph[cnt_node].size(); for (int j = 0; j &lt; edge_num; j++) &#123; // from : 현재 위치, to : 다음 위치, from_to_weight : 현재위치에서 다음위치 까지의 가중치 int from = cnt_node, to = graph[cnt_node][j].first, from_to_weight = graph[cnt_node][j].second; if (dist[to] &gt; dist[from] + from_to_weight) &#123; dist[to] = dist[from] + from_to_weight; pq.push(&#123;dist[to], to&#125;); &#125; &#125; &#125;&#125;int main(void)&#123; scanf(&quot;%d %d %d&quot;, &amp;v, &amp;e, &amp;start_node); dist = vector&lt;int&gt;(v + 1, INF); check = vector&lt;bool&gt;(v + 1, false); graph = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(v + 1); for (int i = 0; i &lt; e; i++) &#123; int from, to, weight; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;weight); graph[from].push_back(&#123;to, weight&#125;); &#125; dijkstra(); for (int i = 1; i &lt;= v; i++) &#123; if (dist[i] == INF) printf(&quot;INF\\n&quot;); else &#123; printf(&quot;%d\\n&quot;, dist[i]); &#125; &#125; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"다익스트라","slug":"Programming/Beakjoon/다익스트라","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}],"tags":[{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"}]},{"title":"JPA - Entity Manager Factory와 Entity Manager","slug":"JPA/entitymanager","date":"2021-02-14T19:31:46.000Z","updated":"2021-03-19T17:22:21.273Z","comments":true,"path":"2021/02/15/JPA/entitymanager/","link":"","permalink":"https://ckck803.github.io/2021/02/15/JPA/entitymanager/","excerpt":"","text":"JPA - Entity Manager Factory와 Entity ManagerEntityManagerEntity Manager는 transaction 단위로 만들고 DataBase transaction이 끝나면 같이 종료 시킨다.EntityManager.persist(entity) : 사실 DB에 저장하는 것이 아니다. 영속성 context를 통해 Entity를 영속화 한다. 사실 DB에 저장하는 것이 아니라. Entity를 영속성 context라는데 저장한다. Entity Manager와 영속성 Context가 1:1로 대응이 된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"JPA","slug":"Programming/JAVA/JPA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"}]},{"title":"스프링부트를 이용한 게시판 만들기 14 - Github와 jenkins 연동하기","slug":"springboot/sample-board/board-14-github-webhook","date":"2021-02-14T16:47:01.000Z","updated":"2021-03-13T11:44:42.955Z","comments":true,"path":"2021/02/15/springboot/sample-board/board-14-github-webhook/","link":"","permalink":"https://ckck803.github.io/2021/02/15/springboot/sample-board/board-14-github-webhook/","excerpt":"","text":"14. Github와 jenkins 연동하기Github webhookngrok을 이용해 외부접근이 가능하도록 네트워크 열기Push 이벤트가 일어났을 때 로컬 Jenkins가 해당 훅을 받기 위해서는 해당 네트워크(포트)를 외부접근이 가능하게 열어놔야 한다.ngrok 프로그램을 사용해 Github로부터 hook을 받을 수 있도록 Jenkins 포트를 열어준다. ngrok은 local PC를 외부에서 접근이 가능하도록 열어주는 프로그램이다. Webhook 추가하기Project Repository &gt; settings &gt; Webhooks &gt; add webhook 로 이동해 Payload URL에 http://[서버 IP주소]:[Port번호]/github-webhook/ 형식으로 날릴 주소를 기입하도록한다. 반드시 주소 뒤에 /github-webhook/ 를 추가해야 한다. Push가 일어났을 때 Payload URL(Jenkins)로 Hook을 날린다. github에서 Webhook을 설정하면 github에서 hook을 날리는 것을 확인할 수 있다. 빌드 진행하기Push 하기 ngrok 로그 확인github로 push를 하게 되면 jenkins서버로 hook을 날리는 것을 확인할 수 있다. build History 확인하기jenkins에 새로운 build가 생성된 것을 확인할 수 있다. 콘솔 출력 확인build가 정상적으로 이루어지고 있는지 아니면 오류가 발생했는지를 확인할 수 있다. Github Hook Log 확인코드에 변화가 있을 경우에는 jenkins에서 해당 프로젝트를 build하지만 코드에 변화가 없을 경우에는 build를 진행하지 않는다. 코드에 변화가 있을 경우 로그 코드에 변화가 없을 경우 로그","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Github","slug":"Github","permalink":"https://ckck803.github.io/tags/Github/"}]},{"title":"스프링부트를 이용한 게시판 만들기 15 - Github와 jenkins 연동하기","slug":"springboot/sample-board/board-15-github-webhook","date":"2021-02-14T16:47:01.000Z","updated":"2021-03-13T11:29:47.371Z","comments":true,"path":"2021/02/15/springboot/sample-board/board-15-github-webhook/","link":"","permalink":"https://ckck803.github.io/2021/02/15/springboot/sample-board/board-15-github-webhook/","excerpt":"","text":"15. Github와 jenkins 연동하기Github webhookngrok을 이용해 외부접근이 가능하도록 네트워크 열기Push 이벤트가 일어났을 때 로컬 Jenkins가 해당 훅을 받기 위해서는 해당 네트워크(포트)를 외부접근이 가능하게 열어놔야 한다.ngrok 프로그램을 사용해 Github로부터 hook을 받을 수 있도록 Jenkins 포트를 열어준다. ngrok은 local PC를 외부에서 접근이 가능하도록 열어주는 프로그램이다. Webhook 추가하기Project Repository &gt; settings &gt; Webhooks &gt; add webhook 로 이동해 Payload URL에 http://[서버 IP주소]:[Port번호]/github-webhook/ 형식으로 날릴 주소를 기입하도록한다. 반드시 주소 뒤에 /github-webhook/ 를 추가해야 한다. Push가 일어났을 때 Payload URL(Jenkins)로 Hook을 날린다. github에서 Webhook을 설정하면 github에서 hook을 날리는 것을 확인할 수 있다. 빌드 진행하기Push 하기 ngrok 로그 확인github로 push를 하게 되면 jenkins서버로 hook을 날리는 것을 확인할 수 있다. build History 확인하기jenkins에 새로운 build가 생성된 것을 확인할 수 있다. 콘솔 출력 확인build가 정상적으로 이루어지고 있는지 아니면 오류가 발생했는지를 확인할 수 있다. Github Hook Log 확인코드에 변화가 있을 경우에는 jenkins에서 해당 프로젝트를 build하지만 코드에 변화가 없을 경우에는 build를 진행하지 않는다. 코드에 변화가 있을 경우 로그 코드에 변화가 없을 경우 로그","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Github","slug":"Github","permalink":"https://ckck803.github.io/tags/Github/"}]},{"title":"스프링부트를 이용한 게시판 만들기 14 - Jenkins 프로젝트 만들기","slug":"springboot/sample-board/board-14-jenkins-plan","date":"2021-02-14T04:11:40.000Z","updated":"2021-03-13T11:29:50.993Z","comments":true,"path":"2021/02/14/springboot/sample-board/board-14-jenkins-plan/","link":"","permalink":"https://ckck803.github.io/2021/02/14/springboot/sample-board/board-14-jenkins-plan/","excerpt":"","text":"14. Jenkins 프로젝트 만들기 새 프로젝트 만들기 소스 코드 관리 소스 코드를 가져오기 위한 계정 추가하기 빌드 유발 선택 Build 선택하기 프로젝트 확인 프로젝트 build하기 프로젝트 결과 확인 새 프로젝트 만들기create a Job &gt; FreeStyle project 를 선택해 새 프로젝트를 만든다. 소스 코드 관리git을 선택한 후 Build할 Repository URL을 넣어준다. 계정 추가하기Credential 종류(kind)로는 Username with password 를 선택한 다음 username에는 Github Id를 Password에는 Github Password를 기입해 계정을 추가한다. 빌드 유발 선택Github hook trigger for GITScm polling 을 선택해 Github에 프로젝트를 Push했을 때 build가 진행될 수 있도록 한다. 개발자 Github로 PUSH를 날리게 되면 Github는 Web hook을 Jenkins으로 날려준다. Build 선택하기shell 명령어를 이용해 프로젝트를 빌드 할 것이므로 Execute shell 을 선택한 후 명령어는 ./gradlew clean build 를 기입한다. Spring Boot 프로젝트는 gradle wrapper를 사용함으로 gradlew를 사용한 Build 방법도 사용할 수 있다. 개인적으론 gradlew를 사용한 Build방식이 더 좋은 것 같다. 프로젝트 확인Dashboard에 새로운 Jenkins 프로젝트가 생성된 것을 확인할 수 있다. 프로젝트 build하기새로운 프로젝트를 생성한 후 해당 프로젝트가 github로부터 파일을 제대로 읽어와 build할 수 있는지 확인하기 위해 Build Now 를 눌러 빌드를 진행해본다. 프로젝트 결과 확인빌드 후 성공했다는 메시지를 받을 수 있다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://ckck803.github.io/tags/Jenkins/"}]},{"title":"스프링부트를 이용한 게시판 만들기 13 - jenkins를 이용해 build 하기","slug":"springboot/sample-board/board-13-jenkins","date":"2021-02-14T03:11:40.000Z","updated":"2021-03-13T11:44:38.794Z","comments":true,"path":"2021/02/14/springboot/sample-board/board-13-jenkins/","link":"","permalink":"https://ckck803.github.io/2021/02/14/springboot/sample-board/board-13-jenkins/","excerpt":"","text":"13. jenkins를 이용해 build하기jenkins를 로컬에 바로 설치해 사용해도 되지만 해당 프로젝트에서는 docker를 이용해 jenkins이미지를 불러와 빌드를 진행할 것이다. docker 설치하기도커는 https://docs.docker.com/get-docker/ 에서 본인 운영체제에 맞는 것을 선택해 다운로드 한다. 본인이 사용하는 프로젝트의 jdk 버전에 맞는 jenkins 파일 가져와야 build시에 jdk 버전 오류가 안생긴다. JDK11버전의 jenkins 이미지를 불러오도록 한다. docker images 명령어를 통해 이미지들을 확인할 수 있다. 123456# lts버전의 jenkins 이미지docker pull jenkins/jenkins:lts# jdk11버전의 jenkins 이미지docker pull jenkins/jenkins:jdk11# 설치된 이미지들 확인docker images jenkins 이미지 실행하기local의 8090포트를 container의 8080포트에 포워딩 시켜준다. container의 특성상 데이터 휘발성 때문에 container 내부에 데이터를 저장할 수 없다. v 옵션을 통해 local의 폴더와 conatainer의 폴더를 공유해 container에 저장한 내용이 그대로 local에도 저장되도록 한다. 8080포트는 평소 스프링 부트를 사용하기에 충돌을 막기 위해 8090포트를 선택했다. 123456# lts버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins:/var/jenkins_home jenkins/jenkins:lts# jdk11버전으로 실행시docker run -d -p 8090:8080 -p 50000:50000 -v ~/docker/jenkins-jdk11:/var/jenkins_home jenkins/jenkins:jdk11# docker container Id3c29b7adb686ad8310bf474fe91406e1ab8c569568e2ef2b5d09f40525aa78ee jenkins 설정jenkins 초기 비밀번호localhost:8090 으로 들어가게 되면 다음과 같이 초기 비밀번호를 입력하라는 창이 뜬다. docker의 경우 log를 확인하면 jenkins 초기 비밀번호를 확인할 수 있다. docker logs [container Id] 명령어를 통해 console에서 docker 로그를 확인할 수 있다. docker를 통해 처음으로 jenkins 이미지를 실행하게 되면 log에 jenkins 초기 비밀번호를 확인할 수 있다. jenkins 플러그인 설치Install suggested plugins 로 플러그인들을 설치한 후 새로운 계정을 만들게 되면 jenkins에 접근할 수 있다. jenkins 프로젝트 만들기새 프로젝트 만들기새로운 Item 만들기 &gt; FreeStyle project 를 선택해 새 프로젝트를 만든다. 소스 코드 관리소스 코드 관리에서 git 을 선택한 후 build할 Repository URL을 넣어준다. 계정 추가하기Credential 종류(kind)로는 Username with password 를 선택한 다음 username에는 Github Id를 Password에는 Github Password를 기입해 계정을 추가한다. 빌드 유발 선택Github hook trigger for GITScm polling 을 선택해 Github에 프로젝트를 Push했을 때 build가 진행될 수 있도록 한다. Build 선택하기shell 명령어를 이용해 SpringBoot 프로젝트를 빌드 할 것이므로 Execute shell 을 선택한 후 명령어는 ./gradlew clean build 를 기입한다. 프로젝트 확인Dashboard에 새로운 jenkins 프로젝트가 생성된 것을 확인할 수 있다. 프로젝트 build하기새로운 프로젝트를 생성한 후 해당 프로젝트가 github로부터 파일을 제대로 읽어와 build할 수 있는지 확인하기 위해 Build Now 를 눌러 빌드를 진행해본다. 프로젝트 결과 확인빌드 후 성공했다는 메시지를 받을 수 있다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"jenkins","slug":"jenkins","permalink":"https://ckck803.github.io/tags/jenkins/"}]},{"title":"스프링부트를 이용한 게시판 만들기 12 - 타임리프 오류 해결하기","slug":"springboot/sample-board/board-12-errors","date":"2021-02-13T17:23:28.000Z","updated":"2021-03-13T11:44:29.450Z","comments":true,"path":"2021/02/14/springboot/sample-board/board-12-errors/","link":"","permalink":"https://ckck803.github.io/2021/02/14/springboot/sample-board/board-12-errors/","excerpt":"","text":"12. 타임리프 오류 해결하기null 오류게시물이 하나도 없을 때 Thymeleaf에서 null인 객체를 참조하여 오류가 발생하는 것을 확인할 수 있었다. 객체를 반환할 때 데이터가 null인 경우 비어있는 객체를 생성해 반환하도록 한다. 1234567891011@GetMapping(&quot;/&quot;)public String board(@PageableDefault Pageable pageable, Model model) &#123; Page&lt;Post&gt; posts = postService.getPosts(pageable); if(posts == null)&#123; posts = new PageImpl&lt;Post&gt;(new ArrayList&lt;&gt;()); &#125; model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;;&#125; paging 오류데이터가 하나도 없는데 pagination 목록에서 1과 0이 떠있는 오류를 발견했다. startIdx= $&#123;PostList.totalPages == 0&#125; ? 0 : $&#123;T(Math).floor(PostList?.number/5)&#125;*5+1 조건을 추가해 page가 하나도 없을 경우 0을 반환하도록 해 페이지 목록에 0만 나타나게 한다. 1234567891011121314151617181920212223242526272829&lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot; th:with=&quot;startIdx= $&#123;PostList.totalPages == 0&#125; ? 0 : $&#123;T(Math).floor(PostList?.number/5)&#125;*5+1, lastIdx=($&#123;PostList.totalPages&#125; &gt; $&#123;startIdx&#125;+4) ? $&#123;startIdx&#125;+4 : $&#123;PostList.totalPages&#125;&quot; &gt; &lt;li th:class=&quot;$&#123;PostList.first&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.first&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;startIdx&#125;-1)&#125;&quot; aria-label=&quot;Previous&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.first&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;)&#125;&quot;&gt;&amp;lsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;($&#123;page&#125; == $&#123;PostList.number&#125;+1)&quot; th:each=&quot;page: $&#123;#numbers.sequence(startIdx, lastIdx)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;$&#123;page&#125;&quot; th:href=&quot;@&#123;/(page=$&#123;page&#125;)&#125;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.last&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;+2)&#125;&quot;&gt;&amp;rsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;$&#123;PostList.last&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.last&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;lastIdx&#125;+1)&#125;&quot; aria-label=&quot;Next&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; pagation 목록에 0만 떠 있는 것을 확인할 수 있다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"error","slug":"error","permalink":"https://ckck803.github.io/tags/error/"}]},{"title":"스프링부트를 이용한 게시판 만들기 11 - 페이징 처리하기","slug":"springboot/sample-board/board-11-paging","date":"2021-02-13T02:59:50.000Z","updated":"2021-03-13T11:30:16.091Z","comments":true,"path":"2021/02/13/springboot/sample-board/board-11-paging/","link":"","permalink":"https://ckck803.github.io/2021/02/13/springboot/sample-board/board-11-paging/","excerpt":"","text":"11. 페이징 처리하기메인 게시판을 접근하게 되면 한번에 너무 많은 게시글들이 쏟아져 나오게 돼 보기가 좋지 않고 서버도 많은 양의 데이터를 한번에 보내야 하기 때문에 성능에서도 좋지 않다.사용자에게 전체 데이터에서 적당한 양의 데이터만 보여줘 사용자 입장에서도 서버 입장에서도 부담이 없게 한다. Control 로직 수정하기Spring에서 제공하는 Pageable 인터페이스를 사용하면 쉽게 페이징 기능을 사용할 수 있다. BoardController.java 12345678910111213141516171819@Controller@RequiredArgsConstructorpublic class BoardController &#123; private final PostService postService;// @GetMapping(&quot;/&quot;)// public String board(Model model)&#123;// List&lt;Post&gt; posts = postService.getAllPosts();// model.addAttribute(&quot;PostList&quot;, posts);// return &quot;board&quot;;// &#125; @GetMapping(&quot;/&quot;) public String board(@PageableDefault Pageable pageable, Model model) &#123; Page&lt;Post&gt; posts = postService.getPosts(pageable); model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;; &#125;&#125; 테스트 코드 로직 변경12345678910111213141516171819202122232425262728@Test@DisplayName(&quot;모든 Post를 가져온다.&quot;)public void board() throws Exception &#123; List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); posts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); Page&lt;Post&gt; pagePosts = new PageImpl&lt;&gt;(posts); PageRequest pageRequest = PageRequest.of(1, 10); given(postService.getPosts(pageRequest)).willReturn(pagePosts); ResultActions resultActions = mockMvc.perform(get(&quot;/&quot;) .param(&quot;page&quot;, &quot;1&quot;)// .flashAttr(&quot;PostList&quot;, new ArrayList&lt;&gt;()) ); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).getPosts(pageRequest);&#125; Servic 로직 추가PageRequest는 Pageable 인터페이스를 구현해 놓은 클래스이다. page, size, sort 를 변수를 설정함으로써 쉽게 paging 요청을 할 수 있다. page : 찾을 페이지size : 한 페이지 내에 가져올 목록(데이터)의 개수sort : 페이징을 정렬하는 방식 Paging은 sort를 통해 데이터들을 정렬하고 size를 통해 데이터들을 그룹으로 나눈 후 각 그룹에 번호를 붙이고 page를 통해 해당 그룹을 가져온다. PostService.java 1234567891011public Page&lt;Post&gt; getPosts(Pageable pageable) &#123; int page; if(pageable.getPageNumber() &lt;= 0)&#123; page = 0; &#125;else&#123; page = pageable.getPageNumber()-1; &#125; Pageable requestPageable = PageRequest.of(page, pageable.getPageSize()); return postRepository.findAll(requestPageable);&#125; Id 역순으로 정렬하기12345678910111213141516@Transactionalpublic void deletePostById(Long id)&#123; postRepository.deleteById(id);&#125;public Page&lt;Post&gt; getPosts(Pageable pageable) &#123; int page; if(pageable.getPageNumber() &lt;= 0)&#123; page = 0; &#125;else&#123; page = pageable.getPageNumber()-1; &#125; Pageable requestPageable = PageRequest.of(page, pageable.getPageSize(), Sort.by(Sort.Direction.DESC, &quot;id&quot;)); return postRepository.findAll(requestPageable);&#125; 타임리프에 paging관련 설정을 해주기Thymeleaf의 th:with 속성을 사용하면 지역변수를 사용할 수 있다. startIdx=$&#123;T(Math).floor(PostList.number/5)&#125;*5+1 : pagenation에서의 시작 번호 lastIdx=($&#123;PostList.totalPages&#125; &gt; $&#123;startIdx&#125;+4) ? $&#123;startIdx&#125;+4 : $&#123;PostList.totalPages&#125; : pagenation에서의 마지막 번호 123456789101112131415161718192021222324252627&lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot; th:with=&quot;startIdx=$&#123;T(Math).floor(PostList.number/5)&#125;*5+1, lastIdx=($&#123;PostList.totalPages&#125; &gt; $&#123;startIdx&#125;+4) ? $&#123;startIdx&#125;+4 : $&#123;PostList.totalPages&#125;&quot;&gt; &lt;li th:class=&quot;$&#123;PostList.first&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.first&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;startIdx&#125;-1)&#125;&quot; aria-label=&quot;Previous&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.first&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;)&#125;&quot;&gt;&amp;lsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;($&#123;page&#125; == $&#123;PostList.number&#125;+1)&quot; th:each=&quot;page: $&#123;#numbers.sequence(startIdx, lastIdx)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;$&#123;page&#125;&quot; th:href=&quot;@&#123;/(page=$&#123;page&#125;)&#125;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li th:style=&quot;$&#123;PostList.last&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;+2)&#125;&quot;&gt;&amp;rsaquo;&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;$&#123;PostList.last&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.last&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;lastIdx&#125;+1)&#125;&quot; aria-label=&quot;Next&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 이전 그룹으로 이동하기 PostList.first : 현재 페이지가 제일 첫페인지 아닌지 (boolean) PostList.last : 현재 페이지가 제일 마지막 페이지 인지 아닌지 (boolean) 1234&lt;li th:class=&quot;$&#123;PostList.first&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.first&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;startIdx&#125;-1)&#125;&quot; aria-label=&quot;Previous&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; 이전 페이지로 이동하기123&lt;li th:style=&quot;$&#123;PostList.first&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;)&#125;&quot;&gt;&amp;lsaquo;&lt;/a&gt;&lt;/li&gt; 페이지 그룹 보여주기1234&lt;li th:class=&quot;($&#123;page&#125; == $&#123;PostList.number&#125;+1)&quot; th:each=&quot;page: $&#123;#numbers.sequence(startIdx, lastIdx)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;$&#123;page&#125;&quot; th:href=&quot;@&#123;/(page=$&#123;page&#125;)&#125;&quot;&gt;&lt;/a&gt;&lt;/li&gt; 다음 페이지로 이동하기123&lt;li th:style=&quot;$&#123;PostList.last&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;/(page=$&#123;PostList.number&#125;+2)&#125;&quot;&gt;&amp;rsaquo;&lt;/a&gt;&lt;/li&gt; 다음 그룹으로 이동하기1234&lt;li th:class=&quot;$&#123;PostList.last&#125; ? &#x27;disabled&#x27;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;$&#123;PostList.last&#125; ? &#x27;#&#x27; : @&#123;/(page=$&#123;lastIdx&#125;+1)&#125;&quot; aria-label=&quot;Next&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt; List 번호 수정하기페이지를 이동해도 List번호가 1~10 으로 밖에 표현되지 않았다. 각페이지를 이동할 때 페이지 번호에 각 세부 번호를 나타낼 수 있도록 표현을 바꿔준다. 12345678910111213141516&lt;tbody class=&quot;text-center&quot;&gt;&lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot; th:id=&quot;*&#123;Post.id&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index + 1&#125; + $&#123;PostList.number&#125;*10&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:href=&quot;@&#123;/post/&#123;id&#125;(id=$&#123;Post.id&#125;)&#125;&quot; th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@&#123;/post/&#123;id&#125;/revise(id=$&#123;Post.id&#125;)&#125;&quot;&gt;수정&lt;/a&gt; &lt;a href=&quot;#&quot; th:href=&quot;&#x27;javascript:deletePost(&#x27;+$&#123;Post.id&#125;+&#x27;)&#x27;&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/a&gt; &lt;!-- &lt;button id=&quot;delete-btn&quot; type=&quot;submit&quot; class=&quot;btn btn-danger&quot; th:onclick=&quot;deletePost([[ $&#123;Post.id&#125; ]]);&quot;&gt;삭제&lt;/button&gt;--&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"paging","slug":"paging","permalink":"https://ckck803.github.io/tags/paging/"}]},{"title":"스프링부트를 이용한 게시판 만들기 10 - 포스트 삭제하기","slug":"springboot/sample-board/board-10-delete","date":"2021-02-12T16:19:00.000Z","updated":"2021-03-13T11:30:19.439Z","comments":true,"path":"2021/02/13/springboot/sample-board/board-10-delete/","link":"","permalink":"https://ckck803.github.io/2021/02/13/springboot/sample-board/board-10-delete/","excerpt":"","text":"10. 포스트 삭제하기PostController.java 123456@PostMapping(&quot;/post/&#123;postId&#125;/delete&quot;)public String deletePost(@PathVariable(&quot;postId&quot;) Long id)&#123; postService.deletePostById(id); return &quot;redirect:/&quot;;&#125; PostService.java 1234@Transactionalpublic void deletePostById(Long id)&#123; postRepository.deleteById(id);&#125; Post.html 12345678910111213141516&lt;tbody class=&quot;text-center&quot;&gt;&lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot; th:id=&quot;*&#123;Post.id&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index+1&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:href=&quot;@&#123;/post/&#123;id&#125;(id=$&#123;Post.id&#125;)&#125;&quot; th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; th:href=&quot;@&#123;/post/&#123;id&#125;/revise(id=$&#123;Post.id&#125;)&#125;&quot;&gt;수정&lt;/a&gt; &lt;a href=&quot;#&quot; th:href=&quot;&#x27;javascript:deletePost(&#x27;+$&#123;Post.id&#125;+&#x27;)&#x27;&quot; class=&quot;btn btn-danger&quot;&gt;삭제&lt;/a&gt;&lt;!--&lt;button id=&quot;delete-btn&quot; type=&quot;submit&quot; class=&quot;btn btn-danger&quot; th:onclick=&quot;deletePost([[ $&#123;Post.id&#125; ]]);&quot;&gt;삭제&lt;/button&gt;--&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; 123456789101112131415161718192021function deletePost(id) &#123; if(confirm(id + &quot;번 게시글을 삭제하시겠습니까?&quot;)) &#123; const action = &quot;/post/&quot; + id + &quot;/delete&quot; let form = document.createElement(&quot;form&quot;); form.setAttribute(&quot;method&quot;, &quot;post&quot;); form.setAttribute(&quot;action&quot;, action); document.body.appendChild(form); form.submit(); &#125;&#125;// var table = document.getElementById(&#x27;PostTable&#x27;);//// async function deletePost(id) &#123;// url = &quot;http://localhost:8080/post/&quot; + id + &quot;/delete&quot;;// console.log(url);// const response = await fetch(url, &#123;// method: &#x27;post&#x27;// &#125;);// &#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 9 - 페이지 수정하기","slug":"springboot/sample-board/board-9-detail-revise","date":"2021-02-12T12:13:28.000Z","updated":"2021-03-13T11:30:22.770Z","comments":true,"path":"2021/02/12/springboot/sample-board/board-9-detail-revise/","link":"","permalink":"https://ckck803.github.io/2021/02/12/springboot/sample-board/board-9-detail-revise/","excerpt":"","text":"9. 페이지 수정하기데이터를 수정하기 위해서는 수정하고자 하는 데이터를 찾아야 하기 때문에 id값이 필요하다. input태그의 type속성을 hidden으로해 form을 작성한 후 나머지 데이터와 함께 id값을 넘겨주도록 한다. post.html 123456789101112131415161718192021222324252627282930313233&lt;h2&gt;게시글 작성&lt;/h2&gt;&lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:action=&quot;@&#123;/post&#125;&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;input type=&quot;hidden&quot; th:if=&quot;*&#123;id != null and id &gt; 0&#125;&quot; th:field=&quot;*&#123;id&#125;&quot;/&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; style=&quot;border-radius: 5px;&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;title&#125;&quot; placeholder=&quot;제목을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; style=&quot;border-radius: 5px;&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;name&#125;&quot;placeholder=&quot;이름을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px; border-radius: 5px;&quot; th:field=&quot;*&#123;content&#125;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a th:href=&quot;@&#123;/&#125;&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 수정페이지로 이동하기데이터를 수정위해서 URL경로를 통해 수정할 데이터의 id값을 받아온 후 해당 id값을 이용해 데이터를 조회한 뒤 기존 데이터를 반환하도록 한다. 내부 로직은 상세페이지를 가져오는 것과 똑같고 반환하는 템플릿만 다르게 반환한다. PostController.java 123456789101112131415@GetMapping(&quot;/post/&#123;postId&#125;/revise&quot;)public String getPostDetailsToRevise(@PathVariable(&quot;postId&quot;) Long id, Model model) &#123; Post post = postService.getPostById(id); PostDto postDto = PostDto.builder() .id(post.getId()) .name(post.getName()) .title(post.getTitle()) .content(post.getContent()) .writeTime(post.getWriteTime()) .build(); model.addAttribute(&quot;postDto&quot;, postDto); return &quot;post&quot;;&#125; PostControllerTest.java 123456789101112131415161718@Test@DisplayName(&quot;포스트 수정 페이지로 이동한다.&quot;)public void getPostDetailsToRevise() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.getPostById(1L)).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1/revise&quot;)); verify(postService).getPostById(1L); resultActions .andExpect(status().isOk());&#125; 데이터 수정 요청 처리를 위한 Control입력받은 데이터를 확인해 id값이 있을 경우에는 새로운 Post를 생성하게 id값이 없는 경우에는 기존 데이터를 Update하도록 한다. form 태그는 Get과 Post 메소드만 사용할 수 있다. Patch 사용하려고 method까지 다 만들어 놨는데 나중가서 생각남….. PostController.java 12345678910@PostMapping(&quot;/post&quot;)public String creatNewPost(@Valid @ModelAttribute(&quot;postDto&quot;) PostDto postDto) &#123; if(postDto.getId() == null) &#123; postService.addPost(postDto); &#125;else&#123; postService.revisePostDetails(postDto); &#125; return &quot;redirect:/&quot;;&#125; 수정요청에 대한 테스트 코드 작성데이터 수정이 제대로 이루어진 경우 /로 redirection이 이루어진다. 결과값으로 상태코드가 302로 뜨는지 확인하도록 한다. PostControllerTest.java 12345678910111213141516171819202122232425@Test@DisplayName(&quot;포스트를 수정한다.&quot;)public void creatOrUpdatePost() throws Exception &#123; PostDto postDto = PostDto.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .build(); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;id&quot;, &quot;1&quot;) .param(&quot;name&quot;, &quot;tester&quot;) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); verify(postService).updatePost(postDto); resultActions .andExpect(status().is3xxRedirection()) .andDo(print()) ;&#125; 데이터 수정을 위한 Service 로직여기서는 DB조회시 PostNotExistedException 예외가 일어날 일이 없다. Control에서 id값의 유무를 통해 create와 update로 나누어 실행하기 때문이다. PostService.java 123456@Transactionalpublic Post updatePost(PostDto postDto) &#123; Post oldPost = postRepository.findById(postDto.getId()).orElseThrow(() -&gt; new PostNotExistedException(postDto.getId())); oldPost.revise(postDto); return oldPost;&#125; 데이터 수정에 대한 테스트 코드 작성PostServiceTest.java 1234567891011121314151617181920212223242526@Test@DisplayName(&quot;포스트 데이터를 업데이트 한다.&quot;)public void updatePost()&#123; PostDto postDto = PostDto.builder() .id(1L) .name(&quot;junit&quot;) .title(&quot;junitTest&quot;) .content(&quot;content&quot;) .build(); Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.findById(1L)).willReturn(Optional.of(mockPost)); Post post = postService.updatePost(postDto); verify(postRepository).findById(1L); assertThat(post.getName()).isEqualTo(postDto.getName()); assertThat(post.getTitle()).isEqualTo(postDto.getTitle()); assertThat(post.getContent()).isEqualTo(postDto.getContent());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 8 - 상세 페이지","slug":"springboot/sample-board/board-8-detail-post","date":"2021-02-12T11:42:27.000Z","updated":"2021-03-13T11:30:26.420Z","comments":true,"path":"2021/02/12/springboot/sample-board/board-8-detail-post/","link":"","permalink":"https://ckck803.github.io/2021/02/12/springboot/sample-board/board-8-detail-post/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;/fragments/head :: main-head&quot;&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;/fragments/navbar :: main-nav&quot;&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;h2&gt;상세 페이지&lt;/h2&gt; &lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;h1 th:text=&quot;*&#123;title&#125;&quot;&gt;제목&lt;/h1&gt; &lt;span&gt;작성자 : &lt;/span&gt; &lt;span th:text=&quot;*&#123;name&#125;&quot;&gt;Tester &lt;/span&gt; &lt;hr&gt; &lt;p class=&quot;lead&quot; style=&quot;height: 300px; border-radius: 5px;&quot; th:text=&quot;*&#123;content&#125;&quot;&gt;&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;text-right&quot; style=&quot;padding-right: 10px;&quot;&gt; &lt;span class=&quot;text-right&quot;&gt;작성일 : &lt;/span&gt; &lt;span class=&quot;text-right&quot; th:text=&quot;*&#123;writeTime&#125;&quot;&gt;작성일 &lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;수정하기&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger waves-effect waves-light&quot;&gt;삭제하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 7 - 특정 페이지를 가져오기","slug":"springboot/sample-board/board-7-detail","date":"2021-02-12T08:17:44.000Z","updated":"2021-03-13T11:30:29.820Z","comments":true,"path":"2021/02/12/springboot/sample-board/board-7-detail/","link":"","permalink":"https://ckck803.github.io/2021/02/12/springboot/sample-board/board-7-detail/","excerpt":"","text":"7. 특정 포스트를 불러오기특정 포스트 불러오기 요청 처리하기 PostController 123456789101112131415@GetMapping(&quot;/post/&#123;postId&#125;&quot;)public String getPostDetails(@PathVariable(&quot;postId&quot;)Long id, Model model)&#123; Post post = postService.getPostById(id); PostDto postDto = PostDto.builder() .id(post.getId()) .name(post.getName()) .title(post.getTitle()) .content(post.getContent()) .writeTime(post.getWriteTime()) .build(); model.addAttribute(&quot;postDto&quot;, postDto); return &quot;details&quot;;&#125; PostControllerTest.java 1234567891011121314151617181920@Test@DisplayName(&quot;상세 페이지를 가져온다.&quot;)public void getPostDetails() throws Exception&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.getPostById(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1&quot;)); resultActions .andExpect(status().isOk()); verify(postService).getPostById(any());&#125; PostControllerTest.java 123456789101112@Test@DisplayName(&quot;상세 페이지를 못 가져온다.&quot;)public void getPostDetailsException() throws Exception&#123; given(postService.getPostById(any())).willThrow(new PostNotExistedException(1L)); ResultActions resultActions = mockMvc.perform(get(&quot;/post/1&quot;)); resultActions .andExpect(status().isNotFound()); verify(postService).getPostById(any());&#125; 포스트가 없는 경우에 대한 예외처리하기BoardErrorAdvice.java 123456789@ControllerAdvicepublic class BoardErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(PostNotExistedException.class) public void handleNotFound()&#123; &#125;&#125; PostNotExistedException.java 123456public class PostNotExistedException extends RuntimeException&#123; public PostNotExistedException(Long id)&#123; super(&quot;Post id : &quot; + id + &quot; is not Existed&quot;); &#125;&#125; PostService.java 1234public Post getPostById(Long id) &#123; Post post = postRepository.findById(id).orElseThrow(() -&gt; new PostNotExistedException(id)); return post;&#125; PostServiceTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041@Test@DisplayName(&quot;특정 포스트를 가져온다.&quot;)public void getPostById()&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.findById(1L)).willReturn(Optional.of(mockPost)); Post post = postService.getPostById(1L); verify(postRepository).findById(1L); assertThat(post.getId()).isEqualTo(mockPost.getId()); assertThat(post.getTitle()).isEqualTo(mockPost.getTitle()); assertThat(post.getName()).isEqualTo(mockPost.getName()); assertThat(post.getContent()).isEqualTo(mockPost.getContent()); assertThat(post.getWriteTime()).isEqualTo(mockPost.getWriteTime());&#125;@Test@DisplayName(&quot;특정 포스트를 못 가져온다.&quot;)public void getPostByIdException()&#123; Post mockPost = Post.builder() .id(1L) .name(&quot;tester&quot;) .title(&quot;test&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.findById(1L)).willThrow(new PostNotExistedException(1L)); assertThatThrownBy(() -&gt;&#123; postService.getPostById(1L); &#125;).isInstanceOf(PostNotExistedException.class); verify(postRepository).findById(1L);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 6 - 게시판 페이지 만들기","slug":"springboot/sample-board/board-6-list","date":"2021-02-12T08:10:45.000Z","updated":"2021-03-13T11:44:25.376Z","comments":true,"path":"2021/02/12/springboot/sample-board/board-6-list/","link":"","permalink":"https://ckck803.github.io/2021/02/12/springboot/sample-board/board-6-list/","excerpt":"","text":"게시판 페이지 템플릿게시판 페이지도 게시판 작성페이지와 똑같이 Bootstrap 과 BootWatch 를 이용해 만들었다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/custom.min.css&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;form class=&quot;form-inline my-2 my-lg-0 float-right&quot; style=&quot;padding-bottom : 16px;&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;text&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-secondary my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;table-responsive clearfix&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;등록일&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;btn_wrap text-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;Write&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item active&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 타임리프 문법 적용하기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;fragments/head :: main-head&quot;/&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;fragments/navbar :: main-nav&quot;/&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;form class=&quot;form-inline my-2 my-lg-0 float-right&quot; style=&quot;padding-bottom : 16px;&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;text&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-secondary my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;table-responsive clearfix&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead class=&quot;text-center&quot;&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;등록일&lt;/th&gt; &lt;th &gt;수정/삭제&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=&quot;text-center&quot;&gt; &lt;tr th:each=&quot;Post:$&#123;PostList&#125;&quot;&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;PostStat.index+1&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot;&gt; &lt;a th:text=&quot;$&#123;Post.title&#125;&quot;&gt;&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.name&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;align-middle&quot; th:text=&quot;$&#123;Post.writeTime&#125;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-center align-middle&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;수정&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;삭제&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;btn_wrap text-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;Write&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;text-center &quot;&gt; &lt;ul class=&quot;pagination&quot; style=&quot;justify-content: center;&quot;&gt; &lt;li class=&quot;page-item disabled&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item active&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 5 - 모든 Post 가져오기","slug":"springboot/sample-board/board-5-all","date":"2021-02-12T01:06:30.000Z","updated":"2021-03-13T11:30:36.031Z","comments":true,"path":"2021/02/12/springboot/sample-board/board-5-all/","link":"","permalink":"https://ckck803.github.io/2021/02/12/springboot/sample-board/board-5-all/","excerpt":"","text":"5. 모든 포스트 가져오기모든 포스트 가져오기 요청 처리하기BoardController.java 123456789101112@Controller@RequiredArgsConstructorpublic class BoardController &#123; private final PostService postService; @GetMapping(&quot;/&quot;) public String board(Model model)&#123; List&lt;Post&gt; posts = postService.getAllPost(); model.addAttribute(&quot;PostList&quot;, posts); return &quot;board&quot;; &#125;&#125; 모든 Post 가져오기 요청에 대한 테스트 코드 작성BoardControllerTest.java 123456789101112131415161718192021222324252627282930313233@WebMvcTestclass BoardControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private PostService postService; @Test @DisplayName(&quot;모든 Post를 가져온다.&quot;) public void board() throws Exception &#123; List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); posts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); given(postService.getAllPost()).willReturn(posts); ResultActions resultActions = mockMvc.perform(get(&quot;/&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); verify(postService).getAllPost(); &#125;&#125; 데이터 조회12345678910111213@Service@RequiredArgsConstructorpublic class PostService &#123; private final PostRepository postRepository; public Post addPost(Post newPost) &#123; return postRepository.save(newPost); &#125; public List&lt;Post&gt; getAllPost() &#123; return postRepository.findAll(); &#125;&#125; 데이터 조회에 대한 테스트 코드 작성123456789101112131415161718192021222324252627@Test@DisplayName(&quot;모든 포스트를 가져온다.&quot;)public void getAllPosts() &#123; List&lt;Post&gt; mockPosts = new ArrayList&lt;&gt;(); mockPosts.add(Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build() ); given(postRepository.findAll()).willReturn(mockPosts); List&lt;Post&gt; posts = postService.getAllPosts(); verify(postRepository).findAll(); Post post = posts.get(0); assertThat(post.getId()).isEqualTo(mockPosts.get(0).getId()); assertThat(post.getTitle()).isEqualTo(mockPosts.get(0).getTitle()); assertThat(post.getName()).isEqualTo(mockPosts.get(0).getName()); assertThat(post.getContent()).isEqualTo(mockPosts.get(0).getContent()); assertThat(post.getWriteTime()).isEqualTo(mockPosts.get(0).getWriteTime());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 4 - My SQL과 연동하기","slug":"springboot/sample-board/board-4-mysql","date":"2021-02-11T23:47:12.000Z","updated":"2021-03-13T11:30:39.357Z","comments":true,"path":"2021/02/12/springboot/sample-board/board-4-mysql/","link":"","permalink":"https://ckck803.github.io/2021/02/12/springboot/sample-board/board-4-mysql/","excerpt":"","text":"4. My SQL과 연동의존성 추가My Sql과 연동하기 위해서는 Springboot프로젝트에 의존성을 추가해야 한다. build.gradle 1implementation &#x27;mysql:mysql-connector-java&#x27; 데이터베이스 접속 설정하기application-mysql.yml 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/[DB]?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: [DB 접속 Id] password: [DB 접송 Password] 접속 설정 가져오기설정에 show_sql 과 format_sql 를 추가해 쿼리문들이 어떻게 출력되는지 눈으로 쉽게 확인할 수 있다. spring.jpa.properties.hibernate.show_sql=true : JPA(hibernamte)가 실행하는 SQL 쿼리문 로그를 출력한다. spring.jpa.properties.hibernate.format_sql=true : SQL문을 보기 좋게 정렬해 출력해준다. application.yml 1234567891011spring: jpa: hibernate: ddl-auto: create properties: hibernate: show_sql: true format_sql: true profiles: include: mysql Springboot를 실행하면 로그에 create 쿼리문이 찍히는 것을 확인할 수 있고 DB로 가게 되면 post 테이블이 생성됬음을 알 수 있다. 임의 데이터 추가하기CommandLineRunner를 사용해서 어플리케이션을 구동하면서 데이터를 데이터 베이스에 저장시킨다. 익명객체 생성 123456789101112131415@Beanpublic CommandLineRunner runner(PostRepository postRepository) throws Exception &#123; return new CommandLineRunner() &#123; @Override public void run(String... args) throws Exception &#123; IntStream.rangeClosed(1, 200).forEach(index -&gt; postRepository.save(Post.builder() .title(&quot;게시글&quot; + index) .name(&quot;tester&quot;) .content(&quot;내용&quot; + index) .writeTime(LocalDateTime.now()) .build())); &#125; &#125;;&#125; 람다식으로 직성 123456789101112@Beanpublic CommandLineRunner runner(PostRepository postRepository) throws Exception &#123; return args -&gt; &#123; IntStream.rangeClosed(1, 200).forEach(index -&gt; postRepository.save(Post.builder() .title(&quot;게시글&quot; + index) .name(&quot;tester&quot;) .content(&quot;내용&quot; + index) .writeTime(LocalDateTime.now()) .build())); &#125;;&#125; 데이터 베이스를 확인해 보니 데이터들이 정상적으로 입력된걸 확인할 수 있었다. 물론 수없이 많은 쿼리문들이 날라간 것도 눈으로 확인할 수 있다!","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 3 - 게시글 작성하기","slug":"springboot/sample-board/board-3-post-write","date":"2021-02-11T13:53:28.000Z","updated":"2021-03-13T11:30:42.387Z","comments":true,"path":"2021/02/11/springboot/sample-board/board-3-post-write/","link":"","permalink":"https://ckck803.github.io/2021/02/11/springboot/sample-board/board-3-post-write/","excerpt":"","text":"3. 새로운 Post 생성 요청 처리하기데이터를 저장하는 로직은 DB에 접근을 하기 때문에 다음과 같은 로직을 추가해 DB에 데이터들이 제대로 저장되는지 확인한다. 어플리케이션을 실핸한 후 http://localhost:8080/h2-console 를 통해 데이터 베이스에 접근할 수 있다. application.yml 12345678910spring: h2: console: enabled: true path: /h2-console datasource: username: sa password: url: jdbc:h2:mem:testdb driver-class-name: org.h2.Driver /post경로로 post 요청이 들어올 경우 입력된 정보들이 제대로 들어왔는지 Validation을 진행하고 문제가 없을 경우 데이터를 저장한다. PostController.java 123456@PostMapping(&quot;/post&quot;)public String creatNewPost(@Valid @ModelAttribute(&quot;postDto&quot;) PostDto postDto) &#123; postService.addPost(postDto); return &quot;redirect:/&quot;;&#125; 생성 요청 테스트 코드 작성하기MockBean 추가하기PostController의 creatNewPost메소드 내에서는 PostService객체를 사용하기 때문에 테스트코드를 작성하기 위해서 해당 Mock 을 추가해줄 필요가 있다. PostControllerTest.java 12@MockBeanprivate PostService postService; PostService객체의 MockBean을 생성해주지 않으면 아래와 같은 오류로 테스트가 진행되지 않는다. creatNewPost메소드 /post경로로 post 요청에 대한 테스트 코드를 작성할 것이다. given메소드를 이용해 PostService가 반환할 객체에 대해 정의를 한다. /post경로로 post요청을 보내도록한다. 데이터를 보내기 위해서는 flashAttr 메소드를 이용해 플래시 스코프에 객체를 설정하도록한다. 요청이 완료된 후 리다이렉션(Status Code : 302) 이 제대로 이루어지는지 확인한다. PostControllerTest.java 1234567891011121314151617181920212223242526272829@Test@DisplayName(&quot;새로운 게시글 생성을 성공한다.&quot;)public void successCreateNewPost() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto())// .sessionAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;name&quot;, &quot;tester&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); resultActions .andExpect(status().is3xxRedirection()) // Response Header에 있는 Location 정보를 비교한다. .andDo(print()); verify(postService).addPost(any());&#125; 실패에 대한 테스트 코드 진행Controller단에서의 Data Validation이 제대로 작동하는지 확인하기 위한 테스트 코드들이다. title, name, content 에 대한 값의 검증을 해줘야 하기 때문에 세가지 경우로 확인했다. PostControllerTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Test@DisplayName(&quot;새로운 게시글 생성을 실패한다.&quot;)public void failCreateNewFailWithNoTitle() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;name&quot;, &quot;tester&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); resultActions .andExpect(status().isBadRequest()) .andDo(print());&#125;@Test@DisplayName(&quot;새로운 게시글 생성을 실패한다.&quot;)public void failCreateNewFailWithNoName() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;content&quot;, &quot;test&quot;) ); resultActions .andExpect(status().isBadRequest()) .andDo(print());&#125;@Test@DisplayName(&quot;새로운 게시글 생성을 실패한다.&quot;)public void failCreateNewFailWithNoContent() throws Exception &#123; Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postService.addPost(any())).willReturn(mockPost); ResultActions resultActions = mockMvc.perform(post(&quot;/post&quot;) .flashAttr(&quot;postDto&quot;, new PostDto()) .param(&quot;title&quot;, &quot;test&quot;) .param(&quot;name&quot;, &quot;tester&quot;) ); resultActions .andExpect(status().isBadRequest()) .andDo(print());&#125; 데이터 저장하기PostRepository 객체를 통해 데이터 저장을 진행한다. PostService.java 1234567891011121314151617@Service@RequiredArgsConstructorpublic class PostService &#123; private final PostRepository postRepository; @Transactional public Post addPost(PostDto postDto) &#123; Post post = Post.builder() .title(postDto.getTitle()) .name(postDto.getName()) .content(postDto.getContent()) .writeTime(LocalDateTime.now()) .build(); return postRepository.save(post); &#125;&#125; 저장로직에 대한 테스트 코드 작성PostService 객체의 addPost가 실행된 후 값이 제대로 반환됐는지 확인한 후 PostRepository 객체에서 save 메소드가 호출됐는지 확인한다. PostServiceTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class PostServiceTest &#123; @Mock private PostRepository postRepository; private PostService postService; @BeforeEach public void init() &#123; MockitoAnnotations.openMocks(this); postService = new PostService(postRepository); &#125; @Test @DisplayName(&quot;새로운 포스트를 추가한다.&quot;) @Transactional public void addPost() &#123; PostDto postDto = PostDto.builder() .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); Post mockPost = Post.builder() .id(1L) .title(&quot;test&quot;) .name(&quot;tester&quot;) .content(&quot;test&quot;) .writeTime(LocalDateTime.now()) .build(); given(postRepository.save(any())).willReturn(mockPost); Post returnPost = postService.addPost(postDto); assertThat(returnPost.getId()).isEqualTo(mockPost.getId()); assertThat(returnPost.getTitle()).isEqualTo(mockPost.getTitle()); assertThat(returnPost.getName()).isEqualTo(mockPost.getName()); assertThat(returnPost.getContent()).isEqualTo(mockPost.getContent()); assertThat(returnPost.getWriteTime()).isEqualTo(mockPost.getWriteTime()); verify(postRepository).save(any()); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 2 - 게시글 작성페이지 만들기","slug":"springboot/sample-board/board-2-post","date":"2021-02-11T10:53:28.000Z","updated":"2021-03-13T11:30:46.672Z","comments":true,"path":"2021/02/11/springboot/sample-board/board-2-post/","link":"","permalink":"https://ckck803.github.io/2021/02/11/springboot/sample-board/board-2-post/","excerpt":"","text":"2. 게시글 작성페이지 설계도메인 설계하기사용자로부터 게시글 제목, 작성자 이름, 게시글 내용과 게시글들을 구별해주기 위해 Id값과 게시글이 언제 작성되었는지 알기 위한 작성시간을 추가해 도메인을 만든다. Post.java 12345678910111213141516171819202122@Entity@NoArgsConstructor@AllArgsConstructor@Builder@Getterpublic class Post &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty private String title; @NotEmpty private String name; @NotEmpty private String content; @NotNull private LocalDateTime writeTime;&#125; DTO 작성하기사용자로부터 Form을 통해 title, name, content를 입력 받는다. Post 객체를 사용해 데이터를 전달받을 수 있지만 View로직이 추가되게 된다. Entity는 DB와 데이터를 주고 받는 객체이기에 DTO를 만들어 Entity를 View로직으로부터 분리해 추후 생길 수 있는 문제를 없애도록 한다. 123456789101112131415@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class PostDto &#123; @NotEmpty private String title; @NotEmpty private String name; @NotEmpty private String content;&#125; View에 Thymeleaf문법 적용하기xmlns:th=&quot;http://www.thymeleaf.org&quot;를 추가하면 Thymeleaf문법을 사용할 수 있다. Thymeleaf는 html속성에 th: 를 붙여 사용한다. th:replace=&quot;/fragments/head :: main-head&quot; : 따로 선언돼 있는 html파일로 치환할 수 있다. th:action=&quot;@&#123;/post&#125;&quot; : Thymeleaf를 사용해 URL을 기입하기 위해서는 @를 추가해준다. th:object=&quot;$&#123;postDto&#125;&quot; : 서버로부터 받은 데이터를 사용하기 위해서는 $를 붙여서 사용한다. th:field=&quot;*&#123;title&#125;&quot; : 서버로부터 받은 데이터내의 field값을 사용하기 위해서는 *를 붙여서 사용한다. post.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;/fragments/head :: main-head&quot;&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt;&lt;nav th:replace=&quot;/fragments/navbar :: main-nav&quot;&gt;&lt;/nav&gt;&lt;div class=&quot;container col-lg-6 &quot;&gt; &lt;h2&gt;게시글 작성&lt;/h2&gt; &lt;div class=&quot;card&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 20px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; th:action=&quot;@&#123;/post&#125;&quot; th:object=&quot;$&#123;postDto&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;title&#125;&quot; placeholder=&quot;제목을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; th:field=&quot;*&#123;name&#125;&quot; placeholder=&quot;이름을 입력해 주세요.&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px;&quot; th:field=&quot;*&#123;content&#125;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 공통적으로 사용하는 Html header부분을 따로 정의해 구성요소를 나누어 관리한다. head.html 12345678910&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:fragment=&quot;main-head&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;./css/bootstrap.css&#125;&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;./css/custom.min.css&#125;&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; navigation bar의 경우에도 모든 페이지에서 동일하게 사용함으로 fragment형식으로 만들어 사용한다. navbar.html 12345&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;nav th:fragment=&quot;main-nav&quot; class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt;&lt;/nav&gt;&lt;/html&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"스프링부트를 이용한 게시판 만들기 1 - 게시글 작성 페이지","slug":"springboot/sample-board/board-1-init","date":"2021-02-11T07:53:15.000Z","updated":"2021-03-13T11:30:50.155Z","comments":true,"path":"2021/02/11/springboot/sample-board/board-1-init/","link":"","permalink":"https://ckck803.github.io/2021/02/11/springboot/sample-board/board-1-init/","excerpt":"","text":"1. 게시글 작성 페이지 만들기간단하게 게시글 제목, 사용자 이름, 게시글 내용 세가지만 입력 받는 폼을 만들 것이다. 게시글 작성페이지는 Bootstrap을 이용해 만들건데, BootsWatch의 Cosmo navbar가 마음에 들어 이것도 사용할 것이다. 먼저, Bootstrap 사이트에서 css, js, fonts를 다운 받고 BootsWatch사이트 Cosmo 페이지에서 custom.min.css을 다운 받은 후 springboot 프로젝트내의 resources/static위치에 폴더들은 넣는다. Bootstrap 사이트 : https://getbootstrap.com/docs/4.6/getting-started/introduction/Bootswatch 사이트 : https://bootswatch.com/ Post 페이지12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/custom.min.css&quot;&gt; &lt;title&gt;게시글 작성 페이지&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;bg-light&quot;&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-primary fixed-top&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;게시판&lt;/a&gt; &lt;/nav&gt; &lt;!-- &lt;div class=&quot;container bg-white&quot; style=&quot;padding: 20px; border-radius: 15px;&quot;&gt; --&gt; &lt;div class=&quot;card col-lg-6&quot; style=&quot;padding: 20px; border-radius: 15px; margin: 50px auto;&quot;&gt; &lt;form class=&quot; form-horizontal&quot; method=&quot;post&quot; onsubmit=&quot;return registerBoard(this)&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;제목&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;제목을 입력해 주세요.&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;이름&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;이름을 입력해 주세요.&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;내용&lt;/label&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;textarea class=&quot;form-control&quot; style=&quot;height: 300px;&quot; placeholder=&quot;내용을 입력해 주세요.&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;btn_wrap text-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default waves-effect waves-light&quot;&gt;뒤로가기&lt;/a&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary waves-effect waves-light&quot;&gt;저장하기&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 스프링 프로젝트 만들기게시판 만들기 프로젝트를 진행하면서 Thymeleaf라는 템플릿 엔진을 사용할 것이고, 총 7가지 의존성을 사용할 것이다. JPA Thymeleaf Web Lombok Devtools H2 validation build.gradle 123456789101112dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-validation&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125; 게시글 작성 페이지로 이동하기/post경로를 통해 요청이 들어오면 게시글을 작성하는 페이지로 이동시킬 예정이다. 테스트 코드 작성/post경로로 요청이 들어왔을 때 정상적으로 control이 작동하는 경우 ok(status code : 200)을 반환한다. 12345678910111213141516@WebMvcTestclass PostControllerTest &#123; @Autowired MockMvc mockMvc; @Test @DisplayName(&quot;게시글 작성페이지로 이동하는지 확인한다.&quot;) public void movePost() throws Exception&#123; ResultActions resultActions = mockMvc.perform(get(&quot;/post&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); &#125;&#125; control 구현/post경로로 요청이 들어왔을 때 post.html을 반환해 사용자에게 게시글 작성 페이지를 보여준다. 12345678@Controllerpublic class PostController &#123; @GetMapping(&quot;/post&quot;) public String post()&#123; return &quot;post&quot;; &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"}]},{"title":"http-explain","slug":"computer-science/Http/http-explain","date":"2021-02-11T07:50:11.000Z","updated":"2021-02-11T07:50:32.149Z","comments":true,"path":"2021/02/11/computer-science/Http/http-explain/","link":"","permalink":"https://ckck803.github.io/2021/02/11/computer-science/Http/http-explain/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"레스토랑 예약 사이트 만들기 14 - 테이블 예약","slug":"springboot/fastcampus-eatgo/eat-go14-table-reservation","date":"2021-02-07T09:46:44.000Z","updated":"2021-03-13T11:42:46.968Z","comments":true,"path":"2021/02/07/springboot/fastcampus-eatgo/eat-go14-table-reservation/","link":"","permalink":"https://ckck803.github.io/2021/02/07/springboot/fastcampus-eatgo/eat-go14-table-reservation/","excerpt":"","text":"패스트 캠퍼스에서 1234567891011121314151617@RestController@RequiredArgsConstructorpublic class ReservationController &#123; private final ReservationService reservationService; @GetMapping(&quot;/reservations&quot;) public List&lt;Reservation&gt; list(Authentication authentication)&#123; Claims claims = (Claims) authentication.getPrincipal(); Long restaurantId = claims.get(&quot;restaurantId&quot;, Long.class);// Long restaurantId = 1004L; List&lt;Reservation&gt; reservations = reservationService.getReservations(restaurantId); return reservations; &#125;&#125; 12345678910111213141516171819202122232425@WebMvcTest(ReservationController.class)class ReservationControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private ReservationService reservationService; @Test @DisplayName(&quot;예약목록을 가져온다.&quot;) public void list() throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJPd25lciIsInJlc3RhdXJhbnRJZCI6MTAwNH0.cQTXhzTW48F5Nj3eXa80Y9J4OJryzFvoHtT8ELl4kTw&quot;; ResultActions resultActions = mockMvc.perform(get(&quot;/reservations&quot;) .header(&quot;Authorization&quot;, &quot;Bearer &quot; + token)); resultActions .andExpect(status().isOk()); verify(reservationService).getReservations(1004L); &#125;&#125; 123456789@Service@RequiredArgsConstructorpublic class ReservationService &#123; private final ReservationRepository reservationRepository; public List&lt;Reservation&gt; getReservations(Long restaurantId) &#123; return reservationRepository.findAllByRestaurantId(restaurantId); &#125;&#125; 123456789101112131415161718192021222324class ReservationServiceTest &#123; @Mock private ReservationRepository reservationRepository; private ReservationService reservationService; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this); this.reservationService = new ReservationService(reservationRepository); &#125; @Test @DisplayName(&quot;예약목록들을 가져온다.&quot;) public void getReservation()&#123; Long restaurantId = 1004L; List&lt;Reservation&gt; reservations = reservationService.getReservations(restaurantId); verify(reservationRepository).findAllByRestaurantId(restaurantId); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; private final JwtUtil jwtUtil; public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123; super(authenticationManager); this.jwtUtil = jwtUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Authentication authentication = getAuthentication(request); if(authentication != null)&#123; SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125; private Authentication getAuthentication(HttpServletRequest request)&#123; // Header에서 Data를 얻어야 한다. String token = request.getHeader(&quot;Authorization&quot;); if(token == null)&#123; return null; &#125; Claims claims = jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length())); Authentication authentication = new UsernamePasswordAuthenticationToken(claims, null); return authentication; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; Filter filter = new JwtAuthenticationFilter(authenticationManager(), jwtUtil()); http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); http .addFilter(filter) .sessionManagement() // Session을 사용하지 않음 .sessionCreationPolicy(SessionCreationPolicy.STATELESS); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 13 - 인가","slug":"springboot/fastcampus-eatgo/eat-go13-authorization","date":"2021-02-07T03:53:14.000Z","updated":"2021-03-13T11:42:30.392Z","comments":true,"path":"2021/02/07/springboot/fastcampus-eatgo/eat-go13-authorization/","link":"","permalink":"https://ckck803.github.io/2021/02/07/springboot/fastcampus-eatgo/eat-go13-authorization/","excerpt":"","text":"JWT로부터 데이터 가져오기1234567891011121314151617181920212223242526272829public class JwtUtil &#123; private Key key; public JwtUtil(String secret) &#123; this.key = Keys.hmacShaKeyFor(secret.getBytes()); &#125; public String createToken(Long userId, String name) &#123; String token = Jwts.builder() .claim(&quot;userId&quot;, 1004L) .claim(&quot;name&quot;, name) .signWith(key, SignatureAlgorithm.HS256) .compact(); return token; &#125; public Claims getClaims(String token)&#123; Claims claims = Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(token) .getBody(); return claims; &#125;&#125; 123456789@Test@DisplayName(&quot;Claims를 가져온다.&quot;)public void getClaims()&#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJUZXN0ZXIifQ.I4DNdunio2m54tfUEaXHC_E-gvCQo6ZhHO15Ewkat6U&quot;; Claims claims = jwtUtil.getClaims(token); assertThat(claims.get(&quot;userId&quot;, Long.class)).isEqualTo(1004L); assertThat(claims.get(&quot;name&quot;)).isEqualTo(&quot;Tester&quot;);&#125; JWTFilter추가1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; Filter filter = new JwtAuthenticationFilter(authenticationManager(), jwtUtil()); http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); http .addFilter(filter) .sessionManagement() // Session을 사용하지 않음 .sessionCreationPolicy(SessionCreationPolicy.STATELESS); ; &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125; JWT 인증 Filter1234567891011121314151617181920212223242526272829303132333435public class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; private JwtUtil jwtUtil; public JwtAuthenticationFilter(AuthenticationManager authenticationManager, JwtUtil jwtUtil) &#123; super(authenticationManager); this.jwtUtil = jwtUtil; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; Authentication authentication = getAuthentication(request); if(authentication != null)&#123; SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125; private Authentication getAuthentication(HttpServletRequest request)&#123; // Header에서 Data를 얻어야 한다. String token = request.getHeader(&quot;Authorization&quot;); if(token == null)&#123; return null; &#125; Claims claims = jwtUtil.getClaims(token.substring(&quot;Bearer &quot;.length())); Authentication authentication = new UsernamePasswordAuthenticationToken(claims, null); return authentication; &#125;&#125; 요청시 Token값을 가지고 있는지 확인12345678910111213141516171819202122@RestController@RequiredArgsConstructorpublic class ReviewController &#123; private final ReviewService reviewService; @PostMapping(&quot;/restaurants/&#123;restaurantId&#125;/reviews&quot;) public ResponseEntity&lt;?&gt; create( Authentication authentication, @PathVariable Long restaurantId, @Valid @RequestBody Review resource ) throws URISyntaxException &#123; Claims claims = (Claims) authentication.getPrincipal(); String name = claims.get(&quot;name&quot;, String.class); Review review = reviewService.addReview(restaurantId, resource); String url = &quot;/restaurants/&quot; + restaurantId + &quot;/reviews/&quot; + review.getId(); return ResponseEntity.created(new URI (url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; 테스트 코드 작성12345678910111213141516171819202122@Testpublic void 리뷰를_생성한다() throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEwMDQsIm5hbWUiOiJUZXN0ZXIifQ.I4DNdunio2m54tfUEaXHC_E-gvCQo6ZhHO15Ewkat6U&quot;; given(reviewService.addReview(eq(1L), any())).willReturn( Review.builder() .id(1004L) .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build()); mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .header(&quot;Authorization&quot;, &quot;Bearer &quot; + token) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;name\\&quot;:\\&quot;JOKER\\&quot;, \\&quot;score\\&quot;:3,\\&quot;description\\&quot; : \\&quot;Mat-it-da\\&quot;&#125;&quot;)) .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/restaurants/1/reviews/1004&quot;)); verify(reviewService).addReview(eq(1L), any());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 12 - JWT","slug":"springboot/fastcampus-eatgo/eat-go12-jwt","date":"2021-02-06T16:03:35.000Z","updated":"2021-03-13T11:42:22.383Z","comments":true,"path":"2021/02/07/springboot/fastcampus-eatgo/eat-go12-jwt/","link":"","permalink":"https://ckck803.github.io/2021/02/07/springboot/fastcampus-eatgo/eat-go12-jwt/","excerpt":"","text":"JWT를 이용해 AccesToken관리하기JwtUtil 클래스에서는 JWT를 생성하기 위한 createToken메서드가 존재한다. JWT에는 userId와 name을 넣을 것이고 HMAC-SHA256 해싱 알고리즘을 사용해 토큰의 유효성을 검사할 것이다. 123456789101112131415161718192021public class JwtUtil &#123; private String secret; public JwtUtil(String secret) &#123; this.secret = secret; &#125; public String createToken(Long userId, String name) &#123; Key key = Keys.hmacShaKeyFor(secret.getBytes()); String token = Jwts.builder() .claim(&quot;userId&quot;, 1004L) .claim(&quot;name&quot;, name) .signWith(key, SignatureAlgorithm.HS256) .compact(); return token; &#125;&#125; JWT가 올바르게 생성됐는지 확인하는 테스트 코드12345678910class JwtUtilTest &#123; @Test public void createToken()&#123; String secret = &quot;12345678901234567890123456789012&quot;; JwtUtil jwtUtil = new JwtUtil(secret); String token = jwtUtil.createToken(1004L, &quot;&quot;); assertThat(token).contains(&quot;.&quot;); &#125;&#125; JwtUtil을 Bean으로 등록123456789101112131415161718192021222324252627@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; // application.yml에 정의된 JWT Secret값을 가져온다. @Value(&quot;$&#123;jwt.secret&#125;&quot;) private String secret; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Bean public JwtUtil jwtUtil()&#123; return new JwtUtil(secret); &#125;&#125; 사용자 요청 결과로 JWT반환하는 로직을 구현/session 경로로 사용자 정보를 받으면 우선 사용자 유효성을 확인한 뒤, 등록된 사용자인 경우 사용자 정보를 JWT에 일부 담아 Response Body에 넣어 사용자에게 반환한다. 123456789101112131415@PostMapping(&quot;/session&quot;)public ResponseEntity&lt;SessionResponseDto&gt; create(@RequestBody SessionRequestDto resource)&#123; String email = resource.getEmail(); String password = resource.getPassword(); User user = userService.authenticate(email, password); String url = &quot;/session&quot;; String accessToken = jwtUtil.createToken(user.getId(), user.getName()); SessionResponseDto sessionResponseDto = SessionResponseDto.builder() .accessToken(accessToken) .build(); return ResponseEntity.created(URI.create(url)).body(sessionResponseDto);&#125; 사용자 요청에 JWT를 반환하는지 확인하는 테스트 코드 작성1234567891011121314151617181920212223242526272829303132333435363738394041424344@Autowiredprivate ObjectMapper objectMapper;...@MockBeanprivate JwtUtil jwtUtil;@Test@DisplayName(&quot;AccessToken을 반환하는지 확인한다.&quot;)public void create() throws Exception &#123; Long id = 1004L; String email = &quot;tester@example.com&quot;; String password = &quot;test&quot;; String name = &quot;Tester&quot;; User mockUser = User.builder() .id(id) .email(email) .name(name) .password(password) .level(3L) .build(); String content = objectMapper.writeValueAsString(mockUser); given(userService.authenticate(email, password)).willReturn(mockUser); given(jwtUtil.createToken(id, name)).willReturn(&quot;header.payload.signature&quot;); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON)// .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;) .content(content) ); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/session&quot;)) // AccessToken을 사용하는지 확인한다. .andExpect(content().string(containsString(&quot;&#123;\\&quot;accessToken\\&quot;:\\&quot;header.payload.signature\\&quot;&#125;&quot;))); verify(userService).authenticate(eq(email), eq(password));&#125; 123456789101112131415161718192021222324252627@Test@DisplayName(&quot;사용자를 생성한다.&quot;)public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .id(1004L) .email(email) .password(password) .name(name) .build(); given(userService.registerUser(email, name, password)) .willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;tester@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Tester\\&quot;, \\&quot;password\\&quot; : \\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/users/1004&quot;)); verify(userService).registerUser(any(), any(), any());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 11 - 인증","slug":"springboot/fastcampus-eatgo/eat-go11-authentication","date":"2021-02-06T10:17:28.000Z","updated":"2021-03-13T11:42:16.371Z","comments":true,"path":"2021/02/06/springboot/fastcampus-eatgo/eat-go11-authentication/","link":"","permalink":"https://ckck803.github.io/2021/02/06/springboot/fastcampus-eatgo/eat-go11-authentication/","excerpt":"","text":"AccessToken을 이용한 인증12345678910111213141516171819202122@RestController@RequiredArgsConstructorpublic class SessionController &#123; private final UserService userService; @PostMapping(&quot;/session&quot;) public ResponseEntity&lt;SessionResponseDto&gt; create(@RequestBody SessionRequestDto resource)&#123; String email = resource.getEmail(); String password = resource.getPassword(); User user = userService.authenticate(email, password); String url = &quot;/session&quot;; String accessToken = user.getAccessToken(); SessionResponseDto sessionResponseDto = SessionResponseDto.builder() .accessToken(accessToken) .build(); return ResponseEntity.created(URI.create(url)).body(sessionResponseDto); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@WebMvcTest(SessionController.class)class SessionControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;AccessToken을 반환하는지 확인한다.&quot;) public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String password = &quot;test&quot;; User mockUser = User.builder().password(&quot;ACCESSTOKEN&quot;).build(); given(userService.authenticate(email, password)).willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/session&quot;)) // AccessToken을 사용하는지 확인한다. .andExpect(content().string(&quot;&#123;\\&quot;accessToken\\&quot;:\\&quot;ACCESSTOKE\\&quot;&#125;&quot;)); verify(userService).authenticate(eq(email), eq(password)); &#125; @Test @DisplayName(&quot;올바르지 않은 이메일을 이용한 요청을 시도&quot;) public void createWithNotExistedEmail() throws Exception &#123; String email = &quot;x@example.com&quot;; String password = &quot;test&quot;; given(userService.authenticate(email, password)).willThrow(EmailNotExistedException.class); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;x@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isBadRequest()); verify(userService).authenticate(eq(email), eq(password)); &#125; @Test @DisplayName(&quot;올바르지 않은 패스워드를 이용한 요청을 시도&quot;) public void createWithInvalidAttributes() throws Exception &#123; String email = &quot;tester@example.com&quot;; String password = &quot;x&quot;; given(userService.authenticate(email, password)).willThrow(PasswordWrongException.class); ResultActions resultActions = mockMvc.perform(post(&quot;/session&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot;:\\&quot;tester@example.com\\&quot;,\\&quot;password\\&quot;:\\&quot;x\\&quot;&#125;&quot;)); resultActions .andExpect(status().isBadRequest()); verify(userService).authenticate(eq(email), eq(password)); &#125;&#125; 12345public class EmailNotExistedException extends RuntimeException&#123; public EmailNotExistedException()&#123; super(&quot;Email is Not registered&quot;); &#125;&#125; 12345public class PasswordWrongException extends RuntimeException&#123; public PasswordWrongException()&#123; super(&quot;Password is Wrong&quot;); &#125;&#125; 1234567891011121314151617@ControllerAdvicepublic class SessionErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(PasswordWrongException.class) public String handlePasswordWrong()&#123; return &quot;&#123;&#125;&quot;; &#125; @ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(EmailNotExistedException.class) public String handleEmailNotExisted()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; public User registerUser(String email, String name, String password) &#123; // 회원이 이미 등록되어 있는지 Email을 통해 유효성 검사 Optional&lt;User&gt; optional = userRepository.findByEmail(email); // 회원이 이미 존재하는 경우 예외처리를 한다. if(optional.isPresent())&#123; throw new EmailExistedException(email); &#125;// // 패스워드를 암호화해서 저장한다.// // 암호화 방식은 BCrypt방식을 이용해 암호화를 진행// BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125; public User authenticate(String email, String password) &#123; User user = userRepository.findByEmail(email) .orElseThrow(() -&gt; new EmailNotExistedException()); String encodedPassword = passwordEncoder.encode(password); if(!passwordEncoder.matches(password, user.getPassword()))&#123; throw new PasswordWrongException(); &#125; return user; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Test@DisplayName(&quot;올바른 파라미터를 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateWithValidAttributes()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); given(passwordEncoder.matches(any(), any())).willReturn(true); User user = userService.authenticate(email, password); assertThat(user.getEmail()).isEqualTo(email);&#125;@Test@DisplayName(&quot;올바르지 않은 이메일을 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateNotValidEmail()&#123; String email = &quot;x@example.com&quot;; String password = &quot;test&quot;; given(userRepository.findByEmail(email)).willThrow(EmailNotExistedException.class); assertThatThrownBy(()-&gt;&#123; User user = userService.authenticate(email, password); &#125;).isInstanceOf(EmailNotExistedException.class);&#125;@Test@DisplayName(&quot;올바르지 않은 이메일을 이용해 사용자 유효성 검사를 한다.&quot;)public void authenticateNotValidPassword()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;x&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); given(passwordEncoder.matches(password, mockUser.getPassword())).willReturn(false); assertThatThrownBy(()-&gt;&#123; User user = userService.authenticate(email, password); &#125;).isInstanceOf(PasswordWrongException.class);&#125; 123456789101112131415161718@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long Id; @NotEmpty private String email; @NotEmpty private String name; @NotNull private Long level; @NotEmpty private String password; public boolean isAdmin() &#123; return level &gt; 2L; &#125; public void deactivate()&#123; level = 0L; &#125; public boolean isActive() &#123; return level &gt; 0L; &#125; @JsonIgnore public String getAccessToken() &#123; if(password == null)&#123; return &quot;&quot;; &#125; return password.substring(0, 10); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 10 - 회원 가입","slug":"springboot/fastcampus-eatgo/eat-go10-signup","date":"2021-02-06T03:30:41.000Z","updated":"2021-03-13T11:42:11.075Z","comments":true,"path":"2021/02/06/springboot/fastcampus-eatgo/eat-go10-signup/","link":"","permalink":"https://ckck803.github.io/2021/02/06/springboot/fastcampus-eatgo/eat-go10-signup/","excerpt":"","text":"Security 설정하기12345678910111213@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .cors().disable() .csrf().disable() .formLogin().disable() .headers().frameOptions().disable(); &#125;&#125; 12345678910111213141516171819@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; 패스워드에 암호화 하기1234567891011121314151617181920212223@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; // 패스워드를 암호화해서 저장한다. BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; 123456789101112131415161718192021222324252627class UserServiceTest &#123; @Mock private UserRepository userRepository; private UserService userService; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this); userService = new UserService(userRepository); &#125; @Test @DisplayName(&quot;사용자를 등록한다.&quot;) public void registerUser()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User user = userService.registerUser(email, name, password); assertThat(user.getEmail()).isEqualTo(email); assertThat(user.getName()).isEqualTo(name); assertThat(user.getPassword()).isEqualTo(password); verify(userRepository).save(any()); &#125;&#125; 1234567891011121314151617@RestController@RequiredArgsConstructorpublic class UserController &#123; private final UserService userService; @PostMapping(&quot;/users&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody User resource)&#123; String email = resource.getEmail(); String name = resource.getName(); String password = resource.getPassword(); User user = userService.registerUser(email, name, password); String url = &quot;/users/&quot; + user.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738@WebMvcTest(UserController.class)class UserControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;사용자를 생성한다.&quot;) public void create() throws Exception &#123; String email = &quot;tester@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .Id(1004L) .email(email) .password(password) .name(name) .build(); given(userService.registerUser(email, name, password)) .willReturn(mockUser); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;tester@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Tester\\&quot;, \\&quot;password\\&quot; : \\&quot;test\\&quot;&#125;&quot;)); resultActions .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/users/1004&quot;)); verify(userService).registerUser(any(), any(), any()); &#125;&#125; 존재하는 회원에 대한 예외처리12345public class EmailExistedException extends RuntimeException&#123; public EmailExistedException(String email)&#123; super(&quot;Email is already registered: &quot; + email); &#125;&#125; 1234567891011121314151617181920212223242526272829303132@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public User registerUser(String email, String name, String password) &#123; // 회원이 이미 등록되어 있는지 Email을 통해 유효성 검사 Optional&lt;User&gt; optional = userRepository.findByEmail(email); // 회원이 이미 존재하는 경우 예외처리를 한다. if(optional.isPresent())&#123; throw new EmailExistedException(email); &#125; // 패스워드를 암호화해서 저장한다. // 암호화 방식은 BCrypt방식을 이용해 암호화를 진행 BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encodedPassword = passwordEncoder.encode(password); User user = User.builder() .email(email) .name(name) .password(encodedPassword) .level(1L) .build(); userRepository.save(user); return user; &#125;&#125; 123456789101112131415161718192021@Test@DisplayName(&quot;사용자가 이미 등록돼 있는경우 예외처리를 한다.&quot;)public void registerUserWithExistedEmail()&#123; String email = &quot;test@example.com&quot;; String name = &quot;Tester&quot;; String password = &quot;test&quot;; User mockUser = User.builder() .email(email) .name(name) .password(password) .build(); given(userRepository.findByEmail(email)).willReturn(Optional.of(mockUser)); // 예외처리가 발생되는지 확인한다. assertThatThrownBy(() -&gt; &#123; userService.registerUser(email, name, password); &#125;).isInstanceOf(EmailExistedException.class); verify(userRepository).findByEmail(any());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 9 - 사용자 관리","slug":"springboot/fastcampus-eatgo/eat-go9-user","date":"2021-02-05T15:01:54.000Z","updated":"2021-03-13T11:42:03.942Z","comments":true,"path":"2021/02/06/springboot/fastcampus-eatgo/eat-go9-user/","link":"","permalink":"https://ckck803.github.io/2021/02/06/springboot/fastcampus-eatgo/eat-go9-user/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long Id; @NotEmpty private String email; @NotEmpty private String name; @NotNull private Long level; public boolean isAdmin() &#123; return level &gt; 2L; &#125; public void deactivate()&#123; level = 0L; &#125; public boolean isActive() &#123; return level &gt; 0L; &#125;&#125; 123@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435@Service@RequiredArgsConstructorpublic class UserService &#123; private final UserRepository userRepository; public List&lt;User&gt; getUsers() &#123; return userRepository.findAll(); &#125; public User addUser(String email, String name) &#123; User user = User.builder() .email(email) .name(name) .level(1L) .build(); userRepository.save(user); return user; &#125; public User updateUser(Long id, String email, String name, Long level ) &#123; User user = userRepository.findById(id).orElse(null); user.setEmail(email); user.setName(name); user.setLevel(level); return user; &#125; public User deactivateUser(Long userId) &#123; User user = userRepository.findById(userId).orElse(null); user.deactivate(); return user; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class UserServiceTest &#123; @Mock private UserRepository userRepository; private UserService userService; @BeforeEach private void setUp() &#123; MockitoAnnotations.openMocks(this); userService = new UserService(userRepository); &#125; @Test @DisplayName(&quot;유저목록을 가져온다.&quot;) public void getUsers() &#123; List&lt;User&gt; mockUsers = new ArrayList&lt;&gt;(); mockUsers.add(User.builder() .name(&quot;tester&quot;) .email(&quot;test@example.com&quot;) .level(3L) .build()); given(userRepository.findAll()).willReturn(mockUsers); List&lt;User&gt; users = userService.getUsers(); User user = users.get(0); assertThat(user.getName()).isEqualTo(&quot;tester&quot;); assertThat(user.getEmail()).isEqualTo(&quot;test@example.com&quot;); &#125; @Test @DisplayName(&quot;유저를 추가한다.&quot;) public void addUser()&#123; String email = &quot;test@example.com&quot;; String name = &quot;tester&quot;; User mockUser = User.builder() .name(name) .email(email) .build(); given(userRepository.save(any())).willReturn(mockUser); User user = userService.addUser(email, name); assertThat(user.getName()).isEqualTo(name); assertThat(user.getEmail()).isEqualTo(email); &#125; @Test @DisplayName(&quot;유저를 업데이트 한다.&quot;) public void updateUser()&#123; Long id = 1004L; Long level = 3L; String email = &quot;test@example.com&quot;; String name = &quot;Superman&quot;; User mockUser = User.builder() .Id(id) .name(&quot;Administrator&quot;) .level(1L) .email(email) .build(); given(userRepository.findById(id)).willReturn(Optional.of(mockUser)); User user = userService.updateUser(id, email, name, level); verify(userRepository).findById(id); assertThat(user.getName()).isEqualTo(&quot;Superman&quot;); assertThat(user.isAdmin()).isEqualTo(true); &#125; @Test @DisplayName(&quot;유저를 삭제한다.&quot;) public void deactiveUser()&#123; Long id = 1004L; Long level = 2L; String email = &quot;test@example.com&quot;; String name = &quot;Superman&quot;; User mockUser = User.builder() .Id(id) .level(level) .email(email) .name(name) .build(); given(userRepository.findById(id)).willReturn(Optional.of(mockUser)); User user = userService.deactivateUser(1004L); verify(userRepository).findById(1004L); assertThat(user.isAdmin()).isEqualTo(false); assertThat(user.isActive()).isEqualTo(false); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435@RestController@RequiredArgsConstructorpublic class UserController &#123; // 1. User list // 2. User create -&gt; 회원가입 // 3. User update // 4. User delete -&gt; level: 0 =&gt; 아무것도 못 함. // (1: customer 2: restaurant owner 3: admin) private final UserService userService; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; list()&#123; return userService.getUsers(); &#125; @PostMapping(&quot;/users&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody User resource) throws URISyntaxException &#123; User user = userService.addUser(resource.getEmail(), resource.getName()); String url = &quot;/users&quot; + user.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125; @PatchMapping(&quot;/users/&#123;userId&#125;&quot;) public void udpate(@PathVariable(&quot;userId&quot;) Long id, @RequestBody User user)&#123; userService.updateUser(id, user.getEmail(), user.getName(), user.getLevel()); &#125; @DeleteMapping(&quot;/users/&#123;userId&#125;&quot;) public String deactivate(@PathVariable(&quot;userId&quot;)Long userId)&#123; userService.deactivateUser(userId); return &quot;&#123;&#125;&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@WebMvcTest(UserController.class)class UserControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private UserService userService; @Test @DisplayName(&quot;유저목록을_가져온다&quot;) public void list() throws Exception &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(User.builder() .email(&quot;tester@example.com&quot;) .name(&quot;tester&quot;) .level(1L) .build()); given(userService.getUsers()).willReturn(users); mockMvc.perform(get(&quot;/users&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;tester&quot;))); &#125; @Test @DisplayName(&quot;유저를 추가한다.&quot;) public void create() throws Exception &#123; String email = &quot;admin@example.com&quot;; String name = &quot;Administrator&quot;; User user = User.builder() .email(email) .name(name) .build(); given(userService.addUser(email, name)).willReturn(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;email\\&quot; : \\&quot;admin@example.com\\&quot;, \\&quot;name\\&quot; : \\&quot;Administrator\\&quot;&#125;&quot;)); verify(userService).addUser(email, name) ; resultActions .andExpect(status().isCreated()); &#125; @Test @DisplayName(&quot;유저상태를 업데이트 한다&quot;) public void update() throws Exception &#123; Long id = 1004L; String email = &quot;admin@example.com&quot;; String name = &quot;Administrator&quot;; Long level = 3L; User user = User.builder() .email(email) .name(name) .level(level) .build(); given(userService.updateUser(id, email, name, level)).willReturn(user); ResultActions resultActions = mockMvc.perform(patch(&quot;/users/1004&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;level\\&quot;: 3&quot; + &quot;,\\&quot;email\\&quot; : \\&quot;admin@example.com\\&quot;&quot; + &quot;, \\&quot;name\\&quot; : \\&quot;Administrator\\&quot;&#125;&quot;)); verify(userService).updateUser(eq(id), eq(email), eq(name), eq(level)); resultActions .andExpect(status().isOk()); &#125; @Test @DisplayName(&quot;유저를 삭제한다.&quot;) public void deactivate() throws Exception &#123; mockMvc.perform(delete(&quot;/users/1004&quot;)) .andExpect(status().isOk()); verify(userService).deactivateUser(1004L); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 8 - 가게목록 필터링","slug":"springboot/fastcampus-eatgo/eat-go8-category","date":"2021-02-05T03:21:36.000Z","updated":"2021-03-13T11:41:53.988Z","comments":true,"path":"2021/02/05/springboot/fastcampus-eatgo/eat-go8-category/","link":"","permalink":"https://ckck803.github.io/2021/02/05/springboot/fastcampus-eatgo/eat-go8-category/","excerpt":"","text":"123456789101112@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Region &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;&#125; 123@Repositorypublic interface RegionRepository extends JpaRepository&lt;Region,Long&gt; &#123;&#125; 123456789@Service@RequiredArgsConstructorpublic class RegionService &#123; private final RegionRepository regionRepository; public List&lt;Region&gt; getRegions() &#123; return regionRepository.findAll(); &#125;&#125; 123456789@Service@RequiredArgsConstructorpublic class RegionService &#123; private final RegionRepository regionRepository; public List&lt;Region&gt; getRegions() &#123; return regionRepository.findAll(); &#125;&#125; 12345678910111213141516171819202122232425262728class RegionServiceTest &#123; private RegionService regionService; @Mock private RegionRepository regionRepository; @BeforeEach public void setUp()&#123; MockitoAnnotations.openMocks(this ); regionService = new RegionService(regionRepository); &#125; @Test public void 지역정보들을_가져온다() &#123; List&lt;Region&gt; mockRegions = new ArrayList&lt;&gt;(); mockRegions.add(Region.builder() .name(&quot;Seoul&quot;) .build()); given(regionRepository.findAll()).willReturn(mockRegions); List&lt;Region&gt; regions = regionService.getRegions(); Region region = regions.get(0); assertThat(region.getName()).isEqualTo(&quot;Seoul&quot;); &#125;&#125; 123456789101112@RestController@RequiredArgsConstructorpublic class RegionController &#123; private final RegionService regionService; @GetMapping(&quot;/regions&quot;) public List&lt;Region&gt; list()&#123; List&lt;Region&gt; regions = regionService.getRegions(); return regions; &#125;&#125; 123456789101112131415161718192021@WebMvcTest(RegionController.class)class RegionControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private RegionService regionService; @Test public void 지역목록들을_가져온다() throws Exception &#123; List&lt;Region&gt; regions = new ArrayList&lt;&gt;(); regions.add(Region.builder().name(&quot;Seoul&quot;).build()); given(regionService.getRegions()).willReturn(regions); mockMvc.perform(get(&quot;/regions&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Seoul&quot;))); &#125;&#125; 카테고리 만들기123456789101112@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Category &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) public Long id; public String name;&#125; 12345678910111213141516@Service@RequiredArgsConstructorpublic class CategoryService &#123; private final CategoryRepository categoryRepository; public List&lt;Category&gt; getCategories() &#123; List&lt;Category&gt; categories = categoryRepository.findAll(); return categories; &#125; public Category addCategory(String name) &#123; Category category = Category.builder().name(name).build(); categoryRepository.save(category); return category; &#125;&#125; 123456789101112131415161718192021222324@RestController@RequiredArgsConstructorpublic class CategoryController &#123; @Autowired private final CategoryService categoryService; @GetMapping(&quot;/categories&quot;) public List&lt;Category&gt; list()&#123; List&lt;Category&gt; categories = categoryService.getCategories(); return categories; &#125; @PostMapping(&quot;/categories&quot;) public ResponseEntity&lt;?&gt; create(@RequestBody Category resource)&#123; String name = resource.getName(); Category category = categoryService.addCategory(name); String url = &quot;/categories&quot; + category.getId(); return ResponseEntity.created(URI.create(url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738@WebMvcTest(CategoryController.class)class CategoryControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private CategoryService categoryService; @Test public void 카테고리들_가져오기() throws Exception &#123; List&lt;Category&gt; categories = new ArrayList&lt;&gt;(); categories.add(Category.builder() .name(&quot;Korean Food&quot;) .build()); given(categoryService.getCategories()).willReturn(categories); mockMvc.perform(get(&quot;/categories&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Korean Food&quot;))); &#125; @Test public void 카테고리_생성하기() throws Exception &#123; Category category = Category.builder() .name(&quot;Korean Food&quot;) .build(); given(categoryService.addCategory(&quot;Korean Food&quot;)).willReturn(category); mockMvc.perform(post(&quot;/categories&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123; \\&quot;name\\&quot; :\\&quot;Korean Food\\&quot; &#125;&quot;)) .andExpect(status().isCreated()) .andExpect(content().string(&quot;&#123;&#125;&quot;)); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435class CategoryServiceTest &#123; private CategoryService categoryService; @Mock private CategoryRepository categoryRepository; @BeforeEach public void setUp() &#123; MockitoAnnotations.openMocks(this); categoryService = new CategoryService(categoryRepository); &#125; @Test public void 카테고리_목록을_가져온다() &#123; List&lt;Category&gt; mockCategories = new ArrayList&lt;&gt;(); mockCategories.add(Category.builder() .name(&quot;Korean Food&quot;) .build()); given(categoryRepository.findAll()).willReturn(mockCategories); List&lt;Category&gt; categories = categoryService.getCategories(); Category category = categories.get(0); assertThat(category.getName()).isEqualTo(&quot;Korean Food&quot;); &#125; @Test public void 카테고리를_추가한다()&#123; Category category = categoryService.addCategory(&quot;Korean Food&quot;); verify(categoryRepository).save(any()); assertThat(category.getName()).isEqualTo(&quot;Korean Food&quot;); &#125;&#125; Request Parameter를 이용한 요청이 들어오는 경우1234public List&lt;Restaurant&gt; getRestaurants(String region) &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAllByAddressContaining(region); return restaurants;&#125; 123456@Testpublic void 모든_레스토랑을_가져온다() &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(&quot;Seoul&quot;); Restaurant restaurant = restaurants.get(0); assertThat(restaurant.getId()).isEqualTo(1004L);&#125; 12345@GetMapping(&quot;/restaurants&quot;)public List&lt;Restaurant&gt; list(@RequestParam(&quot;region&quot;) String region) &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region); return restaurants;&#125; 12345678910111213141516171819@Testpublic void list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Testpublic void RequestHeader를_이용한_list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125;```java@Testpublic void 새로운_레스토랑_저장_및_조회하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .name(BobZip) .address(Seoul) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions postResultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); postResultActions .andExpect(status().isCreated()) .andDo(print()); List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(restaurant); given(restaurantService.getRestaurants(&quot;Seoul&quot;)).willReturn(restaurants); ResultActions getResultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&quot;)); getResultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$[0].name&quot;).value(BobZip)) .andExpect(jsonPath(&quot;$[0].address&quot;).value(Seoul)) .andDo(print());&#125; 1234567891011121314private void mockRestaurantRepository() &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); Restaurant restaurant = Restaurant.builder() .id(1004L) .address(&quot;Seoul&quot;) .name(&quot;Bob zip&quot;) .build(); restaurants.add(restaurant); given(restaurantRepository.findAllByAddressContaining(&quot;Seoul&quot;)).willReturn(restaurants); given(restaurantRepository.findById(1004L)) .willReturn(Optional.of(restaurant));&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 7 - 멀티모듈","slug":"springboot/fastcampus-eatgo/eat-go7-multimodule","date":"2021-02-04T17:42:22.000Z","updated":"2021-03-13T11:41:48.498Z","comments":true,"path":"2021/02/05/springboot/fastcampus-eatgo/eat-go7-multimodule/","link":"","permalink":"https://ckck803.github.io/2021/02/05/springboot/fastcampus-eatgo/eat-go7-multimodule/","excerpt":"","text":"123456789101112131415dependencies &#123; implementation project(&#x27;:eatgo-common&#x27;) implementation &#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27; implementation &#x27;org.springframework.boot:spring-boot-starter-web&#x27; // https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation implementation &#x27;org.springframework.boot:spring-boot-starter-validation&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; developmentOnly &#x27;org.springframework.boot:spring-boot-devtools&#x27; runtimeOnly &#x27;com.h2database:h2&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27;&#125; 1234567jar &#123; enabled = true&#125;bootJar &#123; enabled = false&#125; 12345678910111213@Testpublic void 레스토랑에_해당되는_메뉴들을_반환한다() &#123; List&lt;MenuItem&gt; mockMenuItems = new ArrayList&lt;&gt;(); mockMenuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(mockMenuItems); List&lt;MenuItem&gt; menuItems = menuItemService.getMenuItems(1004L); MenuItem menuItem = menuItems.get(0); assertThat(menuItem.getName()).isEqualTo(&quot;Kimchi&quot;);&#125; 123public List&lt;MenuItem&gt; getMenuItems(Long restaurantId) &#123; return menuItemRepository.findAllByRestaurantId(restaurantId);&#125; 리뷰 정보 가져오기12345@GetMapping(&quot;/reviews&quot;)public List&lt;Review&gt; list()&#123; List&lt;Review&gt; reviews = reivewService.getReviews(); return reviews;&#125; 12345678910111213@Testpublic void 레스토랑에_해당되는_리뷰들을_가져온다() throws Exception &#123; List&lt;Review&gt; mockReviews = new ArrayList&lt;&gt;(); mockReviews.add(Review.builder() .description(&quot;Cool!&quot;) .build()); given(reviewService.getReviews()).willReturn(mockReviews); mockMvc.perform(get(&quot;/reviews&quot;)) .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;Cool!&quot;)));&#125; 123public List&lt;Review&gt; getReviews() &#123; return reviewRepository.findAll();&#125; 1234567891011121314@Testpublic void 리뷰들을_가져온다()&#123; List&lt;Review&gt; mockReviews = new ArrayList&lt;&gt;(); mockReviews.add(Review.builder() .description(&quot;Cool!&quot;) .build()); given(reviewRepository.findAll()).willReturn(mockReviews); List&lt;Review&gt; reviews = reviewService.getReviews(); Review review = reviews.get(0); assertThat(review.getDescription()).isEqualTo(&quot;Cool!&quot;);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 6 - 리뷰 기능","slug":"springboot/fastcampus-eatgo/eat-go6-review","date":"2021-02-04T06:17:44.000Z","updated":"2021-03-13T11:41:41.391Z","comments":true,"path":"2021/02/04/springboot/fastcampus-eatgo/eat-go6-review/","link":"","permalink":"https://ckck803.github.io/2021/02/04/springboot/fastcampus-eatgo/eat-go6-review/","excerpt":"","text":"새로운 리뷰 생성 오청을 처리하기 위한 control1234567891011121314151617@RestController@RequiredArgsConstructorpublic class ReviewController &#123; private final ReviewService reivewService; @PostMapping(&quot;/restaurants/&#123;restaurantId&#125;/reviews&quot;) public ResponseEntity&lt;?&gt; create( @PathVariable Long restaurantId, @Valid @RequestBody Review resource ) throws URISyntaxException &#123; Review review = reivewService.addReview(restaurantId, resource); String url = &quot;/restaurants/&quot; + restaurantId + &quot;/reviews/&quot; + review.getId(); return ResponseEntity.created(new URI (url)).body(&quot;&#123;&#125;&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829@WebMvcTest(ReviewController.class)class ReviewControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private ReviewService reviewService; @Test public void 리뷰를_생성한다() throws Exception &#123; given(reviewService.addReview(eq(1L), any())).willReturn( Review.builder() .id(1004L) .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build()); mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;\\&quot;name\\&quot;:\\&quot;JOKER\\&quot;, \\&quot;score\\&quot;:3,\\&quot;description\\&quot; : \\&quot;Mat-it-da\\&quot;&#125;&quot;)) .andExpect(status().isCreated()) .andExpect(header().string(&quot;location&quot;, &quot;/restaurants/1/reviews/1004&quot;)); verify(reviewService).addReview(eq(1L), any()); &#125;&#125; Review 도메인 객체를 생성1234567891011121314151617181920212223242526@Entity@Builder@NoArgsConstructor@AllArgsConstructor@Getter@Setterpublic class Review &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull private Long restaurantId; @NotEmpty private String name; @NotNull private Integer score; @NotEmpty private String description;&#125; Review를 저장하기 위한 Repository 생성1234@Repositorypublic interface ReviewRepository extends JpaRepository&lt;Review, Long&gt; &#123; List&lt;Review&gt; findAllByRestaurantId(Long restaurantId);&#125; Review Service 클래스를 생성한다.1234567891011@Service@RequiredArgsConstructorpublic class ReviewService &#123; private final ReviewRepository reviewRepository; public Review addReview(Long restaurantId, Review review) &#123; review.setRestaurantId(restaurantId); reviewRepository.save(review); return review; &#125;&#125; 서비스 클래스를 테스트하기 위한 테스트 코드 작성123456789101112131415161718192021222324252627class ReviewServiceTest &#123; @Mock private ReviewRepository reviewRepository; private ReviewService reviewService; @BeforeEach public void setUp()&#123; MockitoAnnotations.initMocks(this); reviewService = new ReviewService(reviewRepository); &#125; @Test public void 리뷰를_추가한다()&#123; Review review = Review.builder() .name(&quot;JOKER&quot;) .score(3) .description(&quot;Mat-it-da&quot;) .build(); reviewService.addReview(1004L, review); verify(reviewRepository).save(any()); &#125;&#125; 올바르지 않는 리뷰 요청에 대한 예외처리를 위한 테스트 코드 작성123456789@Testpublic void 올바르지_않는_리뷰생성_요청() throws Exception &#123; mockMvc.perform(post(&quot;/restaurants/1/reviews&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;&#123;&#125;&quot;)) .andExpect(status().isBadRequest()); verify(reviewService, never()).addReview(1004L, any());&#125; Restaurant 서비스 클래스내에 review 컨텐츠123456789101112131415161718public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; Restaurant restaurant = optional.get(); // 해당 restaurant id값을 갖는 모든 Menu들을 가져온다. List&lt;MenuItem&gt; menuItems = menuItemRepository.findAllByRestaurantId(id); restaurant.setMenuItems(menuItems); // 해당 restaurant id값을 갖는 모든 review들을 가져온다. List&lt;Review&gt; reviews = reviewRepository.findAllByRestaurantId(id); restaurant.setReviews(reviews); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125;&#125; 테스트 코드 작성123456789101112131415161718192021@Testpublic void 특정_레스토랑을_가져온다() &#123; Restaurant restaurant = restaurantService.getRestaurant(1004L); // 레스토랑 정보를 가져오는지 확인한다. verify(restaurantRepository).findById(eq(1004L)); // 메뉴정보도 가져오는지 확인한다. verify(menuItemRepository).findAllByRestaurantId(eq(1004L)); // 리뷰정보도 가져오는지 확인한다. verify(reviewRepository).findAllByRestaurantId(eq(1004L)); // 가져온 정보들을 확인한다. // 레스토랑 정보를 확인한다. assertThat(restaurant.getId()).isEqualTo(1004L); // 메뉴정보들을 확인한다. MenuItem menuItem = restaurant.getMenuItems().get(0); assertThat(menuItem.getName()).isEqualTo(&quot;Kimchi&quot;); // 리뷰정보들을 확인한다. Review review = restaurant.getReviews().get(0); assertThat(review.getDescription()).isEqualTo(&quot;Bad&quot;);&#125; 레스토랑 요청에서 Review정보가 조회되는지 확인하는 테스트 코드 작성123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void 특정_가게_상세정보를_가져온다() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build(); // 메뉴 정보를 생성 MenuItem menuItem = MenuItem.builder() .name(&quot;Kimchi&quot;) .build(); // 리뷰 정보를 생성 Review review = Review.builder() .name(&quot;JOKER&quot;) .score(5) .description(&quot;Great!&quot;) .build(); // 레스토랑 객체에 메뉴 정보들을 저장한다. restaurant.setMenuItems(Arrays.asList(menuItem)); // 레스토랑 객체에 리뷰 정보들을 저장한다. restaurant.setReviews(Arrays.asList(review)); given(restaurantService.getRestaurant(1004L)).willReturn(restaurant); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/1004&quot;)); resultActions .andExpect(status().isOk()) // 레스토랑 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) // 메뉴 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;Kimchi&quot;))) // 리뷰 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;Great!&quot;))) .andDo(print());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 5 - 메뉴 관리","slug":"springboot/fastcampus-eatgo/eat-go5-menuitems","date":"2021-02-04T03:27:21.000Z","updated":"2021-03-13T11:41:36.089Z","comments":true,"path":"2021/02/04/springboot/fastcampus-eatgo/eat-go5-menuitems/","link":"","permalink":"https://ckck803.github.io/2021/02/04/springboot/fastcampus-eatgo/eat-go5-menuitems/","excerpt":"","text":"메뉴를 추가하는 요청을 처리하기 위한 control123456789101112@RestController@RequiredArgsConstructorpublic class MenuItemController &#123; private final MenuItemService menuItemService; @PatchMapping(&quot;/restaurants/&#123;restaurantId&#125;/menuitems&quot;) public String buikUpdate()&#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItemService.bulkUpdate(menuItems); return &quot;&quot;; &#125;&#125; 123456789101112131415161718192021@WebMvcTest(MenuItemController.class)class MenuItemControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private MenuItemService menuItemService; @Test public void bulkUpdate() throws Exception &#123; ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1/menuitems&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;[]&quot;)); resultActions .andExpect(status().isOk()); verify(menuItemService).bulkUpdate(any()); &#125;&#125; 123456789101112@Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829class MenuItemServiceTest &#123; private MenuItemService menuItemService; @Mock private MenuItemRepository menuItemRepository; @BeforeEach public void setUp()&#123; MockitoAnnotations.initMocks(this); menuItemService = new MenuItemService(menuItemRepository); &#125; @Test public void bulkUpdate() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any());; &#125;&#125; 메뉴 삭제 요청1234567891011121314151617181920@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125; 1234567891011121314151617181920@Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; updateOrDeleteMenuItems(restaurantId, menuItem); &#125; &#125; private void updateOrDeleteMenuItems(Long restaurantId, MenuItem menuItem) &#123; if(menuItem.isDestroy())&#123; menuItemRepository.deleteById(menuItem.getId()); &#125;else &#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; 12345678910111213141516171819@Testpublic void 메뉴를_삭제한다() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItems.add(MenuItem.builder() .id(1004L) .destroy(true) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any()); verify(menuItemRepository, times(1)).deleteById(eq(1004L));&#125; 123456789101112131415161718192021@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient @JsonInclude(JsonInclude.Include.NON_DEFAULT) private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 4 - 예외 처리","slug":"springboot/fastcampus-eatgo/eat-go4-exception","date":"2021-02-04T00:37:02.000Z","updated":"2021-03-13T11:41:31.114Z","comments":true,"path":"2021/02/04/springboot/fastcampus-eatgo/eat-go4-exception/","link":"","permalink":"https://ckck803.github.io/2021/02/04/springboot/fastcampus-eatgo/eat-go4-exception/","excerpt":"","text":"없는 페이지 요청에 대한 예외처리123456789@Testpublic void 없는_페이지에대한_예외처리를_한다() throws Exception&#123; given(restaurantService.getRestaurant(404L)).willThrow(new RestaurantNotFoundException(404L)); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/404&quot;)); resultActions .andExpect(status().isNotFound()) .andExpect(content().string(&quot;&#123;&#125;&quot;));&#125; 12345public class RestaurantNotFoundException extends RuntimeException&#123; public RestaurantNotFoundException(Long id) &#123; super(&quot;Could not find Restaurant&quot; + id ); &#125;&#125; 12345678910@ControllerAdvicepublic class RestaurantErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(RestaurantNotFoundException.class) public String handleNotFound()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125; Service 계층에서의 예외처리1234567@Testpublic void 없는_레스토랑을_가져온다() &#123; assertThatThrownBy(() -&gt; &#123; Restaurant restaurant = restaurantService.getRestaurant(404L); &#125;).isInstanceOf(RestaurantNotFoundException.class);// Restaurant restaurant = restaurantService.getRestaurant(404L);&#125; 123456789101112public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; List&lt;MenuItem&gt; menuItems = menuItemRepository.findAllByRestaurantId(id); Restaurant restaurant = new Restaurant(); restaurant.setMenuItems(menuItems); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"},{"name":"Exception Handling","slug":"Exception-Handling","permalink":"https://ckck803.github.io/tags/Exception-Handling/"}]},{"title":"레스토랑 예약 사이트 만들기 3","slug":"springboot/fastcampus-eatgo/eat-go-client","date":"2021-02-03T15:59:58.000Z","updated":"2021-03-13T11:41:25.000Z","comments":true,"path":"2021/02/04/springboot/fastcampus-eatgo/eat-go-client/","link":"","permalink":"https://ckck803.github.io/2021/02/04/springboot/fastcampus-eatgo/eat-go-client/","excerpt":"","text":"123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;Hello, world!&lt;/div&gt;&lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910(async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = JSON.stringify(restaurants);&#125;)(); 12345678910111213(async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = ` $&#123;restaurants[0].id&#125; $&#123;restaurants[0].name&#125; `&#125;)(); 123456789101112131415161718(async () =&gt; &#123; const url = &quot;http://localhost:8080/restaurants&quot;; const response = await fetch(url); const restaurants = await response.json(); console.log(restaurants); const element = document.getElementById(&#x27;app&#x27;); element.innerHTML = ` $&#123;restaurants.map(restaurant =&gt; ` &lt;p&gt; $&#123;restaurant.id&#125; $&#123;restaurant.name&#125; $&#123;restaurant.address&#125; &lt;/p&gt; `).join(&#x27;&#x27;)&#125; `;&#125;)();","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 만들기 2 - 메뉴 정보 추가(관리자)","slug":"springboot/fastcampus-eatgo/2. menuitem/eat-go2-restaurant","date":"2021-02-03T04:46:52.000Z","updated":"2021-03-13T11:43:40.835Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/2. menuitem/eat-go2-restaurant/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/2.%20menuitem/eat-go2-restaurant/","excerpt":"","text":"레스토랑에 메뉴정보를 담기123456789101112131415161718192021222324252627282930313233343536@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Restaurant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull private Long categoryId; @NotEmpty private String name; @NotEmpty private String address; @Transient @JsonInclude(JsonInclude.Include.NON_NULL) private List&lt;MenuItem&gt; menuItems; public void addMenuItem(MenuItem menuItem)&#123; menuItems.add(menuItem); &#125; public void setMenuItems(List&lt;MenuItem&gt; menuItems)&#123; this.menuItems = new ArrayList&lt;&gt;(menuItems); &#125; public String getInformation()&#123; return name + &quot; in &quot; + address; &#125;&#125; 메뉴에 대한 정보를 담고있는 MenuItem 클래스1234567891011121314151617181920@Builder@Entity@Setter@Getter@NoArgsConstructor@AllArgsConstructorpublic class MenuItem &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long restaurantId; private String name; @Transient @JsonInclude(JsonInclude.Include.NON_DEFAULT) private boolean destroy; public MenuItem(String name)&#123; this.name = name; &#125;&#125; 레스토랑에서 메뉴정보 가져오기123public interface MenuItemRepository extends JpaRepository&lt;MenuItem, Long&gt; &#123; List&lt;MenuItem&gt; findAllByRestaurantId(Long restaurantId);&#125; 레스토랑에 메뉴등록 요청 보내기추가하고자 하는 데이터는 Http Body에 넣어서 보낸다. 123456789101112@RestController@RequiredArgsConstructorpublic class MenuItemController &#123; private final MenuItemService menuItemService; @PatchMapping(&quot;/restaurants/&#123;restaurantId&#125;/menuitems&quot;) public String bulkUpdate(@PathVariable Long restaurantId , @RequestBody List&lt;MenuItem&gt; menuItems)&#123; menuItemService.bulkUpdate(restaurantId, menuItems); return &quot;&quot;; &#125;&#125; 레스토랑 메뉴등록 요청에 대한 테스트 코드123456789101112131415161718192021@WebMvcTest(MenuItemController.class)class MenuItemControllerTest &#123; @Autowired private MockMvc mockMvc; @MockBean private MenuItemService menuItemService; @Test public void bulkUpdate() throws Exception &#123; ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1/menuitems&quot;) .contentType(MediaType.APPLICATION_JSON) .content(&quot;[]&quot;)); resultActions .andExpect(status().isOk()); verify(menuItemService).bulkUpdate(eq(1L), any()); &#125;&#125; 레스토랑 정보를 가져와 메뉴정보 넣기1234567891011121314151617181920@Service@RequiredArgsConstructorpublic class MenuItemService &#123; private final MenuItemRepository menuItemRepository; public void bulkUpdate(Long restaurantId, List&lt;MenuItem&gt; menuItems) &#123; for(MenuItem menuItem : menuItems)&#123; updateOrDeleteMenuItems(restaurantId, menuItem); &#125; &#125; private void updateOrDeleteMenuItems(Long restaurantId, MenuItem menuItem) &#123; if(menuItem.isDestroy())&#123; menuItemRepository.deleteById(menuItem.getId()); &#125;else &#123; menuItem.setRestaurantId(restaurantId); menuItemRepository.save(menuItem); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334@Testpublic void bulkUpdate() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any());&#125;@Testpublic void 메뉴를_삭제한다() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add(MenuItem.builder() .name(&quot;Kimchi&quot;) .build()); menuItems.add(MenuItem.builder() .name(&quot;Gukbob&quot;) .build()); menuItems.add(MenuItem.builder() .id(1004L) .destroy(true) .build()); menuItemService.bulkUpdate(1L, menuItems); verify(menuItemRepository, times(2)).save(any()); verify(menuItemRepository, times(1)).deleteById(eq(1004L));&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(사용자) 레스토랑 정보 가져오기","slug":"springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-customer","date":"2021-02-03T01:20:02.000Z","updated":"2021-03-13T11:43:34.587Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-customer/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-customer/","excerpt":"","text":"사용자 페이지사용자의 경우 레스토랑을 관리하지 않으므로 레스토랑 정보를 추가하거나 수정할필요는 없고 조회하는 기능만 있으면 된다. 모든 Restaurant정보 가져오기 특정 Restaurant정보 가져오기 Request Parameter를 통한 레스토랑 조회 control요청시 RequestParameter를 통해 원하는 지역, 카테고리를 통해 해당 조건을 만족하는 레스토랑 정보를 모두 가져올 수 있도록 한다. 특정 Restaurant 정보를 가져오는 함수들은 관리자에서 만들었던 내용과 같으므로 생각한다. 123456789101112131415161718@CrossOrigin@RestController@RequiredArgsConstructorpublic class RestaurantController &#123; private final RestaurantService restaurantService; @GetMapping(&quot;/restaurants&quot;) public List&lt;Restaurant&gt; list(@RequestParam(&quot;region&quot;) String region, @RequestParam(&quot;category&quot;) Long category) &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region, category); return restaurants; &#125; @GetMapping(&quot;/restaurants/&#123;id&#125;&quot;) public Restaurant detail(@PathVariable Long id) throws Exception &#123; Restaurant restaurant = restaurantService.getRestaurant(id); return restaurant; &#125;&#125; Request Parameter를 통한 레스토랑 조회 테스트 코드 작성1234567891011121314151617181920@Testpublic void RequestParameter를_이용한_list를_확인한다() throws Exception &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(Restaurant.builder() .id(1004L) .categoryId(1L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build()); given(restaurantService.getRestaurants(&quot;Seoul&quot;, 1L)).willReturn(restaurants); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants?region=Seoul&amp;category=1&quot;)); resultActions .andExpect(status().isOk()) .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;))) .andDo(print());&#125; Service에서 Region과 CategoryId를 이용한 조회 메소드 구현control로부터 받은 region과 categoryId를 갖고 해당 조건을 만족하는 레스토랑 정보를 가져와 반환한다. 만약 레스토랑 정보가 없다고 하면 RestaurantNotFoundException예외를 일으킨다. 12345678910111213141516171819202122@Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; public List&lt;Restaurant&gt; getRestaurants(String region, long categoryId) &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAllByAddressContainingAndCategoryId(region, categoryId); return restaurants; &#125; public Restaurant getRestaurant(Long id) &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; Restaurant restaurant = optional.get(); return restaurant; &#125;else&#123; throw new RestaurantNotFoundException(id); &#125; &#125;&#125; 123456public List&lt;Restaurant&gt; getRestaurants(String region, long categoryId) &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAllByAddressContainingAndCategoryId(region, categoryId); return restaurants;&#125; Repository에 method추가1234@Repositorypublic interface RestaurantRepository extends JpaRepository&lt;Restaurant, Long&gt; &#123; List&lt;Restaurant&gt; findAllByAddressContainingAndCategoryId(String region, long categoryId);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 레스토랑 정보 업데이트","slug":"springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-update","date":"2021-02-03T00:22:02.000Z","updated":"2021-03-13T11:43:20.504Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-update/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin-update/","excerpt":"","text":"4. 레스토랑 정보 업데이트레스토랑 업데이트 하기 위한 control 추가레스토랑 정보를 업데이트 하기 위해서는 업데이트 하고자 하는 레스토랑을 가지고 와야 한다. /restaurants경로뒤에 레스토랑 id를 붙여 요청이 들어오면 id를 이용해 레스토랑을 찾고 request body에 들어있는 정보로 레스토랑을 업데이트 한다. 업데이트 요청을 처리하기 위해 Http 메소드 중에서 patch메소드를 이용할 것이다. 123456@PatchMapping(&quot;/restaurants/&#123;id&#125;&quot;)public String update(@PathVariable(&quot;id&quot;) Long id, @RequestBody Restaurant restaurant) throws Exception &#123; restaurantService.updateRestaurant(id, restaurant.getName(), restaurant.getAddress()); return &quot;&#123;&#125;&quot;;&#125; 업데이트 요청에 대한 테스트 코드 작성1234567891011121314151617181920212223@Testpublic void 레스토랑정보_업데이트() throws Exception &#123; String JOKER = &quot;JOKER Bar&quot;; String Busan = &quot;Busan&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(JOKER) .address(Busan) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions resultActions = mockMvc.perform(patch(&quot;/restaurants/1004&quot;) .contentType(MediaType.APPLICATION_JSON) .content(content)); resultActions .andExpect(status().isOk()) .andDo(print()); verify(restaurantService).updateRestaurant(1004L, JOKER, Busan);&#125; 레스토랑 업데이트를 하기 위한 Service 메소드먼저 id를 갖고 저장돼 있는 해당 레스토랑을 가져온 후 전달 받은 name값과 address값으로 업데이트 한다. 만약 해당 레스토랑이 없을 경우 RestaurantNotFoundException예외를 일으키도록 한다. 1234567891011121314@Transactionalpublic Restaurant updateRestaurant(Long id, String name, String address) throws Exception &#123; Optional&lt;Restaurant&gt; optional = restaurantRepository.findById(id); if (optional.isPresent()) &#123; Restaurant restaurant = optional.get(); restaurant.setName(name); restaurant.setAddress(address); return restaurant; &#125; else &#123; throw new RestaurantNotFoundException(id); &#125;&#125; 업데이트에 대한 테스트 코드12345678910111213141516@Testpublic void 레스토랑정보_업데이트() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .name(&quot;Bob zip&quot;) .address(&quot;Seoul&quot;) .build(); given(restaurantRepository.findById(1004L)) .willReturn(Optional.of(restaurant)); Restaurant updated = restaurantService.updateRestaurant(1004L, &quot;Sool zip&quot;, &quot;Busan&quot;); assertThat(updated.getName()).isEqualTo(&quot;Sool zip&quot;); assertThat(updated.getAddress()).isEqualTo(&quot;Busan&quot;);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 레스토랑 생성","slug":"springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-create","date":"2021-02-03T00:21:02.000Z","updated":"2021-03-13T11:43:08.177Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-create/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin-create/","excerpt":"","text":"3. 레스토랑 추가하기레스토랑 생성 요청을 처리하기 위한 control 추가Http 메소드들 중에서 post메소드를 사용해 새로운 레스토랑을 추가하는 요청을 처리할 것이고, /restaurnt경로로 요청이 들어올 경우 request body에 들어가 있는 데이터를 가져와 새로운 레스토랑을 생성한다. 1234567891011121314@PostMapping(&quot;/restaurants&quot;)public ResponseEntity&lt;?&gt; create(@RequestBody Restaurant resource) throws URISyntaxException &#123; String name = resource.getName(); String address = resource.getAddress(); Restaurant restaurant = Restaurant.builder() .name(name) .address(address) .build(); restaurantService.addRestaurant(restaurant); URI location = new URI(&quot;/restaurants/&quot; + restaurant.getId()); return ResponseEntity.created(location).body(&quot;&#123;&#125;&quot;);&#125; 요청에 대한 레스토랑 생성 테스트 코드 작성POJO를 JSON형태로 변환하기 위해 Jackson라이브러리의 ObjectMapper를 사용할 것이다.ObjectMapper를 통해 Restaurant객체를 JSON String 형태로 변환해 request body에 넣어 /restaurants경로로 post요청을 한다. 1234567891011121314151617181920212223242526@Autowiredprivate ObjectMapper objectMapper;@Testpublic void 새로운_레스토랑_저장하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(BobZip) .address(Seoul) .build(); // POJO를 JSON형태로 변환해준다. String content = objectMapper.writeValueAsString(restaurant); ResultActions resultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isCreated()) .andDo(print());&#125; 새로운 레스토랑을 생성하는 요청을 한 후 레스토랑의 정보를 가져오는 요청을 해 해당 정보가 제대로 생성 됐는지 확인한다. 12345678910111213141516171819202122232425262728293031323334@Testpublic void 새로운_레스토랑_저장_및_조회하기() throws Exception &#123; String BobZip = &quot;BobZip&quot;; String Seoul = &quot;Seoul&quot;; Restaurant restaurant = Restaurant.builder() .categoryId(1L) .name(BobZip) .address(Seoul) .build(); String content = objectMapper.writeValueAsString(restaurant); ResultActions postResultActions = mockMvc.perform(post(&quot;/restaurants&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); postResultActions .andExpect(status().isCreated()) .andDo(print()); List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); restaurants.add(restaurant); given(restaurantService.getRestaurants()).willReturn(restaurants); ResultActions getResultActions = mockMvc.perform(get(&quot;/restaurants&quot;)); getResultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$[0].name&quot;).value(BobZip)) .andExpect(jsonPath(&quot;$[0].address&quot;).value(Seoul)) .andDo(print());&#125; 레스토랑 정보를 저장하는 Service 메소드 추가1234567891011121314151617181920212223@Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; // 전달받은 Restaurant정보를 저장하기 위한 서비스 public Restaurant addRestaurant(Restaurant restaurant) &#123; restaurantRepository.save(restaurant); return restaurant; &#125; public List&lt;Restaurant&gt; getRestaurants() &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAll(); return restaurants; &#125; public Restaurant getRestaurant(Long id) &#123; Restaurant restaurant = restaurantRepository.findById(id) .orElseThrow(() -&gt; new RestaurantNotFoundException(id)); return restaurant; &#125;&#125; 레스토랑을 추가하는 테스트 코드 추가1234567891011121314151617@Testpublic void 레스토랑_추가하기() &#123; given(restaurantRepository.save(any())).will(invocation -&gt; &#123; Restaurant restaurant = invocation.getArgument(0); restaurant.setId(1234L); return restaurant; &#125;); Restaurant restaurant = Restaurant.builder() .name(&quot;BeRyong&quot;) .address(&quot;Busan&quot;) .build(); Restaurant created = restaurantService.addRestaurant(restaurant); assertThat(created.getId()).isEqualTo(1234L);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 특정 레스토랑 가져오기","slug":"springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-specific","date":"2021-02-03T00:20:02.000Z","updated":"2021-03-13T11:43:14.693Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin-specific/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin-specific/","excerpt":"","text":"2. 특정 레스토랑에 대한 정보 가져오기특정가게에 대한 상세정보 요청을 처리하기 위한 control 추가특정 레스토랑의 정보를 가져오고 싶을 경우 restaurant의 Id값을 이용할 수 있다. /restaurant경로에 사용자가 원하는 restaurantId 를 더해 해당 레스토랑에 대한 정보를 반환하도록 한다. 12345@GetMapping(&quot;/restaurants/&#123;id&#125;&quot;)public Restaurant detail(@PathVariable Long id) throws Exception &#123; Restaurant restaurant = restaurantService.getRestaurant(id); return restaurant;&#125; 테스트 코드 작성특정 id값으로 갖는 restaurant에 대한 정보를 가져오는 테스트를 구현한다. 요청이 정상적으로 진행된 경우에는 Status으로 200과 함께 해당 레스토랑에 대한 정보를 받을 수 있다. 123456789101112131415161718@Testpublic void 특정_가게_상세정보를_가져온다() throws Exception &#123; Restaurant restaurant = Restaurant.builder() .id(1004L) .categoryId(1L) .name(&quot;JOKER House&quot;) .address(&quot;Seoul&quot;) .build(); given(restaurantService.getRestaurant(1004L)).willReturn(restaurant); ResultActions resultActions = mockMvc.perform(get(&quot;/restaurants/1004&quot;)); resultActions .andExpect(status().isOk()) // 레스토랑 정보가 들어있는지 확인한다. .andExpect(content().string(containsString(&quot;\\&quot;id\\&quot;:1004&quot;))) .andExpect(content().string(containsString(&quot;\\&quot;name\\&quot;:\\&quot;JOKER House\\&quot;&quot;)));&#125; 특정 레스토랑을 가져오는 Service로직RestaurantRepository 객체를 이용해 DB로부터 id값이 일치하는 레스토랑 정보를 가져온다. 만약 해당되는 Restaurant정보가 없다면 RestaurantNotFoundException을 발생시킨다. 1234567891011121314151617@Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; public List&lt;Restaurant&gt; getRestaurants() &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAll(); return restaurants; &#125; public Restaurant getRestaurant(Long id) &#123; Restaurant restaurant = restaurantRepository.findById(id) .orElseThrow(() -&gt; new RestaurantNotFoundException(id)); return restaurant; &#125;&#125; Service로직 테스트코드 구현특정 레스토랑정보를 정상적으로 가져오는 경우와 특정 레스토랑정보를 못가져오는 경우 두가지에 대한 테스트 코드를 작성해야 한다. 1234567891011121314151617@Testpublic void 특정_레스토랑을_가져온다() &#123; Restaurant restaurant = restaurantService.getRestaurant(1004L); // restaurantRepository객체의 findById메서드가 실행됬는지 확인한다. verify(restaurantRepository).findById(eq(1004L)); // 레스토랑 정보를 확인한다. assertThat(restaurant.getId()).isEqualTo(1004L);&#125;@Testpublic void 없는_레스토랑을_가져온다() &#123; assertThatThrownBy(() -&gt; &#123; Restaurant restaurant = restaurantService.getRestaurant(404L); &#125;).isInstanceOf(RestaurantNotFoundException.class);&#125; 12345public class RestaurantNotFoundException extends RuntimeException&#123; public RestaurantNotFoundException(Long id) &#123; super(&quot;Could not find Restaurant &quot; + id ); &#125;&#125; 12345678910@ControllerAdvicepublic class RestaurantErrorAdvice &#123; @ResponseBody @ResponseStatus(HttpStatus.NOT_FOUND) @ExceptionHandler(RestaurantNotFoundException.class) public String handleNotFound()&#123; return &quot;&#123;&#125;&quot;; &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리(관리자) 모든 레스토랑 가져오기","slug":"springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin","date":"2021-02-03T00:19:02.000Z","updated":"2021-03-13T11:43:24.631Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-admin/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-admin/","excerpt":"","text":"패스트 캠퍼스에서 레스토량 예약 사이트 만드는 Toy project를 진행 했다. 해당 프로젝트를 진행하면서 배울 수 있었던 것은 TDD, 스프링부트를 이용한 Rest-Api작성 Multi-Module을 이용한 프로젝트 진행을 배울 수 있었다. 강의 내용들을 블로그 포스팅을 통해 다시 되집어 보려고 한다. 관리자 페이지 모든 Restaurant정보 가져오기 특정 Restaurant정보 가져오기 Restaurant 추가하기 Restaurant정보 수정하기 1. 모든 레스토랑에 대한 정보를 가져오기Restaurant Controller 생성레스토랑을 예약하기 위해서 예약할 수 있는 레스토랑 목록을 알아야 한다. /restaurant로 접근하면 모든 레스토랑의 정보를 가져올 수 있도록 한다. RestaurantRepository 로부터 바로 데이터를 가져와 사용자에게 넘겨줘도 되지만, Service 계층을 넣어 데이터를 처리하는 로직과 사용자에게 View를 보여주는 control로직을 분리하도록 한다. 1234567891011@RestController@RequiredArgsConstructorpublic class RestaurantController &#123; private final RestaurantService restaurantService; @GetMapping(&quot;/restaurants&quot;) public List&lt;Restaurant&gt; list() &#123; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(); return restaurants; &#125;&#125; 요청에 대한 테스트 코드 작성12345678910111213141516@WebMvcTest(RestaurantController.class)@AutoConfigureMockMvcclass RestaurantControllerTest &#123; @Autowired MockMvc mockMvc; @Test public void list를_확인한다() throws Exception&#123; ResultActions resultActions = mockMvc.perform(get(&quot;/restaurant&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); &#125;&#125; Restaurant Service 생성1234567891011@Service@RequiredArgsConstructorpublic class RestaurantService &#123; private final RestaurantRepository restaurantRepository; public List&lt;Restaurant&gt; getRestaurants() &#123; List&lt;Restaurant&gt; restaurants = restaurantRepository.findAll(); return restaurants; &#125;&#125; Service 계층에 대한 Test코드 작성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class RestaurantServiceTest &#123; @Autowired private MockMvc mockMvc; @InjectMocks private RestaurantService restaurantService; @Mock private RestaurantRepository restaurantRepository; @Mock private MenuItemRepository menuItemRepository; @Mock private ReviewRepository reviewRepository; @BeforeEach public void setUp() &#123; MockitoAnnotations.openMocks(this); mockRestaurantRepository(); mockMenuItemRepository(); mockReviewRepository(); &#125; private void mockRestaurantRepository() &#123; List&lt;Restaurant&gt; restaurants = new ArrayList&lt;&gt;(); Restaurant restaurant = Restaurant.builder() .id(1004L) .address(&quot;Seoul&quot;) .categoryId(1L) .name(&quot;Bob zip&quot;) .build(); restaurants.add(restaurant); // address와 category를 사용해 검색한다. given(restaurantRepository .findAllByAddressContainingAndCategoryId(&quot;Seoul&quot;, 1L)) .willReturn(restaurants); given(restaurantRepository.findById(1004L)) .willReturn(Optional.of(restaurant)); &#125; private void mockMenuItemRepository() &#123; List&lt;MenuItem&gt; menuItems = new ArrayList&lt;&gt;(); menuItems.add((MenuItem.builder() .name(&quot;Kimchi&quot;) .build())); given(menuItemRepository.findAllByRestaurantId(1004L)).willReturn(menuItems); &#125; private void mockReviewRepository() &#123; List&lt;Review&gt; reviews = new ArrayList&lt;&gt;(); reviews.add(Review.builder() .name(&quot;BeRyong&quot;) .score(1) .description(&quot;Bad&quot;) .build()); given(reviewRepository.findAllByRestaurantId(1004L)).willReturn(reviews); &#125; @Test @DisplayName(&quot;모든 레스토랑을 가져온다.&quot;) public void list() &#123; String region = &quot;Seoul&quot;; Long categoryId = 1L; List&lt;Restaurant&gt; restaurants = restaurantService.getRestaurants(region, categoryId); Restaurant restaurant = restaurants.get(0); assertThat(restaurant.getId()).isEqualTo(1004L); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"Spring Boot를 이용한 RESTful Web Services 개발 - User Service API 구현","slug":"springboot/Rest-Api/RESTful-Web-Services/User-Service-Api-2","date":"2021-02-02T17:02:37.000Z","updated":"2021-03-13T11:39:42.814Z","comments":true,"path":"2021/02/03/springboot/Rest-Api/RESTful-Web-Services/User-Service-Api-2/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/Rest-Api/RESTful-Web-Services/User-Service-Api-2/","excerpt":"","text":"HTTP Status Code 제어1234567891011@PostMapping(&quot;/users&quot;)public ResponseEntity&lt;User&gt; createUser(@RequestBody @Valid User user)&#123; User savedUser = service.save(user); URI location = ServletUriComponentsBuilder.fromCurrentRequest() .path(&quot;/&#123;id&#125;&quot;) .buildAndExpand(savedUser.getId()) .toUri(); return ResponseEntity.created(location).build();&#125; 123public static BodyBuilder created(URI location) &#123; return status(HttpStatus.CREATED).location(location);&#125; HTTP Status Code 상태를 확인하기 위한 Test Code 작성123456789101112131415161718@Testpublic void 유저를_등록하고_상태코드_201을_확인한다() throws Exception &#123; User user = new User(); String name = &quot;dongwoo&quot;; Date date = new Date(); user.setName(name); user.setJoinDate(date); String content = objectMapper.writeValueAsString(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isCreated()) .andDo(print());&#125; 존재하지 않는 id값에 대한 예외처리 추가12345678910@GetMapping(&quot;/users/&#123;id&#125;&quot;)public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); if(user == null)&#123; throw new UserNotFoundException(String.format(&quot;ID[%s] not found&quot;, id )); &#125; return user;&#125; 예외처리하는 Exception 클래스 생성123456@ResponseStatus(HttpStatus.NOT_FOUND)public class UserNotFoundException extends RuntimeException &#123; public UserNotFoundException(String message) &#123; super(message); &#125;&#125; AOP를 이용한 Exception Handling12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class ExceptionResponse &#123; private Date timestamp; private String message; private String details;&#125; 1234567891011121314151617181920@RestController@ControllerAdvicepublic class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler &#123; @ExceptionHandler(Exception.class) public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR); &#125; @ExceptionHandler(UserNotFoundException.class) public final ResponseEntity&lt;Object&gt; handleUserNotFoundException(Exception ex, WebRequest request)&#123; ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Boot/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/"},{"name":"RESTful Web Services 강의","slug":"Spring-Boot/Spring-Rest/RESTful-Web-Services-강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/RESTful-Web-Services-%EA%B0%95%EC%9D%98/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"},{"name":"Exception Handling","slug":"Exception-Handling","permalink":"https://ckck803.github.io/tags/Exception-Handling/"}]},{"title":"레스토랑 예약 사이트 1 - 레스토랑 관리 Domain 생성","slug":"springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-common","date":"2021-02-02T15:21:08.000Z","updated":"2021-03-13T11:43:29.224Z","comments":true,"path":"2021/02/03/springboot/fastcampus-eatgo/1. restaurant/eat-go-restaurant-common/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/fastcampus-eatgo/1.%20restaurant/eat-go-restaurant-common/","excerpt":"","text":"Restaurant Entity 클래스Restaurant 클래스에는 id , name, address를 저장한다. id : 레스토랑을 구분하기 위한 Id값 name : 레스토랑의 이름 address : 레스토랑의 위치 1234567891011121314151617@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builderpublic class Restaurant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotEmpty private String name; @NotEmpty private String address;&#125; Restaurant 클래스에 대한 테스트 코드 작성123456789101112@Testpublic void creation()&#123; String name = &quot;OutBack&quot;; String address = &quot;Seoul&quot;; long id = 1004L; Restaurant restaurant = new Restaurant(id, name, address); assertThat(restaurant).isNotNull(); assertThat(restaurant.getId()).isEqualTo(id); assertThat(restaurant.getName()).isEqualTo(name); assertThat(restaurant.getAddress()).isEqualTo(address);&#125; Restaurant Repository 생성Restaurant에 대한 정보를 가져오고 저장하고 수정하기 위한 Repository를 생성한다. Repository는 DB에 접근해 CRUD를 실행할 수 있다. 123@Repositorypublic interface RestaurantRepository extends JpaRepository&lt;Restaurant, Long&gt; &#123;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"}]},{"title":"Spring Boot를 이용한 RESTful Web Services 개발","slug":"springboot/Rest-Api/RESTful-Web-Services/User-Service-Api","date":"2021-02-02T15:04:00.000Z","updated":"2021-03-13T11:39:50.383Z","comments":true,"path":"2021/02/03/springboot/Rest-Api/RESTful-Web-Services/User-Service-Api/","link":"","permalink":"https://ckck803.github.io/2021/02/03/springboot/Rest-Api/RESTful-Web-Services/User-Service-Api/","excerpt":"","text":"User 도메인 클래스 생성12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name; private Date joinDate;&#125; 서비스 클래스 생성12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class UserDaoService &#123; // 관계형 데이터베이스를 사용하지 않고 Memory 데이터를 사용 private static List&lt;User&gt; users = new ArrayList&lt;&gt;(); private static int usersCount = 3; static&#123; users.add(new User(1, &quot;Kenneth&quot;, new Date())); users.add(new User(2, &quot;Alice&quot;, new Date())); users.add(new User(3, &quot;Elena&quot;, new Date())); &#125; // 전체 사용자 조회 public List&lt;User&gt; findAll()&#123; return users; &#125; // 개별 사용자 조회 public User save(User user)&#123; if(user.getId() == null)&#123; user.setId(++usersCount); &#125; users.add(user); return user; &#125; // id값을 이용한 사용자 조회 public User findOne(int id)&#123; for (User user : users)&#123; if(user.getId() == id)&#123; return user; &#125; &#125; return null; &#125;&#125; 사용자 요청 처리 Controller 추가123456789101112131415161718@RestController@RequiredArgsConstructorpublic class UserController &#123; private final UserDaoService service; @GetMapping(&quot;/users&quot;) public List&lt;User&gt; retrieveAllUsers()&#123; return service.findAll(); &#125; // path variable을 이용한 요청을 처리 @GetMapping(&quot;/users/&#123;id&#125;&quot;) public User retrieveUser(@PathVariable int id)&#123; User user = service.findOne(id); return user; &#125;&#125; 전체 사용자 조회 기능과 특정 사용자 조회 기능 확인을 위한 Test 코드 작성1234567891011121314151617181920212223242526272829@SpringBootTest@AutoConfigureMockMvcclass UserControllerTest &#123; @Autowired MockMvc mockMvc; @Autowired ObjectMapper objectMapper; @Test public void 모든_유저들을_가져온다() throws Exception &#123; ResultActions resultActions = mockMvc.perform(get(&quot;/users&quot;)); resultActions .andExpect(status().isOk()) .andDo(print()); &#125; @Test public void 특정_유저를_가져온다() throws Exception &#123; ResultActions resultActions = mockMvc.perform(get(&quot;/users/1&quot;)); resultActions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;id&quot;).value(1)) .andDo(print()); &#125;&#125; 사용자 생성 요청 처리를 위한 Control 추가1234@PostMapping(&quot;/users&quot;)public void createUser(@RequestBody @Valid User user)&#123; User savedUser = service.save(user);&#125; User 등록 기능을 확인하기 위한 Test 코드 작성123456789101112131415161718@Testpublic void 유저를_등록한다() throws Exception &#123; User user = new User(); String name = &quot;dongwoo&quot;; Date date = new Date(); user.setName(name); user.setJoinDate(date); String content = objectMapper.writeValueAsString(user); ResultActions resultActions = mockMvc.perform(post(&quot;/users&quot;) .content(content) .contentType(MediaType.APPLICATION_JSON)); resultActions .andExpect(status().isOk()) .andDo(print());&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Boot/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/"},{"name":"RESTful Web Services 강의","slug":"Spring-Boot/Spring-Rest/RESTful-Web-Services-강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/RESTful-Web-Services-%EA%B0%95%EC%9D%98/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"}]},{"title":"Spring Boot를 이용한 RESTful Web Services 개발 - User Service API 구현","slug":"springboot/Rest-Api/RESTful-Web-Services/RESTful-Web-Services","date":"2021-02-02T14:47:05.000Z","updated":"2021-03-13T11:39:37.187Z","comments":true,"path":"2021/02/02/springboot/Rest-Api/RESTful-Web-Services/RESTful-Web-Services/","link":"","permalink":"https://ckck803.github.io/2021/02/02/springboot/Rest-Api/RESTful-Web-Services/RESTful-Web-Services/","excerpt":"","text":"12345678910111213141516171819@RestControllerpublic class HelloWorldController &#123; @GetMapping(&quot;/hello-world&quot;) public String Hello()&#123; return &quot;Hello World&quot;; &#125; // SpringBoot에서는 HelloWorldBean이라는 객체를 JSON타입의 형태로 반환해준다. @GetMapping(&quot;/hello-world-bean/&quot;) public HelloWorldBean helloWorldBean()&#123; return new HelloWorldBean(&quot;Hello World&quot;); &#125; @GetMapping(&quot;/hello-world-bean/path-variable/&#123;name&#125;&quot;) public HelloWorldBean helloWorldBean(@PathVariable String name)&#123; return new HelloWorldBean(String.format(&quot;Hello World, %s&quot;, name)); &#125;&#125; HelloWorldBean 클래스 생성123456@Data@NoArgsConstructor@AllArgsConstructorpublic class HelloWorldBean &#123; private String message;&#125; 테스트 코드 작성1234567891011121314151617181920212223242526272829303132333435363738@SpringBootTest@AutoConfigureMockMvcclass HelloWorldControllerTest &#123; @Autowired private MockMvc mockMvc; @Test public void Hello_World가_리턴된다() throws Exception&#123; ResultActions actions = mockMvc.perform(get(&quot;/hello-world&quot;)); actions .andExpect(status().isOk()) .andExpect(content().string(&quot;Hello World&quot;)) .andDo(print()) ; &#125; @Test public void Hello_World_Bean_test() throws Exception&#123; ResultActions action = mockMvc.perform(get(&quot;/hello-world-bean&quot;)); action .andExpect(status().isOk()) .andExpect(jsonPath(&quot;message&quot;).value(&quot;Hello World&quot;)) .andDo(print()); &#125; @Test public void Hello_World_Bean_Name_test() throws Exception&#123; ResultActions actions = mockMvc.perform(get(&quot;/hello-world-bean/path-variable/dongwoo&quot;)); actions .andExpect(status().isOk()) .andExpect(jsonPath(&quot;message&quot;).value(&quot;Hello World, dongwoo&quot;)) .andDo(print()); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Boot/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/"},{"name":"RESTful Web Services 강의","slug":"Spring-Boot/Spring-Rest/RESTful-Web-Services-강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/RESTful-Web-Services-%EA%B0%95%EC%9D%98/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"}]},{"title":"스프링 시큐리티 아키텍처 1 - SecurityContextHolder와 Authentication","slug":"springboot/security/inflearn-whiteship-security/security-context-holder","date":"2021-02-02T13:25:35.000Z","updated":"2021-03-13T11:31:24.032Z","comments":true,"path":"2021/02/02/springboot/security/inflearn-whiteship-security/security-context-holder/","link":"","permalink":"https://ckck803.github.io/2021/02/02/springboot/security/inflearn-whiteship-security/security-context-holder/","excerpt":"","text":"","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"스프링 시큐리티 강의","slug":"Spring-Boot/Spring-Security/스프링-시큐리티-강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EA%B0%95%EC%9D%98/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"}]},{"title":"Spring Boot OAuth2를 이용한 로그인 구현하기 - 2 사용자 정보 가져오기","slug":"springboot/security/OAuth2/oauth2-config","date":"2021-02-01T04:56:10.000Z","updated":"2021-03-13T11:31:05.748Z","comments":true,"path":"2021/02/01/springboot/security/OAuth2/oauth2-config/","link":"","permalink":"https://ckck803.github.io/2021/02/01/springboot/security/OAuth2/oauth2-config/","excerpt":"","text":"2. Resource Server로부터 사용자 정보 가져오기Spring Security 설정하기OAuth2 인증을 마친 후에 Resource Server로부터 사용자 정보를 가져오기 위해서는 UserInfo EndPoint에 접근할 필요가 있다. HttpSecurity객체의 oauth2Login().userInfoEndpoint().userService() 메소드를 이용해서 UserInfo EndPoint로부터 사용자 정보를 가져올 Service를 등록한다. 123456789101112131415161718@EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomOAuth2UserService customOAuth2UserService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(&quot;/**&quot;).authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .anyRequest().authenticated(); http .oauth2Login() .userInfoEndpoint() .userService(customOAuth2UserService); &#125;&#125; 스프링에서 기본적으로 제공하는 OAuth2ProviderGoogle, Facebook, Github 등을 통해 OAuth2인증하기 위한 기본적인 설정값들이 들어가 있다. 해당 정보를 통해 ClientRegistration 객체를 생성한다. authorizationUri 인증을 진행하기 위해 사용하는 URI tokenUri Resource server로부터 access token을 받기 위해 사용하는 URI jwkSetUri token의 유효성(서명)을 확인할 수 있는 public key(JSON Web Key)를 받을 수 있는 URI userInfoUri Resource Server(ex. Google)로부터 사용자 정보를 가져오기 위한 URI userNameAttributeName Resource server가 제공하는 id값 clientName Resource Server 이름(client Name을 사용할 때도 있다.) CommonOAuth2Provider.enum 12345678910111213141516171819202122232425262728293031public enum CommonOAuth2Provider &#123; GOOGLE &#123; @Override public Builder getBuilder(String registrationId) &#123; ClientRegistration.Builder builder = getBuilder(registrationId, ClientAuthenticationMethod.BASIC, DEFAULT_REDIRECT_URL); builder.scope(&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;); builder.authorizationUri(&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;); builder.tokenUri(&quot;https://www.googleapis.com/oauth2/v4/token&quot;); builder.jwkSetUri(&quot;https://www.googleapis.com/oauth2/v3/certs&quot;); builder.issuerUri(&quot;https://accounts.google.com&quot;); builder.userInfoUri(&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;); builder.userNameAttributeName(IdTokenClaimNames.SUB); builder.clientName(&quot;Google&quot;); return builder; &#125; &#125;, ... private static final String DEFAULT_REDIRECT_URL = &quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;; protected final ClientRegistration.Builder getBuilder(String registrationId, ClientAuthenticationMethod method, String redirectUri) &#123; ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(registrationId); builder.clientAuthenticationMethod(method); builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE); builder.redirectUri(redirectUri); return builder; &#125;&#125; Service 생성하기아래 서비스는 DefaultOAuth2UserService 에 구현된 코드들을 가져와 다시 정의 했다. Spring Boot에서 OAuth2 인증 방식을 사용하기 위해서는 OAuth2UserService인터페이스를 구현해 loadUser 메소드를 정의해야 한다. OAuth2UserService 인터페이스를 구현해 사용자가 원하는 서비스를 만든다. DefaultOAuth2UserService 는 스프링에서 제공하는 OAuth2UserService 를 구현한 기본 Class이다. CustomOAuth2UserService.class 123456789101112131415161718192021222324252627282930313233343536373839@Service@RequiredArgsConstructorpublic class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; &#123; private final OAuth2Repository oAuth2Repository; private RestTemplate restTemplate = new RestTemplate(); private final Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt; requestEntityConverter = new OAuth2UserRequestEntityConverter(); @Override public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException &#123; String userNameAttributeName = userRequest .getClientRegistration() .getProviderDetails() .getUserInfoEndpoint() .getUserNameAttributeName(); // userRequest객체를 request객체로 변환해 Resouce Server에 요청을 보내 User 정보를 가져온다. RequestEntity&lt;?&gt; request = this.requestEntityConverter.convert(userRequest); ResponseEntity&lt;Map&lt;String, Object&gt;&gt; response = restTemplate.exchange(request, new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;); Map&lt;String, Object&gt; userAttributes = response.getBody(); // 사용자 권한 목록을 저장한다. Set&lt;GrantedAuthority&gt; authorities = new LinkedHashSet&lt;&gt;(); authorities.add(new OAuth2UserAuthority(userAttributes)); // token값으로 접근 가능한 scope를 같이 저장한다. OAuth2AccessToken token = userRequest.getAccessToken(); for (String authority : token.getScopes()) &#123; authorities.add(new SimpleGrantedAuthority(&quot;SCOPE_&quot; + authority)); &#125; OAuth2User oAuth2User = new DefaultOAuth2User(authorities, userAttributes, userNameAttributeName); return oAuth2User; &#125;&#125; OAuth2UserService 는 clinetRegistration 객체와 accessToken 을 가지고 있는 OAuth2UserRequest 를 이용해 UserInfo EndPoint로부터 사용자 정보를 가져올 수 있다. 디버깅을 통해 Spring OAuth2 자세히 살펴보기 userNameAttributeName 사용자를 인식할 수 있는 field 구글에서는 sub필드를 이용한다. OAuth2User 스프링에서는 기본 구현체로 DefaultOAuth2User 객체를 제공한다. authorities, userAttributes, userNameAttributeName 3가지 속성을 가진 OAuth2 User객체이다. OAuth2AccessToken OAuth2 Access Token을 표현하기 위한 객체 tokenType : Bearer는 Oauth, JWT에 대한 토큰 값을 의미한다. scope : 해당 토큰 값으로 접근할 수 있는 정보들을 나타낸다. toeknValue : 토큰 값이 들어 있다. OAuth2UserRequest OAuth2UserRequest객체는 ClientRegistration 객체와, OAuth2AccessToken 객체 그리고 추가적인 데이터를 담기 위한 Map&lt;String, Object&gt; 객체가 존재한다. ClientRegistration 객체에는 Resource Server에 등록 정보와 Resource에 접근하기 위한 URI들이 있다. OAuth2AccessToken 객체에는 Resource Server로부터 데이터를 가져오기 위해 필요한 Token값이 담겨 있다. request 객체를 보면 Header값에 Access Token값이 있다. UserInfo URI에 접근해 Access Token을 이용해 인증을 받고 사용자 정보를 받아올 수 있다. response 객체를 살펴 보면 UserInfo URI로 접근해 인증을 성공적으로 마쳤을 때 사용자 정보를 가져옴을 확인 할 수 있다. 가져오는 사용자 정보는 scope로 명시한 데이터만 가져온다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Oauth2","slug":"Spring-Boot/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Oauth2/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Oauth2","slug":"Oauth2","permalink":"https://ckck803.github.io/tags/Oauth2/"}]},{"title":"Spring Boot OAuth2를 이용한 로그인 구현하기 - 1 OAuth2를 이용한 인증 사용하기","slug":"springboot/security/OAuth2/oauth2-modeling-md","date":"2021-02-01T04:26:33.000Z","updated":"2021-03-13T11:40:42.823Z","comments":true,"path":"2021/02/01/springboot/security/OAuth2/oauth2-modeling-md/","link":"","permalink":"https://ckck803.github.io/2021/02/01/springboot/security/OAuth2/oauth2-modeling-md/","excerpt":"","text":"1. OAuth2를 이용한 인증 사용하기Google에 Web Application 등록하기Google의 OAuth2 서비스를 이용하기 위해서 사용할 Web Application을 등록해 Client Id와 Client Secret을 받아야 한다. 구글 클라우드 플랫폼 : https://console.cloud.google.com/ API및 서비스 &gt; OAuth 동의 화면을 클릭 사용자 인증 정보 만들기 &gt; OAuth 클라이언트 ID를 선택 애플리케이션 유형으로는 웹 애플리케이션을 선택한다.승인된 리디랙션 URI로는 http://localhost:8080/login/oauth2/code/google 를 기입해준다. OAuth 클라이언트가 생성됐다는 알림과 함께 Client ID와 Client Secret이 생성된다. OAuth2 설정 적용하기SpringBoot에서 Google OAuth2 인증을 사용하기 위해서 Google로부터 생성된 Client ID와 Client Secret을 기입해준다. application.yml 12345678spring: security: oauth2: client: registration: google: client-id: Google로부터 받은 Client ID client-secret: Google로부터 받은 Client Secret Control 구현/ 경로는 누구나 접근이 가능하도록 해 Hello World 문구가 반환되지만 /restricted 경로는 인증된 사용자만 restricted 문구를 받을 수 있도록 할 것이다. Oauth2Controller.class 123456789101112@RestControllerpublic class Oauth2Controller &#123; @GetMapping(&quot;/&quot;) public String Hello()&#123; return &quot;Hello World&quot;; &#125; @GetMapping(&quot;/restricted&quot;) public String restricted()&#123; return &quot;restricted&quot;; &#125;&#125; Spring Security 설정하기/ 경로는 누구나 접근이 가능하도록 하고 그외 모든 경로는 인증된 사용자만 사용할 수 있도록 설정한다.HttpSecurity객체의 oauth2Login() 메소드를 사용해 OAuth2 인증방식을 사용하도록 한다. SecurityConfig.class 12345678910111213141516@EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomOAuth2UserService customOAuth2UserService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(&quot;/**&quot;).authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .anyRequest().authenticated(); http .oauth2Login(); &#125;&#125; 어플리케이션 실행설정을 완료한 후 어플리케이션을 실행한 다음 localhost:8080/restricted 로 이동하면 아래와 같은 Google OAuth2인증 페이지로 이동하게 된다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Oauth2","slug":"Spring-Boot/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Oauth2/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Oauth2","slug":"Oauth2","permalink":"https://ckck803.github.io/tags/Oauth2/"}]},{"title":"OAuth2를 이용한 로그인 구현 이해하기","slug":"springboot/security/OAuth2/oauth2","date":"2021-01-29T11:47:30.000Z","updated":"2021-03-13T11:44:56.915Z","comments":true,"path":"2021/01/29/springboot/security/OAuth2/oauth2/","link":"","permalink":"https://ckck803.github.io/2021/01/29/springboot/security/OAuth2/oauth2/","excerpt":"","text":"OAuth2를 이용한 로그인 구현 이해하기OAuth란?OAuth란 Open Authorization의 약자이며 사용자 인증을 대신해서 해주고 Client에게 Access Token을 발급해 사용자 Resource에 대한 접근 권한(Authorization)을 제공하는 방법이다. OAuth가 등장하기 이전에는 각 사이트 별로 사용자 Id와 Password를 입력해 인증을 하고 정보를 저장하는 방식이였다. 때문에 사용자 입장에서는 본인의 Id와 Password를 각 사이트에 등록해야 한다는 신뢰성 적인 문제와 각 사이트에서는 사용자 정보를 관리하고 책임져야 하는 문제점이 있었다. 해당 문제를 해결하기 위해 등장한 방법이 OAuth 인증 방식이다. OAuth2 사용하기Web Application을 기준으로 OAuth2를 사용하기 위한 방법은 크게 3가지가 있다. Resource Server에 Application을 등록 Resource Owner 사용자 인증을 통해 Autorization Code를 가져오기 Client가 획득한 Autorization Code를 이용해 Access Token을 발급 받기 1. Resource Server에 Application 등록하기Resource Server에 Application을 등록하게 되면 Clinet Id 와 Client Secret 그리고 Authorized redirect URIs 를 받을 수 있다. 2. Resource Owner 인증 URI(Authorization Code 가져오기)Reousrce Owner가 OAuth 방식으로 Client에 사용자 인증을 시도하면 특정 URL로 리다이렉트를 진행한다. Client에서 Resource Server로 Redirect한 주소는 아래와 같다. 사용자가 Resource Server ID와 Password를 이용해 인증을 마치게 되면 Client로 Authorization code가 전송된다. Redirect 1234567https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount? response_type=code &amp;client_id=406416755620-r1h48em5g68qqh34pq277o80sc9qpb05.apps.googleusercontent.com &amp;scope=profile%20email &amp;state=qc0AqQVml_2waASthQKINHS6vGvC2HbjdWKmfWBFSkk%3D &amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Flogin%2Foauth2%2Fcode%2Fgoogle &amp;flowName=GeneralOAuthFlow Request Parameter response_type Google OAuth 2.0 End-Point 가 인증 코드를 반환하는지 여부를 결정한다. 웹 서버 애플리케이션의 경우 매개 변수 값을 code로 설정(resource server가 authorization code 를 발행) client_id Resource Server에서 Client에 발행해준 Id scope client가 resource server에 필요한 리소스에 대한 access범위 를 지정한다. state 애플리케이션이 권한 요청과 권한 서버의 응답 사이의 상태를 유지하기 위해 사용하는 문자열 값을 지정합니다. redirect_uri Oauth2를 이용해 Resource Server로부터 인증을 마친 사용가자 이동할 URI authorization code를 받기 위한 URI flowName 무엇을 위한 접근인지 나타내기 위한 parameter 일반적인 redirect_uri는 {baseUrl}/login/oauth2/code/{registrationId} 의 형식을 띈다.google의 경우 redirect_uri의 경우 localhost:8080/login/oauth2/code/google 이다. 3. Access Token 획득하기Resource Server로부터 Access Token을 발급 받기 위한 요청으로 Resource Server로부터 받은 Authorization Code와 Client Id, Client Secret, Redirect URI를 parameter로 보낸다. 서버측으로 Acces Token을 획득하기 위한 요청 123456https://www.googleapis.com/oauth2/v4/token? code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7 &amp;client_id=your_client_id &amp;client_secret=your_client_secret &amp;redirect_uri=https%3A//oauth2.example.com/code &amp;grant_type=authorization_code Resource Server로부터 Access Token을 받은 것을 확인할 수 있다. Resource Server로부터 Access Token획득 1234567&#123; &quot;access_token&quot;: &quot;1/fFAGRNJru1FTz70BzhT3Zg&quot;, &quot;expires_in&quot;: 3920, &quot;token_type&quot;: &quot;Bearer&quot;, &quot;scope&quot;: &quot;https://www.googleapis.com/auth/drive.metadata.readonly&quot;, &quot;refresh_token&quot;: &quot;1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI&quot;&#125; Google Oauth2 인증 시나리오 살펴보기 Web Server가 Google에 Access Token을 요청한다. 사용자가 구글 ID와 Password를 이용해 로그인을 한다. Web Server쪽으로 Authorization code가 반환된다. Authorization code를 이용해 Access Token을 요청 구글에서 Access Token값을 반환한다. Access Token을 이용해 사용자의 profile과 같은 정보들을 가져온다. 스프링에서 기본적으로 제공하는 OAuth2ProviderGoogle, Facebook, Github 등을 통해 OAuth2인증하기 위한 기본적인 설정값들이 들어가 있다. 123456789101112131415161718192021222324252627282930public enum CommonOAuth2Provider &#123; GOOGLE &#123; @Override public Builder getBuilder(String registrationId) &#123; ClientRegistration.Builder builder = getBuilder(registrationId, ClientAuthenticationMethod.BASIC, DEFAULT_REDIRECT_URL); builder.scope(&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;); builder.authorizationUri(&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;); builder.tokenUri(&quot;https://www.googleapis.com/oauth2/v4/token&quot;); builder.jwkSetUri(&quot;https://www.googleapis.com/oauth2/v3/certs&quot;); builder.issuerUri(&quot;https://accounts.google.com&quot;); builder.userInfoUri(&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;); builder.userNameAttributeName(IdTokenClaimNames.SUB); builder.clientName(&quot;Google&quot;); return builder; &#125; &#125;, ... private static final String DEFAULT_REDIRECT_URL = &quot;&#123;baseUrl&#125;/&#123;action&#125;/oauth2/code/&#123;registrationId&#125;&quot;; protected final ClientRegistration.Builder getBuilder(String registrationId, ClientAuthenticationMethod method, String redirectUri) &#123; ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(registrationId); builder.clientAuthenticationMethod(method); builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE); builder.redirectUri(redirectUri); return builder; &#125;&#125; authorizationUri 인증을 진행하기 위해 사용하는 URI tokenUri Resource server로부터 access token을 받기 위해 사용하는 URI jwkSetUri token의 유효성(서명)을 확인할 수 있는 public key(JSON Web Key)를 받을 수 있는 URI userInfoUri Resource Server(ex. Google)로부터 사용자 정보를 가져오기 위한 URI userNameAttributeName Resource server가 제공하는 id값 clientName Resource Server 이름(client Name을 사용할 때도 있다.) jwkSetUri의 URI로 접속https://www.googleapis.com/oauth2/v3/certs 1234567891011121314151617181920212223// 20210131104458// https://www.googleapis.com/oauth2/v3/certs&#123; &quot;keys&quot;: [ &#123; &quot;use&quot;: &quot;sig&quot;, &quot;kid&quot;: &quot;eea1b1f42807a8cc136a03a3c16d29db8296daf0&quot;, &quot;n&quot;: &quot;0zNdxOgV5VIpoeAfj8TMEGRBFg-gaZWz94ePR1yxTKzScHakH4F4wcMEyL0vNE-yW_u4pOl9E-hAalPa2tFv4fCVNMMkmKwcf0gm9wNFWXGakVQ8wER4iUg33MyUGOWj2RGX1zlZxCdFoZRtshLx8xcpL3F5Hlh6m8MqIAowWtusTf5TtYMXFlPaWLQgRXvoOlLZ-muzEuutsZRu-agdOptnUiAZ74e8BgaKN8KNEZ2SqP6vE4w16mgGHQjEPUKz9exxcsnbLru6hZdTDvXbX9IduabyvHy8vQRZsqlE9lTiOOOC9jwh27TXsD05HAXmNYiR6voekzEvfS88vnot2Q&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;alg&quot;: &quot;RS256&quot; &#125;, &#123; &quot;n&quot;: &quot;rKZ-1zdz_CoLekSynOtyWv6cPSSkV28Kb9kZZHyYL-yhkKnH_bHl8OpWiGxQiKP0ulLRIaq1IhSMetkZ8FfXH-iptIDu4lPb8gt0HQYkjcy3HoaKRXBw2F8fJQO4jQ-ufR4l-E0HRqwLywzdtAImNWmju3A4kx8s0iSGHGSHyE4EUdh5WKt-NMtfUPfB5v9_2bC-w6wH7zAEsI5nscMXnvz1u8w7g2_agyhKSK0D9OkJ02w3I4xLMlrtKEv2naoBGerWckKcQ1kBYUh6WASPdvTqX4pcAJi7Tg6jwQXIP1aEq0JU8C0zE3d33kaMoCN3SenIxpRczRzUHpbZ-gk5PQ&quot;, &quot;e&quot;: &quot;AQAB&quot;, &quot;use&quot;: &quot;sig&quot;, &quot;kid&quot;: &quot;03b2d22c2fecf873ed19e5b8cf704afb7e2ed4be&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;alg&quot;: &quot;RS256&quot; &#125; ]&#125; userInfoUri EndPoint에 접속token_uri로부터 받은 access token을 사용하여 https://www.googleapis.com/oauth2/v3/userinfo?access_token=&#123;Google로부터 받은 Access Token&#125; 해당 형식으로 URI에 접속하게 되면 User와 관련된 JSON값을 받을 수 있다. 12345678910&#123; &quot;sub&quot;: &quot;&quot;, &quot;name&quot;: &quot;사용자 성+이름&quot;, &quot;given_name&quot;: &quot;사용자 이름&quot;, &quot;family_name&quot;: &quot;사용자 성&quot;, &quot;picture&quot;: &quot;구글에서 사용하는 내 사진&quot;, &quot;email&quot;: &quot;구글 email&quot;, &quot;email_verified&quot;: true, &quot;locale&quot;: &quot;ko&quot;&#125; sub 필드는 Google서비스에서 계정마다 부여하는 id 값이다. 참고Open-Id : https://openid.net/specs/openid-connect-discovery-1_0.htmlOauth2 : https://tools.ietf.org/html/rfc6749구글 Oauth2 API : https://developers.google.com/identity/protocols/oauth2생활코딩 Oauth2(구) : https://www.youtube.com/watch?v=y5nNX5w0eqc&amp;t=1s생활코딩 Oauth2 : https://www.youtube.com/watch?v=hm2r6LtUbk8&amp;list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Oauth2","slug":"Spring-Boot/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Oauth2/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Oauth2","slug":"Oauth2","permalink":"https://ckck803.github.io/tags/Oauth2/"}]},{"title":"Spring Security Form Login - 4. 회원가입 페이지 만들기","slug":"springboot/security/Form-Login/form-signup-md","date":"2021-01-29T02:10:40.000Z","updated":"2021-03-13T11:31:14.781Z","comments":true,"path":"2021/01/29/springboot/security/Form-Login/form-signup-md/","link":"","permalink":"https://ckck803.github.io/2021/01/29/springboot/security/Form-Login/form-signup-md/","excerpt":"","text":"회원가입을 처리하기 위한 Controller 추가 요청으로 들어온 데이터를 받기 위한 DTO객체 생성 회원가입 page생성하기 회원 가입을 처리하기 위한 Controller 추가/signup으로 들어온 사용자 정보를 DTO객체로 받고 Account객체를 생성한 후 DB에 저장한다. 123456789101112131415161718192021222324252627282930313233343536373839@Controller@RequiredArgsConstructorpublic class SecurityController &#123; private final CustomUserDetailsService customUserDetailsService; private final PasswordEncoder passwordEncoder; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/logout&quot;) public void logout()&#123; &#125; @GetMapping(&quot;/signup&quot;) public String signup(@ModelAttribute(&quot;signupDto&quot;) AccountDto accountDto, Model model)&#123; return &quot;signup&quot;; &#125; @PostMapping(&quot;/signup&quot;) public String createNewAccount(@ModelAttribute(&quot;signupDto&quot;) @Validated AccountDto accountDto, Model model)&#123; Account account = Account.builder() .username(accountDto.getUsername()) .email(accountDto.getEmail()) .password(passwordEncoder.encode(accountDto.getPassword())) .role(Role.USER) .build(); customUserDetailsService.saveAccount(account); return &quot;redirect:&quot;; &#125;&#125; User정보를 받기위한 DTO만들기123456@Datapublic class AccountDto &#123; private String username; private String email; private String password;&#125; 회원가입 template 만들기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Bootstrap Registration Page with Floating Labels&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&gt; &lt;meta name=&quot;googlebot&quot; content=&quot;noindex, nofollow&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/result-light.css&quot;&gt;--&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/dummy.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/jquery.slim.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/bootstrap.bundle.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/all.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/signup.css&#125;&quot;/&gt; &lt;script id=&quot;insert&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-10 col-xl-9 mx-auto&quot;&gt; &lt;div class=&quot;card card-signin flex-row my-5&quot;&gt; &lt;div class=&quot;card-img-left d-none d-md-flex&quot;&gt; &lt;!-- Background image for card set in CSS! --&gt; &lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title text-center&quot;&gt;Register&lt;/h5&gt; &lt;form class=&quot;form-signin&quot; th:object=&quot;$&#123;signupDto&#125;&quot; th:action=&quot;@&#123;/signup&#125;&quot; th:method=&quot;post&quot;&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;username&#125;&quot; type=&quot;text&quot; id=&quot;inputUserame&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt; &lt;label for=&quot;inputUserame&quot;&gt;Username&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;email&#125;&quot; type=&quot;email&quot; id=&quot;inputEmail&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required&gt; &lt;label for=&quot;inputEmail&quot;&gt;Email address&lt;/label&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input th:field=&quot;*&#123;password&#125;&quot; type=&quot;password&quot; id=&quot;inputPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label for=&quot;inputPassword&quot;&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;inputConfirmPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label for=&quot;inputConfirmPassword&quot;&gt;Confirm password&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block text-uppercase&quot; type=&quot;submit&quot;&gt;Register&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[//]]&gt;&lt;/script&gt;&lt;script&gt; // tell the embed parent frame the height of the content if (window.parent &amp;&amp; window.parent.parent) &#123; window.parent.parent.postMessage([&quot;resultsFrame&quot;, &#123; height: document.body.getBoundingClientRect().height, slug: &quot;1nu8g6e5&quot; &#125;], &quot;*&quot;) &#125; // always overwrite window.name, in case users try to set it manually window.name = &quot;result&quot;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Form에서 기입된 데이터 보내기@ModelAttribute를 통해 accountDTO객체의 데이터가 회원가입 페이지의signupDto에게 전달되고 전달 받을 수 있다. Thymeleaf의 field속성을 통해 기입된 값들은 accountDTO객체로 변환되어 요청이 들어가게 된다. 1234567&lt;form class=&quot;form-signin&quot; th:object=&quot;$&#123;signupDto&#125;&quot; th:action=&quot;@&#123;/signup&#125;&quot; th:method=&quot;post&quot;&gt;...&lt;input th:field=&quot;*&#123;username&#125;&quot; type=&quot;text&quot; id=&quot;inputUserame&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; required autofocus&gt;...&lt;input th:field=&quot;*&#123;email&#125;&quot; type=&quot;email&quot; id=&quot;inputEmail&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required&gt;...&lt;input type=&quot;password&quot; id=&quot;inputConfirmPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Form login","slug":"Spring-Boot/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Form-login/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Form","slug":"Form","permalink":"https://ckck803.github.io/tags/Form/"}]},{"title":"Spring Security Form Login - 3. 템플릿 만들기","slug":"springboot/security/Form-Login/form-template-md","date":"2021-01-29T00:48:42.000Z","updated":"2021-03-13T11:31:11.889Z","comments":true,"path":"2021/01/29/springboot/security/Form-Login/form-template-md/","link":"","permalink":"https://ckck803.github.io/2021/01/29/springboot/security/Form-Login/form-template-md/","excerpt":"","text":"Spring에서 제공하는 Thymeleaf템플릿 엔진을 이용해 로그인 페이지를 구현했다. Form Login Page1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Bootstrap Login Page Card with Floating Labels&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/dummy.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/jquery.slim.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/bootstrap.bundle.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/all.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9 col-md-7 col-lg-5 mx-auto&quot;&gt; &lt;div class=&quot;card card-signin my-5&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title text-center&quot;&gt;Sign In&lt;/h5&gt; &lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;text&quot; th:name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required autofocus&gt; &lt;label th:for=&quot;username&quot;&gt;Email address&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-label-group&quot;&gt; &lt;input type=&quot;password&quot; th:name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; &lt;label th:for=&quot;password&quot;&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;custom-control custom-checkbox mb-3&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;custom-control-input&quot; id=&quot;customCheck1&quot;&gt; &lt;label class=&quot;custom-control-label&quot; for=&quot;customCheck1&quot;&gt;Remember password&lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block text-uppercase&quot; type=&quot;submit&quot;&gt;Sign in&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Form 로그인을 처리하는 url로 post요청을 보낸다. 1&lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; username과 password를 받는 input태그에서 name속성에 username과 password를 확실히 기입해줘야 Security가 해당 데이터를 얻어올 수 있다. 123&lt;input type=&quot;text&quot; th:name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Email address&quot; required autofocus&gt;...&lt;input type=&quot;password&quot; th:name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; required&gt; 로그인 후 진입 화면1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;시작페이지&lt;/h1&gt;&lt;form action=&quot;/logout&quot; th:action=&quot;@&#123;/logout&#125;&quot; th:method=&quot;post&quot; sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;button type=&quot;submit&quot; value=&quot;logout&quot;&gt;로그 아웃&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 인증시에만 보이는 form태그xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;을 이용하면 security를 통해 인증된 사용자에게만 보이는 화면을 구성할 수 있다. 1&lt;form action=&quot;/logout&quot; th:action=&quot;@&#123;/logout&#125;&quot; th:method=&quot;post&quot; sec:authorize=&quot;isAuthenticated()&quot;&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Form login","slug":"Spring-Boot/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Form-login/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Form","slug":"Form","permalink":"https://ckck803.github.io/tags/Form/"}]},{"title":"Spring Security Form Login - 2. Security 설정 및 UserDetailsService 정의하기","slug":"springboot/security/Form-Login/form-login-config","date":"2021-01-29T00:38:37.000Z","updated":"2021-03-14T14:56:26.144Z","comments":true,"path":"2021/01/29/springboot/security/Form-Login/form-login-config/","link":"","permalink":"https://ckck803.github.io/2021/01/29/springboot/security/Form-Login/form-login-config/","excerpt":"","text":"로그인 로그아웃을 처리를 위한 Controller 생성 Spring Security 설정하기 UserDetailsService 구현하기 로그인 로그아웃을 처리를 위한 Controller/login으로 사용자 로그인 요청을 처리하고 /logout으로 사용자 로그아웃 요청을 처리한다. 1234567891011121314151617181920@Controller@RequiredArgsConstructorpublic class SecurityController &#123; private final CustomUserDetailsService customUserDetailsService; private final PasswordEncoder passwordEncoder; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/logout&quot;) public void logout()&#123; &#125;&#125; Spring Security 설정하기Spring Security를 설정하고 싶으면 EnableWebSecurity어노테이션과 WebSecurityConfigurerAdapter 클래스를 상속해 method들을 overriding한다. configure(AuthenticationManagerBuilder auth) AuthenticationManager를 설정하기 위해 사용하는 method configure(WebSecurity web) 전역적인 security를 설정할 때 사용하는 method, 보통은 보안 예외처리에 사용한다. configure(HttpSecurity http) request 단위로 보안을 걸때 사용하는 method configure(HttpSecurity http)을 이용해 허가를 하는 경우에는 Spring Filter Chain을 거처야 하지만 configure(WebSecurity web)를 이용하면 Spring Filter Chain을 거치지 않는다. 123456789101112131415161718192021222324252627282930313233343536373839@EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final CustomUserDetailsService customUserDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;) ; &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http. authorizeRequests() .anyRequest().authenticated(); http .formLogin() // Form Login을 이용한 인증 방식을 사용 .loginPage(&quot;/login&quot;) // Login Page로 redirect할 경로를 적어준다. .defaultSuccessUrl(&quot;/&quot;, true) // 로그인 성공후 이동할 경로 .permitAll() ; &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; UserDetailsService 등록하기AuthenticationManagerBuilder객체를 이용해 인증시 사용하는 UserDetailsService를 지정해준다. 1234@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserDetailsService);&#125; 정적파일을 Security Filter에서 제외 시키기css파일이나 js파일에 대한 예외처리를 하지 않는 경우 화면을 그릴때 해당 자원에 대한 접근을 하지 못하므로 화면이 깨져 나오게 된다. 12345678@Overridepublic void configure(WebSecurity web) throws Exception &#123; web .ignoring() .antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;) .antMatchers(&quot;/favicon.ico&quot;, &quot;/resources/**&quot;, &quot;/error&quot;) ;&#125; 요청에 따라서 인증/인가를 설정로그인을 하기 위한 login페이지에 대한 접근은 허용하고, 그 외의 모든 자원에 대한 요청은 인증을 요구하도록 한다. 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http. authorizeRequests() .anyRequest().authenticated(); http .formLogin() // Form Login을 이용한 인증 방식을 사용 .loginPage(&quot;/login&quot;) // Login Page로 redirect할 경로를 적어준다. .defaultSuccessUrl(&quot;/&quot;, true) // 로그인 성공후 이동할 경로 .permitAll() ;&#125; Service생성하기Spring Security는 인증 과정에서 UserDetails를 구현한 객체를 이용한다. 따라서 Service를 생성하기 위해서는 UserDetailsService를 이용해 Service를 만든다. UserDetialsService 인터페이스는 loadUserByUsername 메서드가 있는데, username을 이용해 DB로부터 사용자 정보를 얻어와 UserDetails를 반환하는 메서드이다. 12345678910111213141516171819202122232425@Service@RequiredArgsConstructorpublic class CustomUserDetailsService implements UserDetailsService &#123; private final AccountRepository accountRepository; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123; // return new User(&quot;user&quot;, passwordEncoder.encode( &quot;1234&quot;), new ArrayList&lt;&gt;()); Optional&lt;Account&gt; optional = accountRepository.findByEmail(email); if(optional.isPresent())&#123; Account account = optional.get(); return new SecurityAccount(account); &#125;else&#123; throw new UsernameNotFoundException(email + &quot;사용자 없음&quot;); &#125; &#125; public void saveAccount(Account account)&#123; accountRepository.save(account); &#125;&#125; DB로부터 User정보를 가져와 UserDetails객체로 반환UserDetailsService인터페이스를 구현하면서username을 매게변수로 받는 loadUserByUsername메소드를 Overriding해,DB에 접근해 User정보를 가져오고 해당 객체를 UserDetails객체를 반환하도록 Overriding 해준다. loadUserByUsername메소드를 Overriding 해줘야 한다. loadUserByUsername메소드는 username을 매게변수로 받아 username을 이용해 DB로부터 User정보를 가져오고 해당 객체를 UserDetails객체로 반환하도록 Overriding 해준다. 123456789101112@Overridepublic UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123; // return new User(&quot;user&quot;, passwordEncoder.encode( &quot;1234&quot;), new ArrayList&lt;&gt;()); Optional&lt;Account&gt; optional = accountRepository.findByEmail(email); if(optional.isPresent())&#123; Account account = optional.get(); return new SecurityAccount(account); &#125;else&#123; throw new UsernameNotFoundException(email + &quot;사용자 없음&quot;); &#125;&#125; User객체 생성하기Spring Security는 인증시 UserDetails객체를 사용하므로 Account객체를 UserDetails객체로 변환해줘야 한다. Spring Security에서는 UserDetails를 객체를 쉽게 만들 수 있도록 UserDetails를 구현한 User객체를 지원한다. 1234567public class SecurityAccount extends User &#123; public SecurityAccount(Account account)&#123; super(account.getEmail() , account.getPassword() , AuthorityUtils.createAuthorityList(account.getRole().getValue())); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Form login","slug":"Spring-Boot/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Form-login/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Form","slug":"Form","permalink":"https://ckck803.github.io/tags/Form/"}]},{"title":"Spring Security Form Login - 1. 기본적인 모델 정의하기","slug":"springboot/security/Form-Login/form-login-modeling","date":"2021-01-27T18:54:27.000Z","updated":"2021-03-13T11:31:17.682Z","comments":true,"path":"2021/01/28/springboot/security/Form-Login/form-login-modeling/","link":"","permalink":"https://ckck803.github.io/2021/01/28/springboot/security/Form-Login/form-login-modeling/","excerpt":"","text":"Spring properties 설정하기Spring Security에서 사용하는 기본적인 user정보를 등록한다. jpa를 사용하므로 관련 옵션도 추가해준다. application.yml123456789101112131415161718spring: security: user: name: user password: 1234 jpa: hibernate: ddl-auto: create-drop properties: hibernate: show_sql: true format_sql: true profiles: include: mysqllogging: level: org.springframework.security: DEBUG application-mysql.yml12345678910spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/&#123;테이블명&#125;?serverTimezone=UTC&amp;characterEncoding=UTF-8 username: user_id password: user_password jpa: database: mysql database-platform: org.hibernate.dialect.MySQL5InnoDBDialect Entity 생성하기사용자 정보를 저장하기 위한 Account Entity를 만든다. 123456789101112131415161718192021222324252627282930@Entity@NoArgsConstructor@AllArgsConstructor@Getterpublic class Account &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long idx; private String username; @Column(unique = true, nullable = false) private String email; private String password; @Enumerated(EnumType.STRING) private Role role; private String getRoleValue()&#123; return this.role.getValue(); &#125; @Builder public Account(String username, String email, String password, Role role)&#123; this.username = username; this.email = email; this.password = password; this.role = role; &#125;&#125; 권한을 지정하기위한 Role123456789101112public enum Role &#123; USER(&quot;ROLE_USER&quot;), ADMIN(&quot;ROLE_ADMIN&quot;); private String value; Role(String value)&#123; this.value = value; &#125; public String getValue()&#123; return this.value; &#125;&#125; DB로부터 사용자 정보를 가져오기 위한 Repository123@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Long&gt; &#123; public Optional&lt;Account&gt; findByEmail(String email);&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Form login","slug":"Spring-Boot/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Form-login/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"Form","slug":"Form","permalink":"https://ckck803.github.io/tags/Form/"}]},{"title":"백준 1726 - 로봇","slug":"algorithm/baekjoon/BFS/1726","date":"2020-01-29T06:28:53.000Z","updated":"2021-03-19T17:11:13.223Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1726/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1726/","excerpt":"","text":"링크https://www.acmicpc.net/problem/1726 채점 현황 전체 소스 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int M, N;int map[101][101];bool check[101][101][4];int dx[4] = &#123;0, 1, -1, 0&#125;;int dy[4] = &#123;-1, 0, 0, 1&#125;;// char dir[4] = &#123; &#x27;N&#x27;, &#x27;E&#x27;, &#x27;W&#x27;, &#x27;S&#x27; &#125;;struct point &#123; int y; int x; int dir;&#125;;int main(void) &#123; cin &gt;&gt; M &gt;&gt; N; for (int i = 1; i &lt;= M; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; point start, goal; int tempY, tempX, tempD; cin &gt;&gt; tempY &gt;&gt; tempX &gt;&gt; tempD; start.y = tempY; start.x = tempX; start.dir = tempD % 4; cin &gt;&gt; tempY &gt;&gt; tempX &gt;&gt; tempD; goal.y = tempY; goal.x = tempX; goal.dir = tempD % 4; queue&lt;point&gt; q; q.push(start); check[start.y][start.x][start.dir] = true; int num = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int y = q.front().y; int x = q.front().x; int d = q.front().dir; q.pop(); if (y == goal.y &amp;&amp; x == goal.x &amp;&amp; d == goal.dir) &#123; cout &lt;&lt; num &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; int nextR, nextL; if (d == 0) &#123; nextR = 1; nextL = 2; &#125; else if (d == 1) &#123; nextR = 3; nextL = 0; &#125; else if (d == 2) &#123; nextR = 0; nextL = 3; &#125; else if (d == 3) &#123; nextR = 2; nextL = 1; &#125; if (check[y][x][nextR] == false) &#123; check[y][x][nextR] = true; q.push(&#123;y, x, nextR&#125;); &#125; if (check[y][x][nextL] == false) &#123; check[y][x][nextL] = true; q.push(&#123;y, x, nextL&#125;); &#125; for (int i = 1; i &lt;= 3; i++) &#123; int nx = x + dx[d] * i; int ny = y + dy[d] * i; if (1 &lt;= ny &amp;&amp; ny &lt;= M &amp;&amp; 1 &lt;= nx &amp;&amp; nx &lt;= N) &#123; if (map[ny][nx] == 1) &#123; break; &#125; if (check[ny][nx][d] == false) &#123; check[ny][nx][d] = true; q.push(&#123;ny, nx, d&#125;); &#125; &#125; &#125; &#125; num++; // for (int i = 1; i &lt;= M; i++) &#123; // for (int j = 1; j &lt;= N; j++) &#123; // cout &lt;&lt; check[i][j][3] &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; // &#125; // cout &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"틀렸습니다 1","slug":"틀렸습니다-1","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-1/"}]},{"title":"1707 이분 그래프","slug":"algorithm/baekjoon/BFS/1707","date":"2020-01-29T06:23:28.000Z","updated":"2021-03-19T17:09:25.739Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1707/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1707/","excerpt":"","text":"링크https://www.acmicpc.net/problem/1707 채점 현황 전체 소스 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int T, V, E;vector&lt;vector&lt;int&gt;&gt; arr;bool check[20002];bool colorCheck[20002];int color[20002];void paintColor(int cnt, int cntColor) &#123; for (int i = 0; i &lt; arr[cnt].size(); i++) &#123; int next = arr[cnt][i]; if (check[next] == false) &#123; if (cntColor == 1) &#123; color[next] = 2; check[next] = true; paintColor(next, 2); &#125; else &#123; color[next] = 1; check[next] = true; paintColor(next, 1); &#125; &#125; &#125;&#125;bool confirmColor(int cnt) &#123; bool isTrue = true; for (int i = 0; i &lt; arr[cnt].size(); i++) &#123; int next = arr[cnt][i]; if (color[cnt] != color[next]) &#123; if (colorCheck[next] == false) &#123; colorCheck[next] = true; isTrue = confirmColor(next); &#125; &#125; else &#123; return false; &#125; &#125; return isTrue;&#125;int main(void) &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; V &gt;&gt; E; arr = vector&lt;vector&lt;int&gt;&gt;(V + 1); for (int i = 0; i &lt; E; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; arr[x].push_back(y); arr[y].push_back(x); &#125; for (int i = 1; i &lt;= V; i++) &#123; if (check[i] == false) &#123; check[i] = true; color[i] = 1; paintColor(i, 1); &#125; &#125; bool isTrue; for (int i = 1; i &lt;= V; i++) &#123; if (colorCheck[i] == false) &#123; colorCheck[i] = true; isTrue = confirmColor(i); if (isTrue == false) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#x27;\\n&#x27;; break; &#125; &#125; &#125; if (isTrue == true) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; for (int i = 1; i &lt;= V; i++) &#123; check[i] = 0; colorCheck[i] = false; color[i] = 0; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"틀렸습니다 4","slug":"틀렸습니다-4","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-4/"}]},{"title":"백준 1600 - 말이 되고픈 원숭이","slug":"algorithm/baekjoon/BFS/1600","date":"2020-01-29T06:19:42.000Z","updated":"2021-03-19T17:10:59.488Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1600/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1600/","excerpt":"","text":"링크https://www.acmicpc.net/problem/1600 체점 현황 문제 풀이 말처럼 뛸 수 있는 횟수(k), width, height를 입력 받는다. field에 대한 정보를 입력 받는다. (0, 0)에서 시작해 (width-1, height-1)까지 갈 수 있는 최소 횟수를 탐색한다. 원숭이가 움직일 수 있는 방법은 두가지가 존재한다. 말처럼 뛸 수 있는 방법(k내의 횟수에서) 상하좌우로 움직일 수 있는 방법 말이 (width-1, height-1)에 도착하면 그 횟수를 반환한다. 만약 도착하지 못할 경우 -1을 반환한다. 말이 움직인 횟수를 출력해준다. 전체 소스 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;int numOfKnight;int width, height;int field[202][202];bool check[31][202][202];int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;int horse_dx[8] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;int horse_dy[8] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;struct point &#123; int k; int y; int x;&#125;;int bfs(int y, int x) &#123; check[0][y][x] = true; queue&lt;point&gt; q; q.push(&#123;0, y, x&#125;); int count = 0; while (!q.empty()) &#123; int q_size = q.size(); while (q_size--) &#123; int cntK = q.front().k; int cntY = q.front().y; int cntX = q.front().x; q.pop(); if (cntY == height - 1 &amp;&amp; cntX == width - 1) &#123; return count; &#125; if (cntK &lt; numOfKnight) &#123; for (int i = 0; i &lt; 8; i++) &#123; int ny = cntY + horse_dy[i]; int nx = cntX + horse_dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) continue; if (field[ny][nx] == 0 &amp;&amp; check[cntK + 1][ny][nx] == false) &#123; check[cntK + 1][ny][nx] = true; q.push(&#123;cntK + 1, ny, nx&#125;); &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) continue; if (field[ny][nx] == 0 &amp;&amp; check[cntK][ny][nx] == false) &#123; check[cntK][ny][nx] = true; q.push(&#123;cntK, ny, nx&#125;); &#125; &#125; &#125; count++; &#125; return -1;&#125;int main(void) &#123; cin &gt;&gt; numOfKnight &gt;&gt; width &gt;&gt; height; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; cin &gt;&gt; field[i][j]; &#125; &#125; int minValueOfMove = bfs(0, 0); cout &lt;&lt; minValueOfMove &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"}]},{"title":"백준 1260 - DFS와 BFS","slug":"algorithm/baekjoon/DFS/1260","date":"2020-01-29T06:16:03.000Z","updated":"2021-03-19T17:08:48.743Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/DFS/1260/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/DFS/1260/","excerpt":"","text":"링크https://www.acmicpc.net/problem/1260 문제 풀이그래프탐색에 있어 가장 기본적인 DFS, BFS를 사용해볼 수 있는 유형이다. 좌표 자체가 존재하지 않아 1차원적인 check방식을 통해 탐색해 나간다. cpp 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;// 점점의 개수 : N, 간산의 개수 M, 탐색을 시작할 정점의 번호 Vint N, M, V;bool check_dfs[1010];bool check_bfs[1010];int graph[1010][1010];void bfs(int start) &#123; queue&lt;int&gt; q; q.push(start); check_bfs[start] = true; while (!q.empty()) &#123; int cnt = q.front(); q.pop(); cout &lt;&lt; cnt &lt;&lt; &#x27; &#x27;; for (int i = 1; i &lt;= N; i++) &#123; if (graph[cnt][i] == 1 &amp;&amp; check_bfs[i] == false) &#123; check_bfs[i] = true; q.push(i); &#125; &#125; &#125;&#125;void dfs(int depth, int cnt) &#123; check_dfs[cnt] = true; if (N &lt;= depth) &#123; return; &#125; cout &lt;&lt; cnt &lt;&lt; &#x27; &#x27;; for (int i = 1; i &lt;= N; i++) &#123; if (graph[cnt][i] == 1 &amp;&amp; check_dfs[i] == false) &#123; dfs(depth + 1, i); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; V; for (int i = 0; i &lt; M; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; graph[a][b] = 1; graph[b][a] = 1; &#125; dfs(0, V); cout &lt;&lt; &#x27;\\n&#x27;; bfs(V); return 0;&#125; java 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.IOException;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class Main &#123; static int n, m, v; static int map[][]; static boolean bfs_check[]; static boolean dfs_check[]; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); v = sc.nextInt(); map = new int[n + 1][n + 1]; for (int i = 0; i &lt; m; i++) &#123; int from, to; from = sc.nextInt(); to = sc.nextInt(); map[from][to] = 1; map[to][from] = 1; &#125; bfs_check = new boolean[n + 1]; dfs_check = new boolean[n + 1]; dfs(v); System.out.println(); bfs(v); sc.close(); &#125; static void dfs(int node) &#123; System.out.print(Integer.toString(node) + &#x27; &#x27;); dfs_check[node] = true; for (int i = 1; i &lt;= n; i++) &#123; if (map[node][i] == 1 &amp;&amp; dfs_check[i] == false) &#123; dfs(i); &#125; &#125; &#125; static void bfs(int start) &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); q.offer(start); bfs_check[start] = true; System.out.print(Integer.toString(start) + &#x27; &#x27;); while (!q.isEmpty()) &#123; int cnt = q.remove(); for (int i = 1; i &lt;= n; i++) &#123; if (map[cnt][i] == 1 &amp;&amp; bfs_check[i] == false) &#123; bfs_check[i] = true; q.offer(i); System.out.print(Integer.toString(i) + &#x27; &#x27;); &#125; &#125; &#125; &#125;&#125; python 코드1234567891011121314151617181920212223242526272829303132333435def bfs(start): queue = [start] bfs_check = [start] while queue: cnt_node = queue.pop(0) for next_node in range(len(matrix[cnt_node])): if(matrix[cnt_node][next_node] == 1 and next_node not in bfs_check): bfs_check.append(next_node) queue.append(next_node) return bfs_checkdef dfs(cnt_node): dfs_check.append(cnt_node) for next_node in range(len(matrix[cnt_node])): if(matrix[cnt_node][next_node] == 1 and next_node not in dfs_check): dfs(next_node)N, M, V = map(int, input().split())matrix = [[0] * (N+1) for i in range(N+1)]dfs_check = []for i in range(M): point = list(map(int, input().split())) matrix[point[0]][point[1]] = 1 matrix[point[1]][point[0]] = 1dfs(V)print(*dfs_check)print(*bfs(V))","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"C++","slug":"C","permalink":"https://ckck803.github.io/tags/C/"},{"name":"DFS","slug":"DFS","permalink":"https://ckck803.github.io/tags/DFS/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"Python","slug":"Python","permalink":"https://ckck803.github.io/tags/Python/"}]},{"title":"백준 1012 - 유기농 배추","slug":"algorithm/baekjoon/BFS/1012","date":"2020-01-29T04:08:11.000Z","updated":"2021-03-19T17:08:41.068Z","comments":true,"path":"2020/01/29/algorithm/baekjoon/BFS/1012/","link":"","permalink":"https://ckck803.github.io/2020/01/29/algorithm/baekjoon/BFS/1012/","excerpt":"","text":"링크https://www.acmicpc.net/problem/1012 채점 현황 문제 풀이전형적인 색칠하기 유형히다.이 문제는 testcase문제이기 때문에 각 case마다 데이터를 초기화 해줘야 한다. field를 탐색하면서 배추가 심어져 있는 위치를 찾는다. 배추가 심어져 있는 곳을 찾았다면 이전에 탐색을 했는지 확인한다. 탐색한 적이 없다면 다음으로 넘어간다. 탐색한 적이 있다면 1로 돌아간다. 배추가 심어져 있는 주변에 다른 배추들이 있는지 탐색한다. 탐색횟수가 배추 흰 지렁이의 갯수가 된다. BFS를 이용한 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;int field[55][55];bool check[55][55];int width, height;int test_case;int num_of_cabbage;int num_of_warm;void init() &#123; for (int i = 0; i &lt; 55; i++) &#123; for (int j = 0; j &lt; 55; j++) &#123; field[i][j] = 0; check[i][j] = false; &#125; &#125; num_of_warm = 0;&#125;void bfs(int y, int x) &#123; num_of_warm++; check[y][x] = true; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;y, x&#125;); while (!q.empty()) &#123; int cnt_y = q.front().first; int cnt_x = q.front().second; q.pop(); for (int i = 0; i &lt; 4; i++) &#123; int ny = cnt_y + dy[i]; int nx = cnt_x + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) &#123; continue; &#125; if (check[ny][nx] == true) &#123; continue; &#125; if (field[ny][nx] == 0) &#123; continue; &#125; check[ny][nx] = true; q.push(&#123;ny, nx&#125;); &#125; &#125;&#125;int main(void) &#123; cin &gt;&gt; test_case; while (test_case--) &#123; cin &gt;&gt; width &gt;&gt; height &gt;&gt; num_of_cabbage; init(); for (int i = 0; i &lt; num_of_cabbage; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; field[y][x] = 1; &#125; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; if (field[i][j] == 1 &amp;&amp; check[i][j] == false) &#123; bfs(i, j); &#125; &#125; &#125; cout &lt;&lt; num_of_warm &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; DFS를 이용한 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;int field[55][55];bool check[55][55];int test_case, width, height;int num_of_cabbage;int num_of_warm;int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;void init() &#123; for (int i = 0; i &lt; 55; i++) &#123; for (int j = 0; j &lt; 55; j++) &#123; field[i][j] = 0; check[i][j] = false; &#125; &#125; num_of_warm = 0;&#125;void dfs(int y, int x) &#123; check[y][x] = true; for (int i = 0; i &lt; 4; i++) &#123; int ny = y + dy[i]; int nx = x + dx[i]; if (0 &gt; ny || ny &gt;= height || 0 &gt; nx || nx &gt;= width) &#123; continue; &#125; if (check[ny][nx] == true) &#123; continue; &#125; if (field[ny][nx] == 0) &#123; continue; &#125; dfs(ny, nx); &#125;&#125;int main(void) &#123; cin &gt;&gt; test_case; while (test_case--) &#123; cin &gt;&gt; width &gt;&gt; height &gt;&gt; num_of_cabbage; init(); for (int i = 0; i &lt; num_of_cabbage; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; field[y][x] = true; &#125; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; if (field[i][j] == 1 &amp;&amp; check[i][j] == false) &#123; num_of_warm++; dfs(i, j); &#125; &#125; &#125; cout &lt;&lt; num_of_warm &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 자바를 이용한 풀이1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class Main &#123; static int Map[][] = new int[55][55]; static boolean check[][] = new boolean[55][55]; static int dy[] = &#123; 1, 0, -1, 0 &#125;; static int dx[] = &#123; 0, 1, 0, -1 &#125;; static int testCase; static int row; static int col; static int num; static int result; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); testCase = sc.nextInt(); while (testCase-- &gt; 0) &#123; result = 0; for (int i = 0; i &lt; 55; i++) &#123; for (int j = 0; j &lt; 55; j++) &#123; Map[i][j] = 0; check[i][j] = false; &#125; &#125; row = sc.nextInt(); col = sc.nextInt(); num = sc.nextInt(); for (int i = 0; i &lt; num; i++) &#123; int x, y; x = sc.nextInt(); y = sc.nextInt(); Map[y][x] = 1; &#125; for (int i = 0; i &lt; col; i++) &#123; for (int j = 0; j &lt; row; j++) &#123; if (Map[i][j] == 1 &amp;&amp; check[i][j] == false) &#123; bfs(i, j); &#125; &#125; &#125; System.out.println(result); &#125; &#125; static void bfs(int y, int x) &#123; result++; Queue&lt;int[]&gt; q = new LinkedList(); q.add(new int[] &#123; y, x &#125;); check[y][x] = true; while (!q.isEmpty()) &#123; int point[] = q.remove(); int cntY = point[0]; int cntX = point[1]; for (int i = 0; i &lt; 4; i++) &#123; int ny = cntY + dy[i]; int nx = cntX + dx[i]; if (0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; 0 &lt;= nx &amp;&amp; nx &lt; row) &#123; if (check[ny][nx] == false &amp;&amp; Map[ny][nx] == 1) &#123; check[ny][nx] = true; q.add(new int[] &#123; ny, nx &#125;); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"C++","slug":"C","permalink":"https://ckck803.github.io/tags/C/"}]}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/categories/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Boot/Spring-Security","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/"},{"name":"Programming","slug":"Programming","permalink":"https://ckck803.github.io/categories/Programming/"},{"name":"Beakjoon","slug":"Programming/Beakjoon","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/"},{"name":"자료구조","slug":"Programming/Beakjoon/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Beakjoon/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"},{"name":"Programmers","slug":"Programming/Programmers","permalink":"https://ckck803.github.io/categories/Programming/Programmers/"},{"name":"자료구조","slug":"Programming/Programmers/자료구조","permalink":"https://ckck803.github.io/categories/Programming/Programmers/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"스택","slug":"Programming/Programmers/자료구조/스택","permalink":"https://ckck803.github.io/categories/Programming/Programmers/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%8A%A4%ED%83%9D/"},{"name":"JWT","slug":"Spring-Boot/Spring-Security/JWT","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/JWT/"},{"name":"CS","slug":"CS","permalink":"https://ckck803.github.io/categories/CS/"},{"name":"OS","slug":"CS/OS","permalink":"https://ckck803.github.io/categories/CS/OS/"},{"name":"Network","slug":"CS/Network","permalink":"https://ckck803.github.io/categories/CS/Network/"},{"name":"게시판 만들기","slug":"Spring-Boot/게시판-만들기","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"name":"DataBase","slug":"CS/DataBase","permalink":"https://ckck803.github.io/categories/CS/DataBase/"},{"name":"SQL","slug":"CS/DataBase/SQL","permalink":"https://ckck803.github.io/categories/CS/DataBase/SQL/"},{"name":"Spring","slug":"Spring","permalink":"https://ckck803.github.io/categories/Spring/"},{"name":"Spring5 MVC","slug":"Spring/Spring5-MVC","permalink":"https://ckck803.github.io/categories/Spring/Spring5-MVC/"},{"name":"Spring Core","slug":"Spring-Boot/Spring-Core","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/"},{"name":"스프링 핵심 원리 - 기본편","slug":"Spring-Boot/Spring-Core/스프링-핵심-원리-기본편","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Core/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/"},{"name":"Spring Framework","slug":"Spring-Boot/Spring-Framework","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Framework/"},{"name":"DFS","slug":"Programming/Beakjoon/DFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/DFS/"},{"name":"BFS","slug":"Programming/Beakjoon/BFS","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/BFS/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/"},{"name":"JPA","slug":"Programming/JAVA/JPA","permalink":"https://ckck803.github.io/categories/Programming/JAVA/JPA/"},{"name":"다익스트라","slug":"Programming/Beakjoon/다익스트라","permalink":"https://ckck803.github.io/categories/Programming/Beakjoon/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"},{"name":"강의","slug":"Spring-Boot/강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/"},{"name":"레스토랑 예약 사이트","slug":"Spring-Boot/강의/레스토랑-예약-사이트","permalink":"https://ckck803.github.io/categories/Spring-Boot/%EA%B0%95%EC%9D%98/%EB%A0%88%EC%8A%A4%ED%86%A0%EB%9E%91-%EC%98%88%EC%95%BD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"name":"Spring Rest","slug":"Spring-Boot/Spring-Rest","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/"},{"name":"RESTful Web Services 강의","slug":"Spring-Boot/Spring-Rest/RESTful-Web-Services-강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Rest/RESTful-Web-Services-%EA%B0%95%EC%9D%98/"},{"name":"스프링 시큐리티 강의","slug":"Spring-Boot/Spring-Security/스프링-시큐리티-강의","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EA%B0%95%EC%9D%98/"},{"name":"Oauth2","slug":"Spring-Boot/Spring-Security/Oauth2","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Oauth2/"},{"name":"Form login","slug":"Spring-Boot/Spring-Security/Form-login","permalink":"https://ckck803.github.io/categories/Spring-Boot/Spring-Security/Form-login/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://ckck803.github.io/tags/Spring-Boot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://ckck803.github.io/tags/Spring-Security/"},{"name":"beakjoon","slug":"beakjoon","permalink":"https://ckck803.github.io/tags/beakjoon/"},{"name":"틀렸습니다 2","slug":"틀렸습니다-2","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-2/"},{"name":"Java","slug":"Java","permalink":"https://ckck803.github.io/tags/Java/"},{"name":"Programmers","slug":"Programmers","permalink":"https://ckck803.github.io/tags/Programmers/"},{"name":"JWT","slug":"JWT","permalink":"https://ckck803.github.io/tags/JWT/"},{"name":"CRUD","slug":"CRUD","permalink":"https://ckck803.github.io/tags/CRUD/"},{"name":"Logging","slug":"Logging","permalink":"https://ckck803.github.io/tags/Logging/"},{"name":"Github Action","slug":"Github-Action","permalink":"https://ckck803.github.io/tags/Github-Action/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://ckck803.github.io/tags/Jenkins/"},{"name":"nginx","slug":"nginx","permalink":"https://ckck803.github.io/tags/nginx/"},{"name":"properties","slug":"properties","permalink":"https://ckck803.github.io/tags/properties/"},{"name":"Github","slug":"Github","permalink":"https://ckck803.github.io/tags/Github/"},{"name":"Spring Core","slug":"Spring-Core","permalink":"https://ckck803.github.io/tags/Spring-Core/"},{"name":"AutoConfiguration","slug":"AutoConfiguration","permalink":"https://ckck803.github.io/tags/AutoConfiguration/"},{"name":"Spring Framework","slug":"Spring-Framework","permalink":"https://ckck803.github.io/tags/Spring-Framework/"},{"name":"MVC","slug":"MVC","permalink":"https://ckck803.github.io/tags/MVC/"},{"name":"IoC 컨테이너","slug":"IoC-컨테이너","permalink":"https://ckck803.github.io/tags/IoC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/"},{"name":"Beakjoon","slug":"Beakjoon","permalink":"https://ckck803.github.io/tags/Beakjoon/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://ckck803.github.io/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://ckck803.github.io/tags/%EC%82%BC%EC%84%B1-%EA%B8%B0%EC%B6%9C/"},{"name":"틀렸습니다 5","slug":"틀렸습니다-5","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-5/"},{"name":"JPA","slug":"JPA","permalink":"https://ckck803.github.io/tags/JPA/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://ckck803.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"},{"name":"jenkins","slug":"jenkins","permalink":"https://ckck803.github.io/tags/jenkins/"},{"name":"error","slug":"error","permalink":"https://ckck803.github.io/tags/error/"},{"name":"paging","slug":"paging","permalink":"https://ckck803.github.io/tags/paging/"},{"name":"Spring Rest","slug":"Spring-Rest","permalink":"https://ckck803.github.io/tags/Spring-Rest/"},{"name":"강의","slug":"강의","permalink":"https://ckck803.github.io/tags/%EA%B0%95%EC%9D%98/"},{"name":"HTTP Status Code","slug":"HTTP-Status-Code","permalink":"https://ckck803.github.io/tags/HTTP-Status-Code/"},{"name":"Exception Handling","slug":"Exception-Handling","permalink":"https://ckck803.github.io/tags/Exception-Handling/"},{"name":"Oauth2","slug":"Oauth2","permalink":"https://ckck803.github.io/tags/Oauth2/"},{"name":"Form","slug":"Form","permalink":"https://ckck803.github.io/tags/Form/"},{"name":"BFS","slug":"BFS","permalink":"https://ckck803.github.io/tags/BFS/"},{"name":"틀렸습니다 1","slug":"틀렸습니다-1","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-1/"},{"name":"틀렸습니다 4","slug":"틀렸습니다-4","permalink":"https://ckck803.github.io/tags/%ED%8B%80%EB%A0%B8%EC%8A%B5%EB%8B%88%EB%8B%A4-4/"},{"name":"C++","slug":"C","permalink":"https://ckck803.github.io/tags/C/"},{"name":"DFS","slug":"DFS","permalink":"https://ckck803.github.io/tags/DFS/"},{"name":"Python","slug":"Python","permalink":"https://ckck803.github.io/tags/Python/"}]}